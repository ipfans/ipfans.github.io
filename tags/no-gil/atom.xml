<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>No-Gil on ipfans's Blog</title><link>https://www.4async.com/tags/no-gil/</link><description>Recent content in No-Gil on ipfans's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 18 Mar 2024 10:11:00 +0000</lastBuildDate><atom:link href="https://www.4async.com/tags/no-gil/atom.xml" rel="self" type="application/rss+xml"/><item><title>No GIL Python 的冒险</title><link>https://www.4async.com/2024/03/adventure-of-no-gil-python/</link><pubDate>Mon, 18 Mar 2024 10:11:00 +0000</pubDate><guid>https://www.4async.com/2024/03/adventure-of-no-gil-python/</guid><description>&lt;img src="https://www.4async.com/2024/03/adventure-of-no-gil-python/cover.png" alt="Featured image of post No GIL Python 的冒险" />在前几周的时候，Python的允许禁用 GIL PR 正式合并进入了 Python 3.13 的master分支。这是一个非常重要的 PR，因为它在未来将会对 Python 的并发性能产生非常大的影响。在即将到来的 Python 3.13 中，这个允许禁用 GIL和包含了 Copy and Paste JIT 技术，这些同时都对 Python 的性能产生了非常大的影响。
什么是 GIL GIL，即全局解释器锁，是 Python 语言中一个技术术语。官方实现的 CPython 中包含了 GIL 的实现，同时也是最广泛使用的实现。GIL 的主要目的是在任何时候只允许一个线程执行 Python 字节码，这意味着即使你的程序在多核处理器上运行，也无法实现真正的并行执行。GIL 的存在主要是为了简化 CPython 的内存管理。Python 的对象，如列表、字典等，不是线程安全的，这意味着如果多个线程同时从不同的核心修改同一个对象，可能会导致数据不一致或者程序崩溃。GIL 通过限制同时执行的线程数来避免这种情况。
换句话说：如果一个系统线程想要执行 Python 的字节码，必须要获取到 GIL 锁，然后才可以执行 Python 字节码。而如果没有获取到锁，那么线程就会休眠，直到获得信号而被唤醒。为了保证 Python 的效率，Python 也会自动切换线程，比如 IO 阻塞时，或者执行了指定数量的 Python 字节码时。这样就尽量保证了 Python 的效率。当然，你也可以选择手工释放 GIL 锁，比如使用 C/C++/Rust 扩展，或者使用 Cython 等开发高性能扩展时。
但是这个 GIL 也是 Python 的一个瓶颈，因为它限制了 Python 的并发性能。在多核处理器上，Python 的并发性能并不是很好。这也是为什么很多人选择使用多进程而不是多线程来提高 Python 的并发性能。在现代的计算机上，多核处理器已经是标配，因此 Python 的并发性能成为了一个非常重要的问题。这也是为什么这么多年来，Python 的 GIL 一直是一个非常热门的话题。</description></item></channel></rss>