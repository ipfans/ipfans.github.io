<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on ipfans's Blog</title><link>https://www.4async.com/tags/docker/</link><description>Recent content in Docker on ipfans's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 31 May 2016 09:13:00 +0000</lastBuildDate><atom:link href="https://www.4async.com/tags/docker/atom.xml" rel="self" type="application/rss+xml"/><item><title>CoreOS 折腾笔记（三）了解 Etcd</title><link>https://www.4async.com/2016/05/2016-05-31-learning-coreos-part3/</link><pubDate>Tue, 31 May 2016 09:13:00 +0000</pubDate><guid>https://www.4async.com/2016/05/2016-05-31-learning-coreos-part3/</guid><description>服务发现是微服务化架构中重要的一环，服务的配置信息需要有一种可靠高效的发现机制，保证服务上线时可以及时被使用，服务失效中断时可以及时切走。服务发现工具 Etcd 就是为了这种需求开发的。
什么是 Etcd？ Etcd 是一个分布式 KV 数据库，通过将数据分散存储在多台独立的设备上，从而提高数据的可靠性或读写性能。Etcd 是几个比较常见的服务发现应用之一，它支持 TTL 的支持和 HTTP Restful API，同时通过 Raft 一致性算法处理日志复制以保证强一致性。关于 Raft 算法，请参考 这篇文章，这里不多介绍。Etcd 本来就是 CoreOS 团队开发支持的，因此也是原生存在在 CoreOS 系统中。
Etcd 中提供了订阅通知机制，同时提供了一个线上服务 https://discovery.etcd.io/，这个服务可以用于发现集群中的机器。比如 Fleet 等等工具也是基于 Etcd 去发现网络中的节点服务器。在 CoreOS 机器部署之后，系统中一个叫做 cloud-init 的服务会根据之前的 user-data 文件去启动 Etcd。Etcd 会更新对应的自己的节点信息，并且获取其它的节点信息。
另外比较常见的服务发现还有 ZooKeeper（应用最广泛）、Consul 等等，如果有兴趣，可以自己在进行研究。
Etcdctl 使用 工具 etcdctl 是 etcd 的控制程序，我们可以通过执行命令查看所有键值：
core@core-01 ~ $ etcdctl ls / --recursive /coreos.com /coreos.com/network /coreos.com/network/config /coreos.com/network/subnets /coreos.com/network/subnets/10.1.64.0-24 /coreos.com/network/subnets/10.1.48.0-24 /coreos.com/network/subnets/10.1.10.0-24 /coreos.com/updateengine /coreos.com/updateengine/rebootlock /coreos.com/updateengine/rebootlock/semaphore 还可以通过类似 Redis 的 get 等命令获取具体存储内容：</description></item><item><title>CoreOS 折腾笔记（二）Fleet 进阶</title><link>https://www.4async.com/2016/05/2016-05-28-learning-coreos-part2/</link><pubDate>Sat, 28 May 2016 18:00:00 +0000</pubDate><guid>https://www.4async.com/2016/05/2016-05-28-learning-coreos-part2/</guid><description>如果要说什么样子的分布式集群对用户是最友好的，那无疑是对客户来说，像本地执行命令一样方便的执行集群命令肯定是最舒服的了。这个我们在上一节 集群部署 里面就提到了一个叫做 &amp;ldquo;fleetctl&amp;rdquo; 的命令，这个命令是做什么用的呢？
fleet 是什么 工具 fleet 是一个在集群层面上的 systemd 管理工具。它的配置文件语法基于 systemd 的语法，另外添加了一些自有的属性。如果你希望在集群中运行你的服务，那么使用 fleet 管理 systemd 单元是再有必要不过的了。
在比较新的系统 (CentOS 7+、Ubuntu 16+、Debian 8+) 中均采用了 systemd 作为启动项管理工具。如果你对 systemd 有疑问的话，请到其 官方网站 查看具体的介绍，这里不做赘述。
之前使用的 fleetctl 就是 fleet 的管理工具，默认是在集群中的某台机器上进行管理。当然，fleetctl 同样也可以通过远程进行管理，可以通过如下命令连接远程集群。
FLEETCTL_ENDPOINT=http://&amp;lt;IP:[PORT]&amp;gt; fleetctl list-units fleetctl 常见命令 比较常见的 fleetctl 命令有：
core@core-01 ~ $ fleetctl -h ... COMMANDS: cat 查看已经提交的单元文件内容 destroy 销毁集群中的一个或多个单元 fd-forward 将标准输入输出转向到一个 unix socket 中 journal 将集群中的某个 unit 的日志输出到当前 list-machines 查看集群中的已知机器 list-unit-files 查看集群中存在的单元 list-units 查看集群中的单元状态 load 将一个或多个单元加载到集群中，必要时会先执行 submit 功能 ssh 连接到集群中的某台机器 start 启动集群中一个或多个单元，必要时会先执行 submit 和 load 功能 status 输出集群中一个或多个单元的状态 stop 停止集群中一个或多个单元 submit 上传一个或多个单元到集群中，并不会加载执行 unload 卸载集群中的一个或多个单元 fleet 单元文件 以一个 Hello World 程序作为演示来讲解：</description></item><item><title>CoreOS 折腾笔记（一）集群部署</title><link>https://www.4async.com/2016/05/2016-05-28-learning-coreos-part1/</link><pubDate>Sat, 28 May 2016 17:00:00 +0000</pubDate><guid>https://www.4async.com/2016/05/2016-05-28-learning-coreos-part1/</guid><description>最近在技改完成之后打算进行大量的微服务化改造，而方便进行微服务化的步骤之一，就是将现有的系统移植进入 Docker 环境之中。在标准容器系统的选择上，我把目光放在了 CoreOS 上。实际上，我在 CoreOS 版本还是 2 开头的时候就有简单研究过，但是当时主要作为研究 Docker 的途径，现在则是作为集群化部署的基准系统。从本文开始的一系列折腾则是我在研究 CoreOS 集群化使用的一些纪录，而本文就是介绍一个本地实现容器化机群的步骤。
安装 Vagrant 略，因为太简单了。另外还需要 VirtualBox，不要忘记装。
配置 CoreOS-vagrant 执行以下命令：
git clone https://github.com/coreos/coreos-vagrant.git cd coreos-vagrant 下载 CoreOS 的 vagrant 配置。值得在进入正式配置之前一提的是，CoreOS 本身是没有默认密码或者安装密码机制的，也就是说，现有的所有认证登录需要通过 SSH 进行。如果是通过 vagrant 安装，会自动生成登录需要的 SSH 密钥，这个是需要额外注意的内容。
首先，将仓库中提供的两个模版配置文件复制成正式，接下来需要修改对应的文件：
cp config.rb.sample config.rb cp user-data.sample user-data 首先修改 config.rb 文件。这里重点是两个参数，一个是启动的实例数量，另外一个是升级的版本，我修改成了
$num_instances=4 $update_channel=&amp;#39;stable&amp;#39; 启动 4 个实例，升级选择的版本则是月度升级版。另外一个 user-data 暂时不作修改。
接下来执行：
vagrant up 在一堆输出之后，生成的 4 个实例就已经在运行了。也可以通过命令 vagrant status 查看运行状态。
➜ coreos-vagrant git:(master) vagrant status Current machine states: core-01 running (virtualbox) core-02 running (virtualbox) core-03 running (virtualbox) core-04 running (virtualbox) This environment represents multiple VMs.</description></item><item><title>初识 Docker</title><link>https://www.4async.com/2014/06/2014-06-01-try-docker-with-coreos/</link><pubDate>Tue, 10 Jun 2014 11:52:15 +0000</pubDate><guid>https://www.4async.com/2014/06/2014-06-01-try-docker-with-coreos/</guid><description>Docker 是一个最近非常风行的轻量级应用容器。如果不知道的同学自行搜索去吧，这里不在赘述了。针对于 Docker，有个初创公司推出了适用于 Docker 专用的 Linux：CoreOS。一个号称系统运行内存只占用 161MB 的精简系统。这个 CoreOS 只提供了 Docker 需要的必须环境和管理功能，因此很轻量级，非常适合批量部署和我们这种用来研究学习目的的。
值得一提的是里面的管理工具也是由 Golang 开发的，提供 json api 接口，有兴趣的话可以自行查看源代码。
安装必须软件 必须软件需要 Vargrant 和 VirtualBox。Vargrant 可以当作是一个虚拟机和镜像管理器，VirtualBox 我就不用说了吧。安装下载就不说立刻，下载安装地址见下：
http://www.vagrantup.com/downloads.html https://www.virtualbox.org/wiki/Downloads CoreOS 配置 CoreOS 的 Vargrant 脚本可以在 https://github.com/coreos/coreos-vagrant/ 找到，下载下来的方法很简单：
git clone https://github.com/coreos/coreos-vagrant/ cd coreos-vagrant 然后执行命令直接开启虚拟机了：
vagrant up 如果第一次执行，会下载 CoreOS 的镜像，站点在国外，难免会慢一点，不过也没啥关系，稍微等一下吧，如果出现问题了，就重新执行一下。
如果出现下面错误：
You specified a box version constraint with a direct box file path. Box version constraints only work with boxes from Vagrant Cloud or a custom box host.</description></item></channel></rss>