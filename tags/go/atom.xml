<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on ipfans's Blog</title><link>https://www.4async.com/tags/go/</link><description>Recent content in Go on ipfans's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 25 Jan 2023 09:39:00 +0000</lastBuildDate><atom:link href="https://www.4async.com/tags/go/atom.xml" rel="self" type="application/rss+xml"/><item><title>Twirp初相识</title><link>https://www.4async.com/2023/01/twirp-first-step/</link><pubDate>Wed, 25 Jan 2023 09:39:00 +0000</pubDate><guid>https://www.4async.com/2023/01/twirp-first-step/</guid><description>&lt;img src="https://www.4async.com/2023/01/twirp-first-step/cover.png" alt="Featured image of post Twirp初相识" />什么是Twirp？ Twirp是Twitch在2018年开源的RPC框架。正如同他们在发布文章中说的那样，RPC相对于普通的RESTful API更方便设计、组织和维护，让开发者更加专注于业务。但是同样的，在Go社区中重要的gRPC方案严重与HTTP/2绑定，这也成为一个制约其推广的问题：HTTP/2的复杂性其实并不必要；与Go Runtime的割裂也是另外一个问题，导致部分优化难以直接通过升级Go版本在gRPC上显现。
Twirp则选择保留了部分好的地方：使用Protobuf这个IDL约束请求/返回类型，这样可以最大化借助Protobuf带来的优势，生成客户端和服务端代码。但是Twirp选择与Go标准库集成，这样可以更好的利用Go本身升级带来的优化。这同时也保证了Twirp本身的简洁性。同时，你也可以很方便的使用cURL等传统工具，借助json请求测试，而不需要手工处理二进制数据。同样的，借助Go标准库，未来Twirp可以更好的升级成HTTP/3而不是像gRPC一样等待上游更新。当然如果你更倾向于使用gRPC相关的实践，那么connect-go可能是你的另外一个不错选择。
当然，如果说缺点，Twirp并不完美：小众的社区，缺少生态，缺少相关信息内容等等。不过这些仍旧是瑕不掩瑜。毕竟实现一个相关的功能其实并不那么复杂。
如何使用Twirp Twirp虽然官网比较简单，甚至社区也不是很大的样子，但是基本上需求的数据基本都可以在官网上找到入口。但是这也有个问题，导致整个流程对新手并不友好，有比较高的上手门槛。接下来的内容主要是完善这部分的内容，方便新手用户使用。
安装Protobuf相关工具 由于Twirp同样使用Protobuf，我们需要使用相关工具。首先是Protobuf，接下来是一些protoc-gen工具：
brew install protobuf # Mac Only go install google.golang.org/protobuf/cmd/protoc-gen-go@latest go install github.com/twitchtv/twirp/protoc-gen-twirp@latest 可选项：Buf Buf是一个Protobuf管理工具，帮助你实现Schema Driven Development实践。它提供了一个CLI管理工具（支持lint，生成和破坏性检查等功能）和类似注册中心机制的BSR(Buf Schema Registry)，你可以在这里管理你的Schema版本和引用其他公开服务的Schema。不使用Buf并不会带来功能缺失，并且Buf提供了付费SaaS服务(测试期间免费)，可以根据你的情况选择是否使用。
brew install bufbuild/buf/buf # Mac Only 可选项：Taskfile Taskfile是我常用来替代Makefile的工具。这并不是必须的工具，你同样可以使用手工执行命令行和Makefile命令进行。事实上，使用Makefile其实可以更好的在Jenkins之类的pipeline里执行，但是对Github Action等现代pipeline而言，区别并不大。
brew install go-task/tap/go-task # Mac Only 生成项目文件 这里我们使用一个简单的Greeter程序演示使用。假设我们已经存在了一个Go的空项目，那么我们接下来需要创建对应的目录和文件。按照官方的建议，我们可以使用如下结构创建我们的项目，你可以在Github上查看完整的代码：
$ tree . . ├── README.md ├── Taskfile.yaml ├── buf.gen-ts.yaml ├── buf.gen.yaml ├── buf.yaml ├── build ├── client │ ├── package.json │ ├── pnpm-lock.yaml │ └── src │ └── protoc-gen-twirp-es.</description></item><item><title>Twirp基本概念：Hooks和Interceptors</title><link>https://www.4async.com/2023/01/twirp-hooks-and-interceptors/</link><pubDate>Wed, 25 Jan 2023 09:39:00 +0000</pubDate><guid>https://www.4async.com/2023/01/twirp-hooks-and-interceptors/</guid><description>&lt;img src="https://www.4async.com/2023/01/twirp-hooks-and-interceptors/cover.png" alt="Featured image of post Twirp基本概念：Hooks和Interceptors" />Twirp做了足够多的抽象工作，使得我们可以在不同的层次上进行扩展。在最基础的使用层面上，你可以像net/http一样去简单的使用。但是往往这样也不能满足我们实际项目中的需求在这篇文章中，我们将介绍Twirp的Hooks和Interceptors基本概念，以及如何使用这些Twirp的扩展机制。</description></item></channel></rss>