<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TDD on ipfans's Blog</title><link>https://www.4async.com/tags/tdd/</link><description>Recent content in TDD on ipfans's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 10 Jan 2020 17:30:00 +0000</lastBuildDate><atom:link href="https://www.4async.com/tags/tdd/atom.xml" rel="self" type="application/rss+xml"/><item><title>从 Go 语言的依赖库讲起（1）Ginkgo、testify和GoMock</title><link>https://www.4async.com/2020/01/2020-01-10-golang-test-driven-toolkit/</link><pubDate>Fri, 10 Jan 2020 17:30:00 +0000</pubDate><guid>https://www.4async.com/2020/01/2020-01-10-golang-test-driven-toolkit/</guid><description>&lt;p>对开发而言，测试的重要性相信对每个开发者而言是老生常谈的事情。虽然我们很有可能在开发过程中由于各种原因会希望后续补全，然而事实上我更建议采用“Tests that fail then pass”原则去处理在实际开发过程中遇到的问题。&lt;/p>
&lt;p>在我们开发过程的初期阶段，开发质量的保持更多依赖开发人员自身素质保持。但是对一个团队而言，未必能够一直保持人员的高素质开发。在这个过程中，人员的变动，新老编码习惯的冲突，人员能力的残次不齐都有可能导致代码的腐化。在测试过程中，我们选择引入测试保障代码的质量&lt;/p>
&lt;p>Go本身提供了基础的测试功能，但是这个功能在实际使用过程中仍有使用起来功能较弱的问题。比如我们在使用过程中，需要使用额外的库让测试代码更佳高效。在实际实践过程中，我推荐使用&lt;code>Ginkgo&lt;/code>、&lt;code>testify&lt;/code>和&lt;code>GoMock&lt;/code>工具。&lt;/p></description></item><item><title>编写测试友好的 Golang 代码</title><link>https://www.4async.com/2016/04/2016-04-18-writing-testable-golang-code/</link><pubDate>Mon, 18 Apr 2016 18:40:00 +0000</pubDate><guid>https://www.4async.com/2016/04/2016-04-18-writing-testable-golang-code/</guid><description>目前我们有大量的应用采用了 Golang 程序进行构建，但是在执行研发流程里我们会发现一些来自于静态编译程序的不便：相对于我们之前使用的 Python 语言程序而言，我们无法在程序功能的单元测试里大量的使用 Mock 方式来进行高效测试。
而这些东西往往可以在开发人员编写单元测试用例时有效的节省时间和一些额外的环境准备成本。因此，这也给我们的程序的单元覆盖率带来了很多麻烦的地方：一些依赖于额外验证和表现的情况或者小几率出现的情况需要复杂的模拟步骤，对开发进度和效率带来了一些额外的影响。如何编写一个测试友好的 Golang 程序成为一个无法绕开的问题。
从动态语言到静态语言 动态语言有良好的运行时修改属性，在运行时的动态修改函数，可以进行有效的 Mock。比如在 Python（以 3 为例，内置了 unittest.mock 标准库）程序中:
with patch.object(ProductionClass,&amp;#39;method&amp;#39;, return_value=None) as mock_method: thing = ProductionClass() thing.method(1, 2, 3) 自然而然的，我们想到了这样的用法：
var imp = func() bool {return true} func TestFunc(t *testing.T) {defer func(org func() bool) {imp = org}(imp) img = func() bool {return false} // testing or something else... } 这样实现 Mock 是完全可以的，但是实际上会带来一些额外的问题，比如说在 MVC 框架中，我们正常采用的方式一般是这样的：</description></item></channel></rss>