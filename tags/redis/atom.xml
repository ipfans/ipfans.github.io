<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Redis on ipfans's Blog</title><link>https://www.4async.com/tags/redis/</link><description>Recent content in Redis on ipfans's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 30 Oct 2015 23:11:15 +0000</lastBuildDate><atom:link href="https://www.4async.com/tags/redis/atom.xml" rel="self" type="application/rss+xml"/><item><title>从零实现一个 Redis 客户端（二）</title><link>https://www.4async.com/2015/10/2015-10-30-write-aio-python-redis-client-as-dummy-2/</link><pubDate>Fri, 30 Oct 2015 23:11:15 +0000</pubDate><guid>https://www.4async.com/2015/10/2015-10-30-write-aio-python-redis-client-as-dummy-2/</guid><description>从 Call 到命令端 在第一个文章中，我们介绍了实现一个 Call 的客户端基本模型，但只是 Call 怎么能满足需求呢？比如在 redis-py 中，一个完整的客户端应该是这样的：
client = redis.StrictRedis() client.setex(&amp;#34;key&amp;#34;, 10, &amp;#34;value&amp;#34;) 接下来作为一个程序的客户端，需要去做的就是封装出一个 Redis Client。比如 setex 方法：
def setex(self, key, seconds, value): &amp;#34;&amp;#34;&amp;#34;Set the value and expiration of a key. :raises TypeError: if seconds is neither int &amp;#34;&amp;#34;&amp;#34;if not isinstance(seconds, int): raise TypeError(&amp;#34;milliseconds argument must be int&amp;#34;) fut = self._conn.execute(b&amp;#39;SETEX&amp;#39;, key, seconds, value) return wait_ok(fut) 剩下的就是一个个方法逐个完善。
什么是连接池 我们会看到，无论那个数据库客户端，总是会有连接池机制。那么连接池是什么呢？我们为什么需要连接池呢？
首先，我们都知道，对连接而言，创建是必要重型的操作。比如说，TCP 连接，接下来之后是登录认证等等过程，最后才会执行命令。这也就是我们通常计算库性能时，很多时候会把建立连接的时候去掉。但是这就出现了一个问题，当一个连接被占用时，其他的操作仍旧是不能够完成操作了，只能等待前一个操作完成。但是假如我们一次性创建一堆连接呢？从一堆连接中找到空闲的连接，使用完成后释放成空闲的状态，这就是线程池的本质。因为减少了每次创建连接的过程，所以对性能提升也非常有帮助。
从单连接到连接池 首先，还是创建一个 RedisPool 类，用于管理 Redis 的连接池。</description></item><item><title>零基础编写 Python Redis Client（一）</title><link>https://www.4async.com/2015/10/2015-10-10-write-aio-python-redis-client-as-dummy-1/</link><pubDate>Sat, 10 Oct 2015 18:11:15 +0000</pubDate><guid>https://www.4async.com/2015/10/2015-10-10-write-aio-python-redis-client-as-dummy-1/</guid><description>什么是 AIO AIO 是 Asynchronous Input/Output 的简写，也就是异步 IO。不过在谈什么是 AIO 之前，我们可能要先介绍一下 BIO。那么什么是 BIO 呢？简单的说，BIO 是 Blocking Input/Output，也就是阻塞 IO，他实现的通常是在线程池中找出一个线程处理 IO，在 IO 过程中，其他线程都需要等待 IO 完成后才可以从中选取一个线程占用 IO。这样最大的问题是，当线程数量较多，并且需要大量的 IO 操作时，就会造成一个大量的阻塞，因为实际上每次只有一个线程在处理 IO。
那么如何解决这个时候的问题呢？这时候就提出了 AIO 的概念。通常在 IO 处理过程中也会伴有一些其他的处理操作，假如把所有的操作都浪费在了等待 IO 释放上，线程池中的线程利用率也太低了，因此我们需要一种方式，在申请 IO 处理之后，就去继续做其他的事情，等 IO 操作完成了，然后通知我们已经 OK，我们可以继续处理了。这也就是我们常说的 AIO 的原型。
AIO 的情况也说明了它适用的场景：长连接场景，或者重度的 IO 操作等等的情况。
如果找软件来做案例，我们可以找一个可能大家熟知的：NGINX。正如我们所知，NGINX 采用了 异步、事件驱动的方法来处理连接。这种处理方式无需（像使用传统架构的服务器一样）为每个请求创建额外的专用进程或者线程，而是在一个工作进程中处理多个连接和请求。为此，NGINX 工作在非阻塞的 socket 模式下，并使用了 epoll 和 kqueue 这样有效的方法。
这部分的内容，在 NGINX 引入线程池 性能提升 9 倍 中进行了详细的介绍，包含了 NGINX 的异步应用经验，同时介绍了 NGINX 中引入了阻塞的线程池用于解决某些特定场景问题下的效率。
如何实现 Python 的异步 IO 这篇文章会以最新的 Python 3.</description></item></channel></rss>