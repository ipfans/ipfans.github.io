<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>fuzzer on ipfans's Blog</title><link>https://www.4async.com/tags/fuzzer/</link><description>Recent content in fuzzer on ipfans's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 07 Jan 2014 15:00:00 +0000</lastBuildDate><atom:link href="https://www.4async.com/tags/fuzzer/atom.xml" rel="self" type="application/rss+xml"/><item><title>浏览器 fuzz 工具 cross_fuzz</title><link>https://www.4async.com/2014/01/2014-01-07-web-browser-cross-fuzz/</link><pubDate>Tue, 07 Jan 2014 15:00:00 +0000</pubDate><guid>https://www.4async.com/2014/01/2014-01-07-web-browser-cross-fuzz/</guid><description>现在来写 cross_fuzz 似乎是有点晚了，毕竟基本上很多时候 cross_fuzz 已经广泛应用于 DOM fuzz 中了。比如 Chromium 中就内置了 cross_fuzz 工具。不过说回来，毕竟就是 Google 自己人做的不是。
最新的代码 (2011 年更新) 可以在：http://lcamtuf.coredump.cx/cross_fuzz/ 找到。
基本设计逻辑 cross_fuzz 就是一个 HTML 文件，因此看起来其实并不麻烦：简单的说，就是不停的打开两个窗口显示不同的 HTML/XHTML/SVG/swf 等等内容（当然，可以自己添加），通过不同的 DOM 操作（访问对象、回收操作）等等尝试出发 UAF 之类的问题。
1. Open two windows with documents of any (DOM-enabled) type. Simple HTML, XHTML, and SVG documents are randomly selected as targets by default – although any other, possibly plugin-supported formats could be targeted instead. 2. Crawl DOM hierarchy of the first document, collecting encountered object references for later reuse.</description></item></channel></rss>