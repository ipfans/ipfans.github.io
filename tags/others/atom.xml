<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Others on ipfans's Blog</title><link>https://www.4async.com/tags/others/</link><description>Recent content in Others on ipfans's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 11 Mar 2021 18:38:00 +0000</lastBuildDate><atom:link href="https://www.4async.com/tags/others/atom.xml" rel="self" type="application/rss+xml"/><item><title>在非容器(集群)环境下运行dapr</title><link>https://www.4async.com/2021/03/2021-03-11-running-dapr-without-container/</link><pubDate>Thu, 11 Mar 2021 18:38:00 +0000</pubDate><guid>https://www.4async.com/2021/03/2021-03-11-running-dapr-without-container/</guid><description>前一段时间一直关注的dapr正式发布了v1.0版本(实际上本文发布时还更新了v1.0.1)，代表dapr在某些程度上进入稳定状态，可以尝试在实际中进行运用。作为我一直关注的项目，在第一时间中进行了尝试，并试图引入实际项目中，本文则是针对这些的一些先期测试内容.
什么是dapr？ Dapr最早是由微软开源的(不愧是你)，一个可移植的、事件驱动的程序运行时，它使任何开发者都能轻松地构建运行在云和边缘的弹性、无状态/有状态的应用程序，并且可以灵活支持多种开发语言。换而言之，在我看来，dapr可以作为一个Serverless落地方案看待和处理，对程序而言，只关注提供的store和消息队列接口，无需关心架构层面更多内容。
不过在官方的示例教程中，使用的环境为容器环境部署和管理dapr。实际上，除了在容器环境或者容器集群环境下，Dapr可以配置为在本地机器上以自托管模式运行。
本地安装 dapr安装可以通过官方的dapr-cli实现，dapr-cli可以通过一键安装命令快速安装：
# wget -q https://raw.githubusercontent.com/dapr/cli/master/install/install.sh -O - | /bin/bash Your system is linux_amd64 Dapr CLI is detected: main: line 86: 43656 Segmentation fault $DAPR_CLI_FILE --version Reinstalling Dapr CLI - /usr/local/bin/dapr... Getting the latest Dapr CLI... Installing v1.0.0 Dapr CLI... Downloading https://github.com/dapr/cli/releases/download/v1.0.0/dapr_linux_amd64.tar.gz ... dapr installed into /usr/local/bin successfully. CLI version: 1.0.0 Runtime version: n/a To get started with Dapr, please visit https://docs.dapr.io/getting-started/ 可以通过输入dapr命令确认dapr-cli程序是否被正常安装成功。
接下来使用dapr-cli安装所有的runtime等应用。
# dapr init --slim ⌛ Making the jump to hyperspace.</description></item><item><title>NATS-Server(JetStream)和NATS Streaming Server对比</title><link>https://www.4async.com/2021/03/2021-03-02-nats-server-usage/</link><pubDate>Tue, 02 Mar 2021 18:38:00 +0000</pubDate><guid>https://www.4async.com/2021/03/2021-03-02-nats-server-usage/</guid><description>在我吐槽了无数次之后，NATS JetStream终于结束了beta阶段正式进入RC阶段。终于官方也在最近刚刚正式回复了我正式版本在处理几个问题之后就会正式发布。那么在这个比较重要的NATS-Server特性发布之际聊一下NATS产品本身区别和新特性的使用，还有更多的潜在的区别。
概念区分：NATS-Server / NATS Streaming Server / NATS JetStream NATS-Server NATS-Server（或者叫nats）是一个开源的、云原生的、高性能的消息传递系统，是NATS的最基础的产品。它的核心是一个发布/订阅（Pub/Sub）系统，客户端可以在不同集群中的服务间nats进行通讯，而不需要关注具体的消息在哪个服务上。换而言之，客户端可以在任意一个集群的服务端上发布消息，同时在任意集群客户端上尝试读取消息。在官方与其他同类消息队列产品功能对比中，我们也可以管窥一下产品的功能列表。nats支持多流多服务进行pub/sub，负载均衡，保障消息最多/最少一次送达，多租户和用户认证等功能。虽然看上去优点很多，但是nats不是一个应用很广的消息队列的重要原因是，它缺少了一些对消息队列而言很最重要的产品特性，比如持久化支持，比如消息确保一次送达。这意味着当你的消息发送出去之后，你的消息是在处理过程中可能丢失的，甚至是可能送达不到的。
NATS Streaming Server NATS Streaming Server（或者叫stan）是用于尝试解决上面提到的nats的已存在问题的。stan添加了持久化功能和消息送达策略支持。stan中自带了nats服务端，但是在使用过程中，nats和stan不能进行混用。在官方文档中，是这么描述stan和nats之间的关系的：
NATS客户端和NATS Streaming Server客户端之间不能相互交换数据。也就是说，如果一个NATS Streaming Server客户端在foo上发布消息，在同一主题上订阅的NATS客户端将不会收到消息。NATS Streaming Server消息是由protobuf组成的NATS消息。NATS Streaming Server要向生产者发送ACK，并接收消费者的ACK。如果与NATS客户端自由交换消息，就会引起问题。
stan的具体架构如下图：
但是stan虽然提供了持久化和消息传递策略支持，但是在架构设计上却出现了问题，导致在最开始设计时遗留了很多问题，比如当你确定stan集群是固定的不能无限制水平扩容(#999)，比如不支持多租户功能(#1122)，比如客户端无法主动拉取消息只能被推送等等
NATS JetStream NATS JetStream（或者叫JetStream）是NATS基于Raft算法实现的最新的架构设计尝试解决上述问题的新方案。在区别于原有的stan功能上，提供了新的持久化功能和消息送达策略，同时支持水平扩容。同时，新的JetStream也为大消息做了一些优化，不再将这特性功能作为nats的客户端存在而是嵌入NATS Server中作为其中的一个功能存在。也就是说，如果在对这几项技术进行选择时，JetStream应该是最应该被选择的方案。更多详细情况具体可以查看官方的指导文档。
NATS JetStream使用 理论介绍过了，接下来说说实际使用的事情。现在JetStream还是RC阶段，
编译和启动客户端 下载nats-server源码，解压之后执行：
cd nats-server-master go build -o nats-server -ldflags=&amp;quot;-s -w -buildid=&amp;quot; . ./nats-server -js 这样就可以启动一个支持JetStream功能的服务端了。
[54738] 2021/03/02 18:27:02.605197 [INF] Starting nats-server [54738] 2021/03/02 18:27:02.605236 [INF] Version: 2.2.0-RC.2 [54738] 2021/03/02 18:27:02.605238 [INF] Git: [not set] [54738] 2021/03/02 18:27:02.</description></item><item><title>切换至Hugo引擎驱动</title><link>https://www.4async.com/2021/02/2021-02-19-move-to-hugo/</link><pubDate>Fri, 19 Feb 2021 16:27:00 +0000</pubDate><guid>https://www.4async.com/2021/02/2021-02-19-move-to-hugo/</guid><description>其实很早之前就希望切换至Hugo引擎驱动博客了，但是体验下来一圈，最大的感觉是Hugo的主题都很一言难尽&amp;hellip;所以拖着一直没有切换。结果今天想发布新文章时突然发现我无法正常编译Hexo的项目了，于是干脆趁此良机切换至Hugo引擎了。
本站目前使用的主题是stack主题，相当简洁，推荐想切换至Hugo的小伙伴了解一下。
另外提供一下快速进行Github Action部署的方案（私有化仓库代码/公有化仓库网站展示），PERSONAL_TOKEN是个人token，需要从个人设置页面里获取填写至仓库Secrets中：
name: github pages on: push: branches: - master jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: &amp;#39;latest&amp;#39; - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} external_repository: 你的用户名/你的仓库 publish_dir: ./public cname: 你的域名</description></item><item><title>漫谈代码安全：也来聊一聊AntD这档子事</title><link>https://www.4async.com/2018/12/2018-12-25-scm-security/</link><pubDate>Tue, 25 Dec 2018 23:20:00 +0000</pubDate><guid>https://www.4async.com/2018/12/2018-12-25-scm-security/</guid><description>没想到今年突然有动力还能写一篇。可能来自于两个方面，有些东西需要整理，另外有一个事情我是感觉到很诧异的。今天技术圈最火的事情当属AntDesign彩蛋事件了（以下简称AntD），很不幸的是，本司也是本次受害者之一。
考虑到AntD是一个使用十分广泛并且关注度非常高的国内项目，并且有阿里支付宝的背书效应，这一次我想影响的会在两个方面：一个是阿里开源本身的信用，一个是开源项目在国内的推广。当然，我们确实在引入AntD方面确实太过草率：我其实关注AntD了大概一年时间，考虑到issue情况和项目开发活跃度情况，要求团队引入此框架希望可以提升开发效率，没想到相关的项目1-2个月就出现了这种事情，真是令人实在痛心。
这件事情也暴露出来，我们以前在使用开源项目时，太过信任
另外，作为最后的一个建议，我们希望如果大家以后开源项目，如果做不到，请不要说自己是__企业级项目__，因为一般也就是放在自己企业里面用，这跟企业级项目是两个概念。至少我们具体到AntD这个项目上，这个项目无论代码开发和管控上，都是算不上的。</description></item><item><title>Consul平滑升级的一点建议</title><link>https://www.4async.com/2018/05/2018-05-10-consul-graceful-stop/</link><pubDate>Thu, 10 May 2018 15:20:00 +0000</pubDate><guid>https://www.4async.com/2018/05/2018-05-10-consul-graceful-stop/</guid><description>我们从 Consul 0.6.x 版本开始使用，中间也遇到的一些各种各样的问题，比较常见的操作问题就是 consul 的升级问题（比如解决 BUG，早期 Consul 的 BUG 也遇到了好几个）。
平滑升级时，我们常见的方式一般为替换 consul 可执行文件，然后执行 Graceful 重启
常见 Consul 的 Graceful leave 的方法有以下两种：
发送 SIGINT 信号至 Consul； 连接要升级的 consul，使用命令 consul leave 发送离开命令； 这两种方式都会让该节点主动退出集群并结束进程，如下：
[INFO] agent: Caught signal: terminated [INFO] agent: Graceful shutdown disabled. Exiting [INFO] agent: Requesting shutdown [INFO] consul: shutting down server [WARN] serf: Shutdown without a Leave [ERR] agent: Coordinate update error: No cluster leader [ERR] agent: failed to sync remote state: No cluster leader [WARN] serf: Shutdown without a Leave [INFO] manager: shutting down [INFO] agent: consul server down [INFO] agent: shutdown complete [INFO] agent: Stopping DNS server 10.</description></item><item><title>配置新域名</title><link>https://www.4async.com/2018/05/2018-05-03-new-domain/</link><pubDate>Thu, 03 May 2018 11:20:00 +0000</pubDate><guid>https://www.4async.com/2018/05/2018-05-03-new-domain/</guid><description>感谢Github Page终于支持了Let&amp;rsquo;s Encrypt的HTTPS，很久之前购买的域名终于可以再次发光发热了。
新的域名： https://www.4async.com
值得注意的是，在新的域名生效之后，HTTPS需要等待1-2个小时才能启用。</description></item><item><title>聊聊初创公司的后端语言选型 (小众语言)</title><link>https://www.4async.com/2016/01/2016-01-27-startup-architecture-language/</link><pubDate>Wed, 27 Jan 2016 09:48:00 +0000</pubDate><guid>https://www.4async.com/2016/01/2016-01-27-startup-architecture-language/</guid><description>在创业公司初创伊始，如何选择合适的语言决定了产品后续的技术栈和如何进行合理的业务支撑方向。如果你在读这篇文章之前，更倾向于选择 Java/C#/PHP 常见语言技术栈，我觉得对于你而言，这篇文章帮助不大。因为对你而言，这些技术栈意味着更加方便招人，更方便的故障处理资料等等。但是如果一个初创公司想要选择合理的小众语言技术栈，我想这篇文章对你也许有一些帮助。
在文章开始之前，我觉得有必要描述一下所谓的小众语言，这里我在最初进行技术选型时，考察了包括：
Python: 你可能在接触爬虫、大数据分析等等方面听过 Python 的大名，大家都知道 Pythonista 都习惯说的一句话就是：人生苦短，我用 Python。 Ruby: 你如果做过 Web 框架，你遇到最多的是很多人都会提到 RoR 框架。用过之后只有一个惊叹了。 JavaScript（Nodejs）: 有没有听过 JavaScript 全栈工程师？有没有听过 JavaScript 全栈工程师？有没有听过 JavaScript 全栈工程师？ Golang: 简单粗暴的语言，也许你见过很多人跟你吹嘘，Golang 是下一代的云计算开发语言。 其他语言太过于小众，考虑语言的应用很多需要得到更多的社区支持，目前不在考虑的范畴内。
小众语言的劣势 正所谓知己知彼百战不殆，在了解一个技术选型之前，最好是研究这些语言的缺点。因为你最后感觉这个技术选型不适合你的时候，根本的原因是这些劣势影响了你。
在上面提到的几个语言中，Python、Ruby、JavaScript 是属于动态语言。关于动态语言的争议最大的地方是：动态语言到底是否合适进行大型项目。事实上，在某些阶段，多人合作，并且大家水平语言不同时，这个时候通常会有这样的问题：团队需要花更多的时间在确保动态语言的准确性上。对于一个项目有高可用、低错误率的要求时，由于语言的动态特性，就需要对程序开发时的单元测试和后期集成测试的要求更高。因为变量在运行时才会赋予类型含义，所以很难在静态检测过程中发现足够多的问题。这样对测试人员的压力也会更大，当你没有合适的测试人员时，这个时候通常会变成，你只覆盖测试了理想情况下的成功失败情况，而对特别异常情况缺少评估。
Python、Ruby 语法对程序员而言最大的成本在于需要重新学习一门新的语言。这个学习成本、时间成本通常对初创公司而言通常是支付不起的，哪怕像这些比较容易学习的动态语言而言。另外一个值得一提的是，无论是 Python 还是 Ruby，从长远看，如果你后续有较大的用户增长又需要保证用户体验时，Python、Ruby 的执行效率和吞吐量会有较大的影响。
Python 和程序员入门的语言差距较大：用 4 个空格表述程序缩进。这意味着，程序员直接从网上寻找解决方案（拷贝代码）时成本更高，因为很有可能他需要手工进行代码格式化，这样有可能造成程序逻辑的改变。另外一个不得不提的是一些 Python 库看似好用，实际上或多或少有有一些坑，这对新手而言，往往是致命的。对应的，Ruby 语言本身时不存在这些问题的。然而 Ruby 作为开发主语言时最大的问题是，如果选择 RoR 框架作为初始的 Web 框架时，如果没有一个熟悉 RoR 框架的人，那么学习修改 RoR 框架的成本是特别高的：对于一个通用型框架而言，你可能需要更多的特殊场景定制，这可能需要做大量的猴子补丁，如果不对框架有一个清晰了解时，这样的成本会更高。
JavaScript（后面统一用 Nodejs 代称）则借助 Nodejs 实现了高性能和较大吞吐量。而且从语言层面上，JavaScript 对很多程序员并不陌生。然而，在过去的很长时间，真正熟练掌握 JavaScript 的都是前端工程师，这是一个非常尴尬的问题。对后端工程师而言，Nodejs 需要与前端不同的技术栈，而且大概没有公司希望一个完全没有任何后端经验的前端工程师去接手后端项目的开发的。Nodejs 是一个年轻的语言，年轻必然会伴随一些问题，比如，库比较少（当然现在也是井喷期）。一些必要的库需要慢慢寻找。事实上，我也不得不吐槽，可能是开发者水平问题，导致很多 npm 提供的包，往往或多或少存在一些比较恼人的 BUG，这些 BUG 可能会在你开发过程中，正常运行中出现，而你却不得不干掉它。对于这种 BUG，很多时候更快的处理方式是你自己动手进行快速修复。然而当你的程序员不具备这种能力的时候，就需要提一个 issue 到开发者，由开发者进行修复，并且需要等待版本更新到 npm 源中。很多时候这个过程都是比较尴尬的，尤其是你选择了一个开发者并不是特别活跃的包。</description></item><item><title>使用 Vagrant 统一开发环境实践</title><link>https://www.4async.com/2015/12/2015-12-28-using-vagrant-development-env/</link><pubDate>Mon, 28 Dec 2015 15:43:12 +0000</pubDate><guid>https://www.4async.com/2015/12/2015-12-28-using-vagrant-development-env/</guid><description>在服务器端开发过程中，比较痛苦的是在多个人员进行开发时，容易因为环境不统一等等的情况，容易出现传说中的 “我这儿能跑，换个环境就出问题” 的情况。我们在项目开发过程中大量的使用了 Python 语言构建 Web 类型服务。Python 对于某些需要编译的扩展模块，可能在不同的场景下带来不同的影响（如编译不过等等、二进制版本不同等等问题）。
在处理这种多人协作的环境统一问题时，我们选择 Vagrant＋VirtualBox＋CentOS 虚拟环境方案统一开发环境，避免出现切换开发者，切换开发环境带来的不统一的麻烦。
初始化项目 vagrant 可以在 https://www.vagrantup.com/ 下载安装，对应的系统镜像可以在 http://www.vagrantbox.es/ 找到下载安装。根据国内实际的下载情况，我们建议先行下载镜像方式初始化项目。在选择镜像时，建议选择与线上服务器版本相同的镜像。下面我们仅演示本地加载镜像方式。
下载 vagrant 和镜像后，安装 vagrant 软件。这样就可以在命令行中执行相关指令。还有，记得安装 VirtualBox。
vagrant box add centos /path/to/centos-6.6-x86_64.box 比如我们线上服务器使用了 centos 环境，我们在开发时，也是选择相同版本的 CentOS box。
接下来进入对应的项目目录，使用如下命令创建 Vagrantfile（centos 是刚刚添加的 box）。当然，如果项目已经存在 Vagrantfile，则可以进行省略。
vagrant init centos 项目文件夹下会生成 Vagrantfile 文件。
Vagrantfile 编辑 Vagrant 在执行环境初始化时会根据 Vagrantfile 文件的描述进行。比较常见的编辑内容一般包含以下几种。
如果想要使用 IP 访问该虚拟服务器，可以通过删除 config.vm.network :private_network, ip: &amp;quot;192.168.33.10&amp;quot; 前的 “#”，将该设置生效。注意需要确认 ip 不要被占用。
如果需要同步文件夹到虚拟机中（比如项目文件夹），可以注释掉 config.vm.synced_folder &amp;quot;../data&amp;quot;, &amp;quot;/vagrant_data&amp;quot; 前的 “#”，将设置生效。该命令可以切换更复杂的设置：config.vm.synced_folder &amp;quot;./&amp;quot;, &amp;quot;/var/www&amp;quot;, create: true, group: &amp;quot;nginx&amp;quot;, owner: &amp;quot;nginx&amp;quot; 命令表示将本地的当前目录映射到 /var/www 目录，若不存在时创建，同意 user 和 group 设置为 nginx。</description></item><item><title>折腾日记 ---cubieboard(Mac OS X 篇)</title><link>https://www.4async.com/2014/09/2014-09-10-trying-cubieboard-on-mac-os-x/</link><pubDate>Wed, 10 Sep 2014 14:49:15 +0000</pubDate><guid>https://www.4async.com/2014/09/2014-09-10-trying-cubieboard-on-mac-os-x/</guid><description>这个是在 OS X 上折腾 cubieboard 的笔记。首先，无论是树莓派还是 cubieboard 之类的开发板，都是需要装一个 usb2tty 的驱动，通过 console 连接到开发板上。
步骤参考：http://pbxbook.com/other/mac-tty.html，简单复述一下：
首先，需要安装 tty2usb 的驱动，点击下面两个连接下载后，安装 pkg 文件。 PL2303_MacOSX_v1_5_1.zip FTDI Driver 重启之后，将 usb 连接至 Mac，通过执行 ls /dev/cu.* 查看已经连接的设备，默认一般名称是 / dev/cu.usbserial 执行 screen /dev/cu.usbserial 波特率 登录 console，波特率需要查一下官方手册看下具体多少，一般是 9600 或者 115400 的多一些。 如果 screen 进去发现没反应，按按回车看看。 如果想结束此次会话，按 ctrl-a 然后 ctril-\ 结束会话。 cubieboard 拿到是 Android 系统，建议直接换成官方支持的 Lubuntu 系统吧，毕竟方便一些。
更换步骤这里不多说了，主要是下载镜像，官方提供工具，直接刷进去就好了。</description></item><item><title>今天学到的几件事</title><link>https://www.4async.com/2014/01/2014-01-12-something-details/</link><pubDate>Sun, 12 Jan 2014 00:20:00 +0000</pubDate><guid>https://www.4async.com/2014/01/2014-01-12-something-details/</guid><description>权限的那点事儿 检查程序问题，除了配置文件有没有错以外，还需要检查一下权限什么的原因。除了用户组以外，还需要关注文件描述的配置。两个命令分别是
chown chmod 多留点心眼总没坏处
ldconfig 的问题 经常会编译一些常用的库文件供其他的文件使用。比如 luajit，今天安装完成之后，编译了一个依赖的程序，但是执行程序却发现提示对应的 so 文件无法找到。
后来我灵机一动，虽然 so 文件在 ldcache 中了，但是重新使用 ldconfig 命令就重新 recache 一下就行了。
看来不见得所有的都那么靠谱就是了。之前编译 zmap 也遇到了这个问题，一直很奇怪 json 库的 so 文件在 ldconf 文件中，为什么执行 zmap 却提示无法找到，看来也是相同的原因了。</description></item><item><title>测试页面</title><link>https://www.4async.com/2013/12/2013-12-27-first-post/</link><pubDate>Fri, 27 Dec 2013 15:28:30 +0000</pubDate><guid>https://www.4async.com/2013/12/2013-12-27-first-post/</guid><description>第一次试用 Github Pages 来做页面，感觉挺不错的，先试试咯。
def print_hi(name) print &amp;#34;hi&amp;#34; print_hi()</description></item></channel></rss>