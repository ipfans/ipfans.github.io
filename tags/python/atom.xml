<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on ipfans's Blog</title><link>https://www.4async.com/tags/python/</link><description>Recent content in Python on ipfans's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 29 Jan 2019 14:30:00 +0000</lastBuildDate><atom:link href="https://www.4async.com/tags/python/atom.xml" rel="self" type="application/rss+xml"/><item><title>利用Stub File标注Python文件</title><link>https://www.4async.com/2019/01/2019-01-28-python-typing-with-stub-files/</link><pubDate>Tue, 29 Jan 2019 14:30:00 +0000</pubDate><guid>https://www.4async.com/2019/01/2019-01-28-python-typing-with-stub-files/</guid><description>&lt;p>在升级到&lt;code>Python 3.5+&lt;/code>版本之后，最大的项目管理优化来自于&lt;a class="link" href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="noopener"
>&lt;code>PEP-484 Type Hint&lt;/code>&lt;/a>的引入。借助&lt;code>Type Hint&lt;/code>，我们可以进一步提升&lt;code>Python&lt;/code>代码的类型标注，保障在重构过程中避免出现一些低级失误。&lt;/p>
&lt;p>我们可以通过高版本&lt;code>Python&lt;/code>新加的新语法启用这项特性，然后通过&lt;code>mypy&lt;/code>等工具检查：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">greeting&lt;/span>(name: str) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> str:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Hello &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> name
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然而，在实际实践过程中，也往往存在一些问题，这些问题来自于很多方面：&lt;/p></description></item><item><title>OSX 下安装 face_recognition</title><link>https://www.4async.com/2017/08/2017-08-02-install-face-recognition-on-osx/</link><pubDate>Wed, 02 Aug 2017 18:30:00 +0000</pubDate><guid>https://www.4async.com/2017/08/2017-08-02-install-face-recognition-on-osx/</guid><description>face_recognition 是一个热门的人脸识别库，常年占据 Github Trending Python 子类的 Top10。
在官方文档中，介绍安装 face_recognition 步骤非常简单，只需要执行 pip install face_recognition 就可以了，实际在安装过程中 face_recognition 有一些非 Python 依赖，需要单独安装，本文就对内容进行一个简单介绍，权作记录，方便大家手动安装时提前规避。文章基于 OSX 10.12.6+pyenv+python3.6.2 介绍。
问题在哪里？ face_recognition 的依赖大部分都比较好安装，只有一个库例外，那就是 dlib 这个依赖。这个依赖需要安装 boost 和 boost-python 两个非 Python 依赖。
安装 Boost 和 boost-python 这两个库可以通过 Homebrew 快速安装，使用如下命令进行安装：
brew install boost brew install boost-python --with-python3 需要注意的是，如果是 Python3 使用，需要额外参数，使用源码编译安装。如果使用 Python2 可以使用 Homebrew 的预编译包。
确认 Python dlib 要求 Python 编译时使用 --enable-shared 参数编译，默认情况下，pyenv 未启用该参数，因此编译需要使用下面参数进行 Python 重新编译
PYTHON_CONFIGURE_OPTS=&amp;quot;--with-dtrace --enable-shared&amp;quot; pyenv install 3.6.2 前面一个参数是我一直编译 Python 3.</description></item><item><title>使用 Python 和 Pandas 分析 Pronto CycleShare 数据</title><link>https://www.4async.com/2017/02/2017-02-19-analyzing-pronto-cycleshare-data-with-python-and-pandas/</link><pubDate>Sun, 19 Feb 2017 18:00:00 +0000</pubDate><guid>https://www.4async.com/2017/02/2017-02-19-analyzing-pronto-cycleshare-data-with-python-and-pandas/</guid><description>这是一篇非常不错的 pandas 分析入门文章，在此简单翻译摘录如下。
本周，西雅图的自行车共享系统 Pronto CycleShare 一周岁了。 为了庆祝这一点，Pronto 提供了从第一年的数据缓存，并宣布了 Pronto Cycle Share 的数据分析挑战。
你可以用很多工具分析这些数据，但我的选择工具是 Python。 在这篇文章中，我想展示如何开始分析这些数据，并使用 PyData 技术栈，即 NumPy，Pandas，Matplotlib 和 Seaborn 与其他可用的数据源。
这篇文章以 Jupyter Notebook 形式组织，它是一种开放的文档格式。结合了文本、代码、数据和图形，并且通过 Web 浏览器查看。本文中的内容可以下载 对应的 Notebook 文件，并通过 Jupyter 打开。
下载 Pronto 的数据 我们可以从 Pronto 官网 下载对应的 数据文件。总下载大约 70MB，解压缩的文件大约 900MB。
接下来我们需要导入一些 Python 包：
In [2]:
%matplotlib inline import matplotlib.pyplot as plt import pandas as pd import numpy as np import seaborn as sns; sns.set() 现在我们使用 Pandas 加载所有的行程记录：</description></item><item><title>使用 dtrace 跟踪 Python 应用</title><link>https://www.4async.com/2016/09/2016-09-15-tracing-python-program-with-dtrace/</link><pubDate>Thu, 15 Sep 2016 18:00:00 +0000</pubDate><guid>https://www.4async.com/2016/09/2016-09-15-tracing-python-program-with-dtrace/</guid><description>今年在 Pycon China 上，来自饿了么的郭浩川分享了 利用 systemtap 进行 Python 执行情况分析 的内容。分享利用 systemtap 在线上环境中实时监控 gevent patch 的 green thread 程序的执行状况。
dtrace 和 systemtap 均支持在 Linux 上进行分析，在 macOS 系统上则只有 dtrace 使用。在 Python3.5 和之前版本中，需要使用手工 Patch 的方式进行埋点监控。在 Python 3.6 以上中 dtrace 和 systemtap 埋点支持功能可以通过编译参数 &amp;ndash;with-dtrace 开启。
从 dtrace 开始 dtrace 是一个低开销的成本动态跟踪工具，可以通过埋点 probs 方式监控各项程序运行状态。dtrace 最初内置在 Solaris 系统中，因此我们可以借助 Solaris 系统的相关文档了解 dtrace 的基本操作。DTrace 用户指南 是 Oracle 提供的基于 Solaris 系统的 dtrace 操作手册，操作基本与其它系统相同，推荐在最初开始阶段阅读该使用手册。
在 macOS 上，已经很多系统底层功能和 framework 中已经集成了 dtrace 的功能。</description></item><item><title>利用 Type Hint 提升 Python 程序开发效率</title><link>https://www.4async.com/2016/07/2016-07-13-type-hint-improve-python-programming/</link><pubDate>Wed, 13 Jul 2016 20:00:00 +0000</pubDate><guid>https://www.4async.com/2016/07/2016-07-13-type-hint-improve-python-programming/</guid><description>Type Hint（或者叫做 PEP-484）提供了一种针对 Python 程序的类型标注标准。
为什么使用 Type Hint？对于动态语言而言，常常出现的情况是当你写了一段代码后，隔段时间你可能忘记这个方法的原型是什么样子的了，你也不清楚具体应该传入什么类型的参数，这样往往需要你去阅读代码才能定义每个类型具体是什么。或者当你使用一个文档并不是特别完全的第三方库，你不知道这个库应该如何使用，这都会很痛苦。
现在，借助 Type Hint，你可以实现：
实现类型检查，防止运行时出现的类型不符合情况。 作为文档附加属性，方便开发者调用时传入传出的参数类型。 提升 IDE 的检查机制，在智能提示时更快给出提示和类型检查结果。 实现这个过程中，你需要使用 Python 3.5+ 中提供的新模块 typing。值得注意的是，这个改动并不会影响程序运行，仅仅是为了方便类型检查器实现的。
Type Hint 类型检查器 目前，比如 JetBrains 家的 PyCharm 已经支持 Type Hint 语法检查功能，如果你使用了这个 IDE，可以通过 IDE 功能进行实现。如果你像我一样，使用了 SublimeText 编辑器，那么第三方工具 mypy 可以帮助到你。AnacondaST3 最近要发布的 2.0 版本也内置了 mypy 功能的支持，具体的进度可以看一下 这个 issue。一些其它的 Python 工具 (比如 代码提示工具 jedi 0.10+) 也支持了 Type Hint 功能。
从简单的例子开始 从简单的例子开始，我们先从一个简单的程序开始，运行环境为 Python 3.5.2，使用 mypy 工具进行检查。
首先通过 pip install mypy-lang 命令安装 mypy 工具。注意是 mypy-lang，之所以是这样，是因为在 pypi 里 mypy 这个名字已经被占用掉了。</description></item><item><title>从 asyncio 简单实现看异步是如何工作的</title><link>https://www.4async.com/2016/02/2016-02-03-simple-implement-asyncio-to-understand-how-async-works/</link><pubDate>Wed, 03 Feb 2016 15:40:00 +0000</pubDate><guid>https://www.4async.com/2016/02/2016-02-03-simple-implement-asyncio-to-understand-how-async-works/</guid><description>从 asyncio 简单实现看异步是如何工作的
by ipfans
注：请使用 Python 3.5+ 版本运行以下代码。
先从例子看起 首先我们来看一个 socket 通讯的例子，这个例子我们可以在官方 socket 模块的文档中找到部分原型代码：
# echo.py from socket import * # 是的，这是一个不好的写法 def echo_server(address): sock = socket(AF_INET, SOCK_STREAM) sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) sock.bind(address) sock.listen(5) while True: client, addr = sock.accept() print(&amp;#34;connect from&amp;#34;, addr) echo_handler(client) def echo_handler(client): while True: data = client.recv(10000) if not data: break client.send(str.encode(&amp;#34;Got: &amp;#34;) + data) print(&amp;#34;connection closed.&amp;#34;) if __name__ == &amp;#39;__main__&amp;#39;: echo_server((&amp;#39;&amp;#39;, 25000)) 但是同步模式会有一个问题，当进行通讯是阻塞的，当一个连接占用时就会阻碍其他连接的继续，这个时候应该怎么更快的运行呢？
回顾历史 在 asyncio 出现之前，我们都是怎么提高效率的呢？首先想到的方法就是多线程处理：</description></item><item><title>我们是如何落实 Code Style Guide 的（Python 篇）</title><link>https://www.4async.com/2016/01/2016-01-15-how-we-follow-python-style-guide/</link><pubDate>Fri, 15 Jan 2016 17:30:00 +0000</pubDate><guid>https://www.4async.com/2016/01/2016-01-15-how-we-follow-python-style-guide/</guid><description>我们是如何落实 Code Style Guide 的（Python 篇）
最近年终，总是想谈谈过去一年的感悟和积累。接下来大概有几篇关于项目管理等等一些小方面的介绍，这篇文章主要介绍一下我们如何将 Python 编码规范真正落实到程序的实际开发过程中的。
编码规范选择 Python 作为灵活的脚本语言，在格式方面并不存在太多的限制（相对编译语言）。这样会导致一个比较蛋疼的问题：在项目开发过程中，由于个人的习惯和编码风格，导致程序缺少一个统一的标准，每个人的代码表现形式也不同。因此，在实际项目由于新人加入、老人退出过程中会产生比较高的模块维护成本。因此，在实际的项目开发中，选择一个编码标准也是比较重要的。
面对编码风格选择，比较常见的包括 PEP-8 和 Google Python Style Guide。在最后，我选择了 PEP-8 作为项目中的实际应用标准，要求程序需要在满足编码要求规范的前提下进行编码。
除了对代码编码更个的要求以外，我们还对 import 等具体的细节进行了标准化。
尽量规范注释 在降低模块维护成本过程中，另外一个比较好的方式是尽量提供良好的代码注释。尽管这个算是一个和语言无关的老生常谈的问题，我只是想在这里提一下另外一个 PEP：PEP-0257，这里介绍了一种约定的 docstring 编写方法，对于编辑器而言，可以通过插件快速实现注释。
不过我考虑到对个人习惯的影响较大，这个 PEP 实际项目开发中并未作为实际开发规范，只是鼓励大家在项目中进行执行。
从规范到执行 从代码开发最初的规范约定是一回事，当回到开发过程中，开发者难免会因为个人的习惯或者疏忽等各种原因导致程序开发过程中程序编码风格不统一问题。因此在实际开发过程中，我们又需要通过工具保证程序在实际过程中能够帮助规范化或者检查格式错误。
借助社区的力量，我们最终选择了工具 flake8、yapf 和 isort。其中，flake8 用于检查我们的代码是否正确的执行了标准；yapf 工具用于快速进行 PEP-8 标准化，减少了人工修改的成本；isort 工具则是执行我们之前提到的 import 标准化工作。
yapf 是 Google 员工开发的一个 Python 格式化工具，它支持 PEP8 与 Google 编码标准，一些具体的使用方式可以查看项目的主页。在实际的项目落地过程中，你应该会遇到的一个问题是关于 flake8 与 yapf 标准不一致导致一个通过另一个无法正常通过的问题。这一个方面，我们选择的方式是统一妥协成 flake8 的标准。对于 yapf 不支持的部分，我们建议活用 # yapf: disable 标记。
还有另一个问题是关于一些 flake8 本身的标准（或者说 PEP－8 标准）问题，比如 flake8 常见问题：E501 程序代码长度超过 79 个字符问题，我们实际编码过程中对这一标准做了适当妥协，允许最大单行字符串长度为 200。但是我们仍然建议缩小至 79 个字符内表示完。</description></item><item><title>Python 异步与性能迷思</title><link>https://www.4async.com/2015/11/2015-11-11-async-python/</link><pubDate>Wed, 11 Nov 2015 18:18:18 +0000</pubDate><guid>https://www.4async.com/2015/11/2015-11-11-async-python/</guid><description>今天在讨论 Python 的异步编程的时候提到的问题：到底为什么现在 Python 的异步数据库那么少呢？到底针对 Python 而言，什么是影响 Python 性能最大的门槛呢？
为了搞清楚这个问题，我对线上环境应用使用了性能探针系统。性能出人意料 (CPython 2.7.10)：
线上性能
似乎真实来说，Python 本身的性能问题才是影响 Python 性能的真凶。
在此以前，我们谈这个之前，还是先复习一下什么是 GIL 吧。无论是 CPython(普通的 Python 2.7.x 和 Python 3.5.x) 还是 pypy，都是有一个名曰『Global Interpreter Lock』的东西限制了它的性能，用一张图可以生动的表现带 GIL 的 Python 在多核下的 CPU 压力：
CPU 性能演示
GIL 限制了 Python 的 bytecode 只能在一个线程中运行，使用这种 GIL 避免多线程编程时隐含并发访问对象可能带来的潜在问题，但是也让 Python 在多核下性能表现感人。这种实现方式一直备受诟病，这也导致 Python 在某些高并发场景时会出现较严重的性能下滑问题。
在 Python 性能提升上，比较常见的性能提升的方式，是将多线程转化为多进程方式，以充分利用 CPU 多核心。但是这样带来直接的问题是进程间通讯会严重影响整体程序的吞吐量。一个简单的 CPU 密集 Python socket 的通讯程序，非 Block 状态下，吞吐量能有大概 10 倍以上的差距。(参考 Python Concurrency From the Ground Up )</description></item><item><title>PEP 0492 Coroutines with async and await syntax 中文翻译</title><link>https://www.4async.com/2015/10/2015-10-31-coroutines-with-async-and-await-syntax-chinese/</link><pubDate>Sat, 31 Oct 2015 12:48:15 +0000</pubDate><guid>https://www.4async.com/2015/10/2015-10-31-coroutines-with-async-and-await-syntax-chinese/</guid><description>原文地址: PEP-0492
PEP 492 标题 协程与 async/await 语法 作者 Yury Selivanov &amp;lt;yury at magic.io&amp;gt; 翻译 ipfans &amp;lt;ipfanscn at gmail.com&amp;gt; 状态 最终稿 Python 版本 3.5 翻译最后更新 2015-11-03 目录
摘要 API 设计和实现的备注 基本原理和目标
语法规范
新协程声明语法 types.coroutine() Await 表达式 新的操作符优先级列表 await 表达式示例 异步上下文管理与 async with 新语法 例子 异步迭代器与 async for 新语法 例子 1 例子 2 为什么使用 StopAsyncIteration 协程对象 与生成器的不同之处 协程对象方法 调试特性 新的标准库函数 新的抽象基类 专用术语表</description></item><item><title>从零实现一个 Redis 客户端（二）</title><link>https://www.4async.com/2015/10/2015-10-30-write-aio-python-redis-client-as-dummy-2/</link><pubDate>Fri, 30 Oct 2015 23:11:15 +0000</pubDate><guid>https://www.4async.com/2015/10/2015-10-30-write-aio-python-redis-client-as-dummy-2/</guid><description>从 Call 到命令端 在第一个文章中，我们介绍了实现一个 Call 的客户端基本模型，但只是 Call 怎么能满足需求呢？比如在 redis-py 中，一个完整的客户端应该是这样的：
client = redis.StrictRedis() client.setex(&amp;#34;key&amp;#34;, 10, &amp;#34;value&amp;#34;) 接下来作为一个程序的客户端，需要去做的就是封装出一个 Redis Client。比如 setex 方法：
def setex(self, key, seconds, value): &amp;#34;&amp;#34;&amp;#34;Set the value and expiration of a key. :raises TypeError: if seconds is neither int &amp;#34;&amp;#34;&amp;#34;if not isinstance(seconds, int): raise TypeError(&amp;#34;milliseconds argument must be int&amp;#34;) fut = self._conn.execute(b&amp;#39;SETEX&amp;#39;, key, seconds, value) return wait_ok(fut) 剩下的就是一个个方法逐个完善。
什么是连接池 我们会看到，无论那个数据库客户端，总是会有连接池机制。那么连接池是什么呢？我们为什么需要连接池呢？
首先，我们都知道，对连接而言，创建是必要重型的操作。比如说，TCP 连接，接下来之后是登录认证等等过程，最后才会执行命令。这也就是我们通常计算库性能时，很多时候会把建立连接的时候去掉。但是这就出现了一个问题，当一个连接被占用时，其他的操作仍旧是不能够完成操作了，只能等待前一个操作完成。但是假如我们一次性创建一堆连接呢？从一堆连接中找到空闲的连接，使用完成后释放成空闲的状态，这就是线程池的本质。因为减少了每次创建连接的过程，所以对性能提升也非常有帮助。
从单连接到连接池 首先，还是创建一个 RedisPool 类，用于管理 Redis 的连接池。</description></item><item><title>零基础编写 Python Redis Client（一）</title><link>https://www.4async.com/2015/10/2015-10-10-write-aio-python-redis-client-as-dummy-1/</link><pubDate>Sat, 10 Oct 2015 18:11:15 +0000</pubDate><guid>https://www.4async.com/2015/10/2015-10-10-write-aio-python-redis-client-as-dummy-1/</guid><description>什么是 AIO AIO 是 Asynchronous Input/Output 的简写，也就是异步 IO。不过在谈什么是 AIO 之前，我们可能要先介绍一下 BIO。那么什么是 BIO 呢？简单的说，BIO 是 Blocking Input/Output，也就是阻塞 IO，他实现的通常是在线程池中找出一个线程处理 IO，在 IO 过程中，其他线程都需要等待 IO 完成后才可以从中选取一个线程占用 IO。这样最大的问题是，当线程数量较多，并且需要大量的 IO 操作时，就会造成一个大量的阻塞，因为实际上每次只有一个线程在处理 IO。
那么如何解决这个时候的问题呢？这时候就提出了 AIO 的概念。通常在 IO 处理过程中也会伴有一些其他的处理操作，假如把所有的操作都浪费在了等待 IO 释放上，线程池中的线程利用率也太低了，因此我们需要一种方式，在申请 IO 处理之后，就去继续做其他的事情，等 IO 操作完成了，然后通知我们已经 OK，我们可以继续处理了。这也就是我们常说的 AIO 的原型。
AIO 的情况也说明了它适用的场景：长连接场景，或者重度的 IO 操作等等的情况。
如果找软件来做案例，我们可以找一个可能大家熟知的：NGINX。正如我们所知，NGINX 采用了 异步、事件驱动的方法来处理连接。这种处理方式无需（像使用传统架构的服务器一样）为每个请求创建额外的专用进程或者线程，而是在一个工作进程中处理多个连接和请求。为此，NGINX 工作在非阻塞的 socket 模式下，并使用了 epoll 和 kqueue 这样有效的方法。
这部分的内容，在 NGINX 引入线程池 性能提升 9 倍 中进行了详细的介绍，包含了 NGINX 的异步应用经验，同时介绍了 NGINX 中引入了阻塞的线程池用于解决某些特定场景问题下的效率。
如何实现 Python 的异步 IO 这篇文章会以最新的 Python 3.</description></item><item><title>Python async/await 入门</title><link>https://www.4async.com/2015/08/2015-08-14-introduction-to-async-and-await/</link><pubDate>Fri, 14 Aug 2015 18:11:15 +0000</pubDate><guid>https://www.4async.com/2015/08/2015-08-14-introduction-to-async-and-await/</guid><description>在新版 Python3.5 中，引入了两个新关键字 async 和 await，用于解决在 Python 异步编程中无法有效 区分 yield 生成器与异步的关系的问题。
异步是一个什么东西 异步的作用在于，对于 Python 这种拥有 GIL 的语言，某个线程在处理单个耗时较长的任务时（如 I/O 读取，RESTful API 调用）等操作时，不能有效的释放 CPU 资源，导致其他线程的等待时间随之增加。 异步的作用是，在等待这种花费大量时间的操作数，允许释放 CPU 资源执行其他的线程任务，从而提 高程序的执行效率。
3.4 之前如何实现异步 在 3.5 版本以前的程序中，Python 程序通常是使用 yield 作为一个判断是否进入异步操作的关键词。 比如在 3.4.x 版本中，我们可以用这样的一个例子来看一下 (或者你也可以用一个 Tornado 的例子，这 样你的程序就也可以运行在 2.7.x 版本的 Python 中了)：
import time import asyncio @asyncio.coroutine def slow_operation(n): yield from asyncio.sleep(1) print(&amp;#34;Slow operation {}complete&amp;#34;.format(n)) @asyncio.coroutine def main(): start = time.time() yield from asyncio.wait([slow_operation(1), slow_operation(2), slow_operation(3), ]) end = time.</description></item><item><title>如何用 Python 实现一个权限管理系列 (一)</title><link>https://www.4async.com/2015/07/2015-07-22-howto-make-your-own-permission-plugin/</link><pubDate>Wed, 22 Jul 2015 11:00:15 +0000</pubDate><guid>https://www.4async.com/2015/07/2015-07-22-howto-make-your-own-permission-plugin/</guid><description>最近在实现大型 B2B 系统之后，有很多细节需要考虑，其中一环就是权限控制。之前考虑的比较少，认为这一块框架可以 handle 问题不大，后来发现 Tornado 目前没有一个比较完善的权限管理模块，甚至连个包都没有&amp;hellip; 于是只能自己动手，丰衣足食了。参考的方式也是通过 Flask-Principal 的类似实现方式。
原型 一个权限管理模块应该有的功能应该有哪些呢？从基本角度出发，应该包含用户身份 (Identity)、用户角色（RoleNeed）、用户权限（Permission）这三个最基本的分类组成。那么从最开始，就需要定义这几个类：
class RoleNeed(object): pass class Identity(object): pass class Permission(object): pass 再考虑一下，其实 RoleNeed 更像一个权限的枚举数组，除此之外，比如用户可能存在的权限与分组和单独的用户权限都有关系，这里需要更加抽象一下。具体的可以分成 UserNeed 和 RoleNeed，分别对应用户权限与用户组权限。这样如果通过类实现还是比较麻烦，需要继承，但是实际上这也只是一个元组而已。所以可以选择下面的方式：
from functools import partial。 from collections import namedtuple Need = namedtuple(&amp;#39;Need&amp;#39;, [&amp;#39;method&amp;#39;, &amp;#39;value&amp;#39;]) UserNeed = partial(Need,&amp;#39;user&amp;#39;) RoleNeed = partial(Need,&amp;#39;role&amp;#39;) namedtuple 是 Python 高级数据结构中的一个内容，在 collections 包中，其实实现的效果是生成带名称的元组。比如 Need = namedtuple(&amp;lsquo;Need&amp;rsquo;, [&amp;lsquo;method&amp;rsquo;, &amp;lsquo;value&amp;rsquo;]) 实际上就是生成了一个名字叫做 Need 的元组，你可以通过 Need(&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;) 的方式设置对应的 method 和 value 的值。
接下来的 partial 是和之前我另一篇文章中介绍的 wraps 在一个包中的功能，可以简单理解为方便填入一个初始化参数的方法，比如 partial(Need,&amp;lsquo;user&amp;rsquo;) 等同于 Need(&amp;lsquo;user&amp;rsquo;, x)，但是 x 的这个参数需要在调用 parial 的返回值的时候才会传入，可以用来预定义一部分的环境参数。</description></item><item><title>Python Decorator 修饰器简介</title><link>https://www.4async.com/2015/06/2015-06-17-something-about-python-decorator/</link><pubDate>Wed, 17 Jun 2015 18:00:15 +0000</pubDate><guid>https://www.4async.com/2015/06/2015-06-17-something-about-python-decorator/</guid><description>很久没有写技术存档了，太过于罪恶。最近在智能硬件创业公司担任架构师，推广一些更新更酷的技术应用在各个方面，包括 Golang/Python/Docker 等，如果你有兴趣，也欢迎加入我们: kevin[at yeeuu[dot]com。广告时间结束。
Python 的修饰器是比较常见的开发应用帮助工具，他可以实现一些批量的修饰工作，比如统一来添加一些小功能等等。但是这些功能对原有的函数不产生侵入，也就是说可以实现快速的修改和替换、移除。
如果你使用过 Python 的 Web 框架，相信你对修饰器应该并不陌生：Django、Flask、Tornado 等常见的框架中都包含了修饰器的使用。
那么 decorators 是怎么实现的呢？还是先从一个简单的例子开始。先看下 Tornado 中的 tornado.web.authenticated 使用。
class IndexHandler(tornado.web.RequestHandler): @tornado.web.authenticated def get(self): self.render(&amp;#39;index.html&amp;#39;) tornado.web.authenticated 的作用就是判断 self.current_user 是否为 None 或者为空，否则跳转到之前设置的 login_url 地址去。至于获取 current_user 的内容，可以通过重载 get_current_user 函数实现。
在查看修饰器的具体代码之前，我们先来了解一下 Python 修饰器的原理。Python 的修饰器其实是实现了下面的一个简单功能：
@decorator def func(): pass 等价于
func = decorator(func) 多层的修饰器则是实现了多层的回调调用。同时在底层层面，提供了 functools 包 用于实现相关功能，注意，该包是 2.5 之后版本中引入，如果你还在使用古老的 Python 版本，则可以手工实现同等功能。
具体功能 实现代码 如下：
def authenticated(method): &amp;#34;&amp;#34;&amp;#34;Decorate methods with this to require that the user be logged in.</description></item><item><title>Python 获取当前执行文件名和行数</title><link>https://www.4async.com/2014/10/2014-10-22-python-get-current-line-and-filename/</link><pubDate>Wed, 22 Oct 2014 12:21:15 +0000</pubDate><guid>https://www.4async.com/2014/10/2014-10-22-python-get-current-line-and-filename/</guid><description>这个发现是 logger 或者 traceback 是有这个功能的，所以简单的研究了一下，其实很简单：
#!/usr/bin/env python # -*- coding: utf-8 -*- import sys print sys._current_frames().values()[0].f_code.co_filename, print sys._current_frames().values()[0].f_lineno 执行结果如下：
printno.py 7</description></item><item><title>快速确认 Python 对象结构</title><link>https://www.4async.com/2014/05/2014-05-30-quick-identify-python-object-struct/</link><pubDate>Fri, 30 May 2014 00:10:15 +0000</pubDate><guid>https://www.4async.com/2014/05/2014-05-30-quick-identify-python-object-struct/</guid><description>好吧，这个问题确实比较蛋疼的一个问题，也是最近经常遇到的问题。具体的原因是这样的，最近使用了一个开源的库实现功能，实现方法是使用的回调方式。这样就出现了一个问题，回调过来的对象是什么格式的我并不知道具体细节。有人说，看看文档不就行了么，问题是这个项目他就没个详细文档。其实读代码也是可以解决这个问题的，但是实际上这是一个时间的工作，并且很容易会把自己也绕进去。那怎么办呢？别急，往下看。
直接 dir 输出属性 这个很简单了，直接 print dir(对象名) 就可以打印对象的属性名称了。不过这个得来回测试一下，不能一次性把所有的想要的都能得到。
利用 pdb 快速定位 pdb 是官方库中的 Python Debugger，使用方法也比较简单：在 Python 代码中 import pdb 库，然后在指定的位置添加一句：pdb.set_trace()。以我的代码为例，我需要了解 msg 的结构：
class StickyMaster(controller.Master): ...... def handle_request(self, msg): pdb.set_trace() ...... 然后正常执行这个程序，在执行到这句时，得到如下结果：
✗ python pdbtest.py ...... &amp;gt; pdbtest.py(63)handle_request() -&amp;gt; if allow_check(msg) is False: (Pdb) 是不是看起来很像 gdb 一类的工具？这个时候输入命令查看对象了，输入 h 可以查看帮助：
(Pdb) h Documented commands (type help &amp;lt;topic&amp;gt;): ======================================== EOF bt cont enable jump pp run unt a c continue exit l q s until alias cl d h list quit step up args clear debug help n r tbreak w b commands disable ignore next restart u whatis break condition down j p return unalias where Miscellaneous help topics: ========================== exec pdb Undocumented commands: ====================== retval rv 接下来查看下当前变量：</description></item><item><title>利用 Cython 加速 Python 代码</title><link>https://www.4async.com/2014/05/2014-05-17-speed-python-code-with-cython/</link><pubDate>Sat, 17 May 2014 17:41:14 +0000</pubDate><guid>https://www.4async.com/2014/05/2014-05-17-speed-python-code-with-cython/</guid><description>先从一个例子来说，一个斐波那契数列数列例子说起：
# fib.py #!/usr/bin/env python # -*- coding: utf-8 -*- def fib(i): a = 0 b = 1 while i &amp;gt; 0: i -= 1 a, b = b, a+b return True # try_c.py #!/usr/bin/env python # -*- coding: utf-8 -*- import time from fib import fib startTime = time.time() for i in xrange(1,10): fib(10**6) print time.time() - startTime 在 CPython 下执行效果如下：
➜ cython python try_c.py 429.003911972 换成 pypy 的话，效率会更高一些：</description></item><item><title>解决 Mavericks 系统上 Python 库 - mno-fused-madd 错误</title><link>https://www.4async.com/2014/04/2014-04-08-fix-build-python-ext-on-mac-os-x-mavericks-with-error-mno-fused-madd/</link><pubDate>Tue, 08 Apr 2014 11:43:52 +0000</pubDate><guid>https://www.4async.com/2014/04/2014-04-08-fix-build-python-ext-on-mac-os-x-mavericks-with-error-mno-fused-madd/</guid><description>最近升级了一下 simplejson，发现 simplejson 的 speedup 模块报了一个错误：
Installing collected packages: simplejson Found existing installation: simplejson 3.3.1 Uninstalling simplejson: Successfully uninstalled simplejson Running setup.py install for simplejson building 'simplejson._speedups' extension cc -fno-strict-aliasing -fno-common -dynamic -arch x86_64 -arch i386 -g -Os -pipe -fno-common -fno-strict-aliasing -fwrapv -mno-fused-madd -DENABLE_DTRACE -DMACOSX -DNDEBUG -Wall -Wstrict-prototypes -Wshorten-64-to-32 -DNDEBUG -g -fwrapv -Os -Wall -Wstrict-prototypes -DENABLE_DTRACE -arch x86_64 -arch i386 -pipe -I/System/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7 -c simplejson/_speedups.c -o build/temp.macosx-10.9-intel-2.7/simplejson/_speedups.o clang: error: unknown argument: '-mno-fused-madd' [-Wunused-command-line-argument-hard-error-in-future] clang: note: this will be a hard error (cannot be downgraded to a warning) in the future *************************************************************************** WARNING: The C extension could not be compiled, speedups are not enabled.</description></item><item><title>短小精悍 Falcon</title><link>https://www.4async.com/2014/04/2014-04-02-falcon-web-framework/</link><pubDate>Wed, 02 Apr 2014 19:47:51 +0000</pubDate><guid>https://www.4async.com/2014/04/2014-04-02-falcon-web-framework/</guid><description>之前一直是 Flask 的忠实粉丝，然后嘲讽下 Django 党；结果被 falcon 打脸，恩，下面是我的真机实际测试（i5-3230M 2.6G 8G RAM, SSD。乱码的是什么呢&amp;hellip;.）：
Benchmarking, Trial 1 of 3......done. Benchmarking, Trial 2 of 3......done. Benchmarking, Trial 3 of 3......done. Results: 1. falcon.........34,165 req/sec or 29.27 渭 s/req (9x) 2. falcon-ext.....25,752 req/sec or 38.83 渭 s/req (7x) 3. bottle.........17,043 req/sec or 58.67 渭 s/req (5x) 4. pecan...........7,915 req/sec or 126.34 渭 s/req (2x) 5. werkzeug........6,241 req/sec or 160.24 渭 s/req (2x) 6. flask...........3,762 req/sec or 265.</description></item><item><title>Python 分发包制作（一）</title><link>https://www.4async.com/2014/03/2014-03-28-python-distribute-building-part-one/</link><pubDate>Fri, 28 Mar 2014 11:33:51 +0000</pubDate><guid>https://www.4async.com/2014/03/2014-03-28-python-distribute-building-part-one/</guid><description>之前我在 Python 开发实践 中曾经提到过通过 python distribute 实现包分发。但是一直没有机会研究如何实现 (没错&amp;hellip;)，今天就粗略的通过一个例子简单描述一下一个包的制作：
# setup.py #!/usr/bin/env python # -*- coding: utf-8 -*- from setuptools import setup, find_packages import sys # 兼容旧版本 setuptools extra = {} if sys.version_info &amp;gt;= (3,): extra[&amp;#39;use_2to3&amp;#39;] = True extra[&amp;#39;convert_2to3_doctests&amp;#39;] = [&amp;#39;src/your/module/README.txt&amp;#39;] extra[&amp;#39;use_2to3_fixers&amp;#39;] = [&amp;#39;your.fixers&amp;#39;] setup( # 包名称 name=&amp;#39;your.module&amp;#39;, # 版本号 version = &amp;#39;1.0&amp;#39;, # 包描述 description=&amp;#39;This is your awesome module&amp;#39;, # 作者名称 author=&amp;#39;You&amp;#39;, # 作者 URL author_email=&amp;#39;your@email&amp;#39;, # 如果有需要 license = &amp;#34;PSF&amp;#34;, # 如果有需要 url = &amp;#34;&amp;#34;, # 依赖包 install_requires=[], # 源代码目录 package_dir = {&amp;#39;&amp;#39;:&amp;#39;src&amp;#39;}, # 包文件 packages = find_packages(), # 包含其他必须文件，前面是文件夹，后面是扩展名，将会按此格式排列文件 package_data = {# include them:&amp;#39;&amp;#39;: [&amp;#39;*.</description></item></channel></rss>