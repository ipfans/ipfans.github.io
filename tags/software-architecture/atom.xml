<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software Architecture on ipfans's Blog</title><link>https://www.4async.com/tags/software-architecture/</link><description>Recent content in Software Architecture on ipfans's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 23 Nov 2023 09:39:00 +0000</lastBuildDate><atom:link href="https://www.4async.com/tags/software-architecture/atom.xml" rel="self" type="application/rss+xml"/><item><title>使用子解释器运行Python并行应用</title><link>https://www.4async.com/2023/11/python-312-sub-interpreters/</link><pubDate>Thu, 23 Nov 2023 09:39:00 +0000</pubDate><guid>https://www.4async.com/2023/11/python-312-sub-interpreters/</guid><description>&lt;img src="https://www.4async.com/cover.png" alt="Featured image of post 使用子解释器运行Python并行应用" />译者注：最近 Python 3.12 引入了子解释器概念，非常火热，更好的消息是已经在FastAPI应用成功了，虽然是很简单的那种。因此顺腾摸瓜，找到了作者的博客，翻译分享给大家。
Python 3.12 引入了一个新的 API 用于“子解释器”（sub interpreters），这是 Python 的一种不同的并行执行模型，提供了真正并行处理和多进程处理之间的良好折中，且具有更快的启动时间。在这篇文章中，我将解释什么是子解释器，为什么它对 Python 中的并行代码执行很重要，以及它与其他方法的比较。
什么是子解释器？ Python 的系统架构大致由三部分组成：
一个包含一个或多个解释器的 Python 进程 一个包含锁（GIL）和一个或多个 Python 线程的解释器 一个包含当前执行代码信息的线程。 要了解更多关于这方面的信息，你可以阅读我的书《CPython 内部实现》中的“并行性和并发性”章节。
自 Python 1.5 以来，就有一个 C-API 可以支持多个解释器，但这个功能由于 GIL 的限制而受到严重限制，没有真正实现真正的并行性。因此，运行并行代码最常用的技术（不使用第三方库）是使用 multiprocessing 模块。
2017 年，CPython 核心开发人员提出改变解释器结构的提议，使它们更好地与拥有它们的 Python 进程隔离，并能够并行操作。实现这一目标的工作相当巨大（6 年后仍未完成），并分为两个 PEP。PEP684 将 GIL 在各个解释器独立开，PEP554 提供了一个创建解释器和在它们之间共享数据的 API。
GIL 是“全局解释器锁”，是 Python 进程中的一个锁，意味着在任何时间点 Python 进程中只能执行一条指令，即使它有多个线程。这实际上意味着，即使你在拥有 4 核 CPU 的电脑上同时启动 4 个 Python 线程，也只有一个线程会在任何时候运行。
你可以通过创建一个 numpy 数组或整数，并粗略计算每个值与 50 的距离来进行一个简单的测试：
import numpy # Create a random array of 100,000 integers between 0 and 100 a = numpy.</description></item><item><title>Twirp初相识</title><link>https://www.4async.com/2023/01/twirp-first-step/</link><pubDate>Wed, 25 Jan 2023 09:39:00 +0000</pubDate><guid>https://www.4async.com/2023/01/twirp-first-step/</guid><description>&lt;img src="https://www.4async.com/2023/01/twirp-first-step/cover.png" alt="Featured image of post Twirp初相识" />什么是Twirp？ Twirp是Twitch在2018年开源的RPC框架。正如同他们在发布文章中说的那样，RPC相对于普通的RESTful API更方便设计、组织和维护，让开发者更加专注于业务。但是同样的，在Go社区中重要的gRPC方案严重与HTTP/2绑定，这也成为一个制约其推广的问题：HTTP/2的复杂性其实并不必要；与Go Runtime的割裂也是另外一个问题，导致部分优化难以直接通过升级Go版本在gRPC上显现。
Twirp则选择保留了部分好的地方：使用Protobuf这个IDL约束请求/返回类型，这样可以最大化借助Protobuf带来的优势，生成客户端和服务端代码。但是Twirp选择与Go标准库集成，这样可以更好的利用Go本身升级带来的优化。这同时也保证了Twirp本身的简洁性。同时，你也可以很方便的使用cURL等传统工具，借助json请求测试，而不需要手工处理二进制数据。同样的，借助Go标准库，未来Twirp可以更好的升级成HTTP/3而不是像gRPC一样等待上游更新。当然如果你更倾向于使用gRPC相关的实践，那么connect-go可能是你的另外一个不错选择。
当然，如果说缺点，Twirp并不完美：小众的社区，缺少生态，缺少相关信息内容等等。不过这些仍旧是瑕不掩瑜。毕竟实现一个相关的功能其实并不那么复杂。
如何使用Twirp Twirp虽然官网比较简单，甚至社区也不是很大的样子，但是基本上需求的数据基本都可以在官网上找到入口。但是这也有个问题，导致整个流程对新手并不友好，有比较高的上手门槛。接下来的内容主要是完善这部分的内容，方便新手用户使用。
安装Protobuf相关工具 由于Twirp同样使用Protobuf，我们需要使用相关工具。首先是Protobuf，接下来是一些protoc-gen工具：
brew install protobuf # Mac Only go install google.golang.org/protobuf/cmd/protoc-gen-go@latest go install github.com/twitchtv/twirp/protoc-gen-twirp@latest 可选项：Buf Buf是一个Protobuf管理工具，帮助你实现Schema Driven Development实践。它提供了一个CLI管理工具（支持lint，生成和破坏性检查等功能）和类似注册中心机制的BSR(Buf Schema Registry)，你可以在这里管理你的Schema版本和引用其他公开服务的Schema。不使用Buf并不会带来功能缺失，并且Buf提供了付费SaaS服务(测试期间免费)，可以根据你的情况选择是否使用。
brew install bufbuild/buf/buf # Mac Only 可选项：Taskfile Taskfile是我常用来替代Makefile的工具。这并不是必须的工具，你同样可以使用手工执行命令行和Makefile命令进行。事实上，使用Makefile其实可以更好的在Jenkins之类的pipeline里执行，但是对Github Action等现代pipeline而言，区别并不大。
brew install go-task/tap/go-task # Mac Only 生成项目文件 这里我们使用一个简单的Greeter程序演示使用。假设我们已经存在了一个Go的空项目，那么我们接下来需要创建对应的目录和文件。按照官方的建议，我们可以使用如下结构创建我们的项目，你可以在Github上查看完整的代码：
$ tree . . ├── README.md ├── Taskfile.yaml ├── buf.gen-ts.yaml ├── buf.gen.yaml ├── buf.yaml ├── build ├── client │ ├── package.json │ ├── pnpm-lock.yaml │ └── src │ └── protoc-gen-twirp-es.</description></item><item><title>Twirp基本概念：Hooks和Interceptors</title><link>https://www.4async.com/2023/01/twirp-hooks-and-interceptors/</link><pubDate>Wed, 25 Jan 2023 09:39:00 +0000</pubDate><guid>https://www.4async.com/2023/01/twirp-hooks-and-interceptors/</guid><description>&lt;img src="https://www.4async.com/2023/01/twirp-hooks-and-interceptors/cover.png" alt="Featured image of post Twirp基本概念：Hooks和Interceptors" />Twirp做了足够多的抽象工作，使得我们可以在不同的层次上进行扩展。在最基础的使用层面上，你可以像net/http一样去简单的使用。但是往往这样也不能满足我们实际项目中的需求在这篇文章中，我们将介绍Twirp的Hooks和Interceptors基本概念，以及如何使用这些Twirp的扩展机制。</description></item><item><title>去年的一点小工作(1)：从BFF谈起</title><link>https://www.4async.com/2023/01/something-happend-in-2022-1/</link><pubDate>Sat, 21 Jan 2023 17:55:39 +0000</pubDate><guid>https://www.4async.com/2023/01/something-happend-in-2022-1/</guid><description>&lt;img src="https://www.4async.com/2023/01/something-happend-in-2022-1/cover.jpg" alt="Featured image of post 去年的一点小工作(1)：从BFF谈起" />&lt;p>前年底，之前创业的公司关掉正式回归了打工生活。现在在一家SaaS公司做一些新业务开发和架构的工作。这个系列的文章也是想整理一下2022年的一些小成果，有一些内容和相关背景可能因为各种原因无法描述更细节的内容，也请各位见谅。&lt;/p>
&lt;h1 id="后端和前端的配合我们遇到了什么问题">后端和前端的配合，我们遇到了什么问题？&lt;/h1></description></item></channel></rss>