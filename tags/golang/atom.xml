<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on ipfans's Blog</title><link>https://www.4async.com/tags/golang/</link><description>Recent content in Golang on ipfans's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 17 Aug 2021 17:48:00 +0000</lastBuildDate><atom:link href="https://www.4async.com/tags/golang/atom.xml" rel="self" type="application/rss+xml"/><item><title>Go 1.17 泛型尝鲜</title><link>https://www.4async.com/2021/08/golang-117-generics/</link><pubDate>Tue, 17 Aug 2021 17:48:00 +0000</pubDate><guid>https://www.4async.com/2021/08/golang-117-generics/</guid><description>今天，Go的1.17版本终于正式发布，除了带来各种优化和新功能外，1.17正式在程序中提供了尝鲜的泛型支持，这一功能也是为1.18版本泛型正式实装做铺垫。意味着在6个月后，我们就可以正式使用泛型开发了。那在Go 1.18正式实装之前，我们在1.17版本中先尝鲜一下泛型的支持吧。
泛型是什么？ 在使用Go没有泛型之前我们怎么实现针对多类型的逻辑实现的呢？有很多方法，比如说使用interface{}作为变量类型参数，在内部通过类型判断进入对应的处理逻辑；将类型转化为特定表现的鸭子类型，通过接口定义的方法实现逻辑整合；还有人专门编写了Go的函数代码生成工具，通过批量生成不同类型的相同实现函数代替手工实现等等。这些方法多多少少存在一些问题：使用了interface{}作为参数意味着放弃了编译时检查，作为强类型语言的一个优势就被抹掉了。同样，无论使用代码生成还是手工书写，一旦出现问题，意味着这些方法都需要重复生成或者进行批量修改，工作量反而变得更多了。
在Go中引入泛型会给程序开发带来很多好处：通过泛型，可以针对多种类型编写一次代码，大大节省了编码时间。你可以充分应用编译器的编译检查，保证程序变量类型的可靠性。借助泛型，你可以减少代码的重复度，也不会出现一处出现问题需要修改多处地方的尴尬问题。这也让很多测试工作变得更简单，借助类型安全，你甚至可以少考虑很多的边缘情况。
Go语言官方有详细的泛型提案文档可以在这里和这里查看详情。
如何使用泛型 前面理论我们仅仅只做介绍，这次尝鲜还是以实践为主。让我们先从一个小例子开始。
从简单的例子开始 让我们先从一个最简单的例子开始：
package main import ( &amp;#34;fmt&amp;#34; ) type Addable interface { type int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, uintptr, float32, float64, complex64, complex128, string } func add[T Addable](a, b T) T { return a + b } func main() { fmt.Println(add(1,2)) fmt.Println(add(&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;)) } 这个函数可以实现任何需要使用+符号进行运算的类型，我们通过定义Addable类型，枚举了所有可能可以使用add方法的所有的类型。比如我们在main函数中就使用了int和string两种不同类型。
但是如果这时我们使用简单的go run命令运行，会发现提示语法错误：
$ go version go version go1.17 darwin/arm64 $ go run ~/main.</description></item><item><title>上下文Context与结构体Struct</title><link>https://www.4async.com/2021/02/2021-02-25-context-and-structs/</link><pubDate>Thu, 25 Feb 2021 10:30:00 +0000</pubDate><guid>https://www.4async.com/2021/02/2021-02-25-context-and-structs/</guid><description>原文地址：https://blog.golang.org/context-and-structs 原文作者：Jean de Klerk, Matt T. Proud 译者：Kevin 介紹 在许多Go API中，尤其是现代的API中，函数和方法的第一个参数通常是context.Context。上下文（Context）提供了一种方法，用于跨API边界和进程之间传输截止时间、调用者取消和其他请求范围的值。当一个库与远程服务器（如数据库、API等）直接或间接交互时，经常会用到它。
在context的文档中写道。
上下文不应该存储在结构类型里面，而是传递给每个需要它的函数。 本文对这一建议进行了扩展，用具体例子解析为什么传递上下文而不是将其存储在其他类型中很重要。它还强调了一种罕见的情况，即在结构类型中存储上下文可能是有意义的，以及如何安全地这样做。
倾向于将上下文作为参数传递 为了深入理解不在结构中存储上下文的建议，我们来考虑一下首选的上下文作为参数的方法。
type Worker struct { /* … */ } type Work struct { /* … */ } func New() *Worker { return &amp;amp;Worker{} } func (w *Worker) Fetch(ctx context.Context) (*Work, error) { _ = ctx // 每次调用中ctx用于取消操作，截止时间和元数据。 } func (w *Worker) Process(ctx context.Context, w *Work) error { _ = ctx // A每次调用中ctx用于取消操作，截止时间和元数据。 } 在这个例子中，(*Worker).Fetch和(*Worker).Process方法都直接接受上下文。通过这种通过参数传递的设计，用户可以设置每次调用的截止时间、取消和元数据。而且，很清楚传递给每个方法的context.Context将如何被使用：没有期望传递给一个方法的context.Context将被任何其他方法使用。这是因为上下文的范围被限定在了小范围的必须操作内，这大大增加了这个包中上下文的实用性和清晰度。</description></item><item><title>Go 1.16 中Module功能新变化</title><link>https://www.4async.com/2021/02/2021-02-19-go116-module-changes/</link><pubDate>Fri, 19 Feb 2021 10:16:00 +0000</pubDate><guid>https://www.4async.com/2021/02/2021-02-19-go116-module-changes/</guid><description>原文地址：https://blog.golang.org/go116-module-changes 原文作者：Jay Conrod 译者：Kevin 希望您喜欢Go 1.16! 这个版本有很多新功能，特别是对Module而言。发行说明中简要介绍了这些变化，但让我们深入发掘一下其中的一些变化。
Module功能默认开启 go命令现在默认以module-aware模式构建包，即使没有go.mod文件存在。这是向在所有项目中使用Module功能迈出的一大步。
通过设置GO111MODULE环境变量为off，仍然可以在GOPATH模式下构建包。你也可以将GO111MODULE设置为auto，只有当当前目录或任何父目录中存在go.mod文件时才启用module-aware模式。这在以前是默认的。请注意，您可以使用go env -w来永久地设置GO111MODULE和其他变量。
go env -w GO111MODULE=auto 我们计划在 Go 1.17 中放弃对GOPATH模式的支持。换句话说，Go 1.17将忽略GO111MODULE。如果您的项目没有以module-aware模式构建，现在是时候迁移了。如果有问题妨碍您迁移，请考虑提交问题或体验报告。
不会自动更改 go.mod 和 go.sum 在之前的版本中，当go命令发现go.mod或go.sum有问题时，比如缺少require指令或缺少sum，它会尝试自动修复问题。我们收到了很多反馈，认为这种行为是出乎大家意料的，尤其是对于像go list这样通常不会产生副作用的命令。自动修复并不总是可取的：如果一个导入的包没有被任何需要的Module提供，go命令会添加一个新的依赖关系，可能会触发普通依赖关系的升级。即使是拼写错误的导入路径也会导致（失败的）网络查找。
在 Go 1.16 中，module-aware命令在发现go.mod或go.sum中的问题后会报告一个错误，而不是尝试自动修复问题。在大多数情况下，错误信息建议使用命令来修复问题。
$ go build example.go:3:8: no required module provides package golang.org/x/net/html; to add it: go get golang.org/x/net/html $ go get golang.org/x/net/html $ go build 和之前一样，如果存在vendor目录，go命令可能会使用该目录（详见Vendoring）。像go get和go mod tidy这样的命令仍然会修改go.mod和go.sum，因为它们的主要目的是管理依赖关系。
在特定版本上安装可执行文件 go install命令现在可以通过指定@version后缀来安装特定版本的可执行文件。
go install golang.org/x/tools/gopls@v0.6.5 当使用这种语法时，go install命令会从该Module的制定版本安装，而忽略当前目录和父目录中的任何 go.mod 文件。(如果没有@version后缀，go install会像往常一样继续运行，使用当前Module的go.mod中列出的版本要求和替换来构建程序。)
我们曾经推荐使用go get -u程序来安装可执行文件，但这种使用方式对go.</description></item><item><title>OpenTelemetry入门</title><link>https://www.4async.com/2020/03/2020-03-31-intro-opentelemetry/</link><pubDate>Tue, 31 Mar 2020 11:10:00 +0000</pubDate><guid>https://www.4async.com/2020/03/2020-03-31-intro-opentelemetry/</guid><description>&lt;p>今天早些时候，&lt;a class="link" href="https://opentelemetry.io/" target="_blank" rel="noopener"
>OpenTelemetry&lt;/a>正式&lt;a class="link" href="https://medium.com/opentelemetry/opentelemetry-is-officially-in-beta-352fa859db10" target="_blank" rel="noopener"
>进入Beta版本阶段&lt;/a>，这标志着OpenTelemetry的基本模型已经正式确定，可以开始将OpenTelemetry集成到应用程序和客户端库中，以捕获应用程序级指标和分布式跟踪。&lt;/p></description></item><item><title>译：在Go中转向领域驱动设计</title><link>https://www.4async.com/2020/02/2020-02-16-moving-towards-domain-driven-design-in-go/</link><pubDate>Sun, 16 Feb 2020 21:52:00 +0000</pubDate><guid>https://www.4async.com/2020/02/2020-02-16-moving-towards-domain-driven-design-in-go/</guid><description>&lt;p>原文：&lt;a class="link" href="https://www.calhoun.io/moving-towards-domain-driven-design-in-go/" target="_blank" rel="noopener"
>Moving Towards Domain Driven Design in Go&lt;/a>&lt;/p>
&lt;p>本文的目的是帮助演示当应用程序随着时间不断推移不断演化时，我们如何利用领域驱动设计帮我们解决可能遇到的问题。为了实现这个目标，我们会通过一个琐碎的项目研究项目是如何随着时间一步步演化的。这不是一个完整的项目，示例代码并不能够直接编译，甚至有些导入以来没有全部列出。这只是一个简单的示例，也就是说，如果出现什么问题，你可以随时与我联系，我们将对问题进行调整或者你的问题及时解答（如果可以的话）。&lt;/p></description></item><item><title>从 Go 语言的依赖库讲起（2）监控、分布式追踪和日志</title><link>https://www.4async.com/2020/02/2020-02-05-golang-debug-instrumental/</link><pubDate>Wed, 05 Feb 2020 18:30:00 +0000</pubDate><guid>https://www.4async.com/2020/02/2020-02-05-golang-debug-instrumental/</guid><description>&lt;p>我们通常会遇到线上甚至测试中代码出现问题，这些问题可能来自于我们开发过程中的引入的BUG，有些来自于我们的功能未得到理想结果的，甚至有一些问题来自于运行环境的。很多事情可能未必能够足够可控，尤其是上线之后才发现出现了问题。除了我们&lt;a class="link" href="" >前面一篇文章&lt;/a>中介绍了一些测试相关的内容，虽然可以解决一部分问题，但是这些并不能完全杜绝所有问题在线上一定不会出现任何问题。因此我们需要建立对发布/预发环境一套相对完善的监控、诊断机制，保证我们可以尽快进行故障的分析和溯源。&lt;/p></description></item><item><title>从 Go 语言的依赖库讲起（1）Ginkgo、testify和GoMock</title><link>https://www.4async.com/2020/01/2020-01-10-golang-test-driven-toolkit/</link><pubDate>Fri, 10 Jan 2020 17:30:00 +0000</pubDate><guid>https://www.4async.com/2020/01/2020-01-10-golang-test-driven-toolkit/</guid><description>&lt;p>对开发而言，测试的重要性相信对每个开发者而言是老生常谈的事情。虽然我们很有可能在开发过程中由于各种原因会希望后续补全，然而事实上我更建议采用“Tests that fail then pass”原则去处理在实际开发过程中遇到的问题。&lt;/p>
&lt;p>在我们开发过程的初期阶段，开发质量的保持更多依赖开发人员自身素质保持。但是对一个团队而言，未必能够一直保持人员的高素质开发。在这个过程中，人员的变动，新老编码习惯的冲突，人员能力的残次不齐都有可能导致代码的腐化。在测试过程中，我们选择引入测试保障代码的质量&lt;/p>
&lt;p>Go本身提供了基础的测试功能，但是这个功能在实际使用过程中仍有使用起来功能较弱的问题。比如我们在使用过程中，需要使用额外的库让测试代码更佳高效。在实际实践过程中，我推荐使用&lt;code>Ginkgo&lt;/code>、&lt;code>testify&lt;/code>和&lt;code>GoMock&lt;/code>工具。&lt;/p></description></item><item><title>从Go语言的依赖库讲起（0）：让我们聊聊如何开发更方便维护的Go语言程序</title><link>https://www.4async.com/2019/11/2019-11-23-learning-go-from-3rd-library/</link><pubDate>Sat, 23 Nov 2019 22:43:00 +0000</pubDate><guid>https://www.4async.com/2019/11/2019-11-23-learning-go-from-3rd-library/</guid><description>缘起 今年是Go语言的10年生日，准确的说应该是Go开放于2009年，当时虽然公开了，但是其实真正的可用性并不是很好。甚至Windows的支持都没有。当时我的主要环境还是在Windows平台，因此没有太关注Go语言。在2012年Go语言正式发布1.0版本之后，我当时工作环境转移到了Linux/macOS/iOS相关的产品上，因此重新学习了一下Go语言。
后来在Go的1.3版本发布后，我在支付宝的内部系统中第一次上线了一个基于Go语言的边缘服务，也是第一次将Go语言应用到了实际的生产环境中。后来在云柚科技创业过程中，正式将Go语言作为我们物联网环境的第一优选语言（也基本上是唯一语言），大规模的批量部署Go语言项目和代码。
聊聊如何开发更方便维护的Go语言程序 对Go语言而言，开发似乎是简单的事情：Go本身的语法比较简单，关键词不多，可以快速上手。如果基本功能而言，能采用的花式解法不多，导致Go语言的上手比较简单，对我们创业期间的公司而言，享受到了很多这种方面带来的很多红利：我们工程师基本上都是其他语言/岗位转型过来的全(quan)栈(gan)工程师，他们也为我们业务的快速发展提供了原生的动力。
然而，当我们把时间稍微放长一点，我们会发现当时我们仍旧遗留下了很多历史性的技术债，这些内容包含了我们当时对于代码质量的妥协，由其他语言习惯带过来的洋玩意但有点水土不服，一些过度的设计，一些库选择上和我们后续的最佳实践相违背等等问题。
这里面，一些软性的东西其实我们可以通过一些非编码环节去解决：对开发过的代码要求提供单元测试和开发后的Code Review；在技术开发之前进行沟通，规避可能出现的过度设计问题等等。不过，我想了想，这些更多属于规范性的问题，各个公司自有自身的特色在，那么还有什么内容可以更适合初中级开发一块聊一聊的呢？
那么毫无疑问就是对依赖库的选择。这部分的内容直接与我们在开发过程中会采用的实际最佳实践相关，无论是多人合作项目，还是单枪匹马的开源项目开发，各种依赖库无法避免：它们可以帮我们有效提升开发效率，帮我们落地最佳实践，让我们更快的更高效的完成工作。因此，我打算从这个系列中，一方面去聊聊我们未来会介绍的依赖库的使用；另外一方面，也想通过这个系列，聊聊如何是使用依赖库的过程中，将各种最佳实践一一落地。我们可能会介绍为什么选择这个依赖库，这个依赖库会带给我们的实践会是怎么样的。
不过在这里仍旧提醒一句，这里提到的所有的功能和实践均为在实际项目中总结的内容，部分实践则可根据个人情况进行实际选择。所有的实践并非全部都是最优解，仍需根据实际项目情况进行对应的调整和抉择。
最后，希望你们能够喜欢这个系列。：）</description></item><item><title>使用Go Modules</title><link>https://www.4async.com/2019/03/2019-03-20-using-go-modules/</link><pubDate>Wed, 20 Mar 2019 14:22:00 +0000</pubDate><guid>https://www.4async.com/2019/03/2019-03-20-using-go-modules/</guid><description>原文：Using Go Modules 作者：Tyler Bui-Palsulich、Eno Compton
介绍 Go 1.11和1.12包含了初步的modules支持，Go的新版本管理系统用于依赖版本信息描述和更方便的管理。这篇博客是一个关于开始使用modules的基础操作指引教程。后续文章会介绍发布一个其他人可以使用的modules。
modules是Go包的集合，保存在顶层目录一个名叫go.mod的文件中。go.mod文件定义了模块的路径，这个会作为根目录引用路径；同时文件中也包含了能够正常构建的其他包依赖需求。每个依赖需求同样以模块路径方式标示，同时根据语义化版本方式进行标记。
在Go 1.11开始，go命令行会再当前目录或者上层目录中存在go.mod文件并且在 $GOPATH/src目录外时自动启用modules功能。（当目录位于$GOPATH/src中时，出于兼容性考虑，go命令仍旧采用GOPATH模式，即便存在go.mod文件。具体请参考Go命令行文档）。从Go 1.13版本开始，modules功能将会在所有开发过程中默认开启。
这篇博客会演示使用modules开发Go代码的一系列的常用操作：
创建一个模块 添加依赖 升级依赖 添加一个依赖的新主版本 升级一个依赖到新主版本 移除无用依赖 创建一个新的模块 让我门从创建一个新模块开始。
在$GOPATH/src外创建一个新的空文件夹，使用cd切换进入这个目录，然后创建一个名叫hello.go的新源码文件：
package hello func Hello() string { return &amp;#34;Hello, world.&amp;#34; } 让我们同样创建一个名叫hello_test.go的测试文件：
package hello import &amp;#34;testing&amp;#34; func TestHello(t *testing.T) { want := &amp;#34;Hello, world.&amp;#34; if got := Hello(); got != want { t.Errorf(&amp;#34;Hello() = %q, want %q&amp;#34;, got, want) } } 现在，这个目录包含了一个包，但是它并不是一个模块，因为还没有go.mod文件。如果你文件创建在 /home/gopher/hello目录下，执行go test命令时，我们可以看到结果：
$ go test PASS ok _/home/gopher/hello 0.</description></item><item><title>聊聊新的Go语言错误处理方案</title><link>https://www.4async.com/2019/01/2019-01-25-go-new-xerrors/</link><pubDate>Fri, 25 Jan 2019 23:20:00 +0000</pubDate><guid>https://www.4async.com/2019/01/2019-01-25-go-new-xerrors/</guid><description>今天早些时候，golang/x/exp中默默的更新了一个名曰xerrors的包，这个包和同样处于golang/x/exp下的另一个名叫errors的包名字十分相似，就连介绍也都一致：
Package errors implements functions to manipulate errors. This package implements the Go 2 draft designs for error inspection and printing 从目前的情况来看，基本上错误的处理形式基本已经定型，处理方式则是类似于之前的另一个github.com/pkg/errors包，但是具体细节不尽相同。
如何处理error？ 在之前介绍文章中提到过github.com/pkg/errors包的设计思路，那么在Go团队的实现中，这种思路也得到了继承。先从一个小例子开始：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;golang.org/x/exp/xerrors&amp;#34; ) func raiseError() error { return xerrors.New(&amp;#34;a new error&amp;#34;) } func main() { err := xerrors.Errorf(&amp;#34;raiseError: %w&amp;#34;, raiseError()) fmt.Println(err) } 输出结果：
raiseError: a new error 看起来非常类似于之前github.com/pkg/errors的显示内容。而其中xerrors.Errorf则充当了之前errors.Wrap的功能。 其中值得一提的是%w，这个用于包装错误，后续验证错误中也会用到其中的值。
同时，这个包中也包含了几个非常有用的辅助函数，分别是：验证错误类型方法Is、错误类型转换方法As、错误关系链解除方法Opaque和提取内层错误方法Unwrap。我们可以用一个简单的演示来说明这种关系：
var ( ErrBase = xerrors.New(&amp;#34;a new error&amp;#34;) ) func main() { err := xerrors.</description></item><item><title>gini：一个让你更方便使用Gin框架的库</title><link>https://www.4async.com/2019/01/2019-01-18-gin-toolkit-gini/</link><pubDate>Fri, 18 Jan 2019 23:20:00 +0000</pubDate><guid>https://www.4async.com/2019/01/2019-01-18-gin-toolkit-gini/</guid><description>&lt;p>&lt;a class="link" href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener"
>Gin框架&lt;/a>是一个Go语言框架中非常受欢迎的一款。今天我们开放了一个&lt;a class="link" href="https://github.com/ipfans/gini" target="_blank" rel="noopener"
>gini&lt;/a>库，结合了我们实际开发中的使用，描述一下我们为什么开发这个库，在开发过程中的权衡。&lt;/p></description></item><item><title>Go 1.10中的一处不兼容问题</title><link>https://www.4async.com/2018/06/2018-06-08-compatibility-in-golang-1-10/</link><pubDate>Fri, 08 Jun 2018 12:20:00 +0000</pubDate><guid>https://www.4async.com/2018/06/2018-06-08-compatibility-in-golang-1-10/</guid><description>&lt;p>最近我们在把线上系统升级至Go 1.10版本时发现，在我们实现的某些接口中，出现了客户反馈调用失败提示参数缺失的情况。这种情况我们在测试过程中未能复线，后来经过了解，发现了故障原因为Go 1.10版本升级过程中更改了部分程序代码与验证逻辑导致的。&lt;/p></description></item><item><title>关于Golang过滤敏感信息的正确姿势</title><link>https://www.4async.com/2018/06/2018-06-06-sensitive-info-filter-in-golang/</link><pubDate>Wed, 06 Jun 2018 16:07:00 +0000</pubDate><guid>https://www.4async.com/2018/06/2018-06-06-sensitive-info-filter-in-golang/</guid><description>&lt;p>今天正好看到一篇关于敏感信息过滤的&lt;a class="link" href="https://hackernoon.com/keep-passwords-and-secrets-out-of-your-logs-with-go-a2294a9546ce" target="_blank" rel="noopener"
>文章&lt;/a>，这算做一个interface实际应用的一些举例和应用。&lt;/p>
&lt;p>例子中介绍了一种比较常见的使用场景：使用JSON保存数据时的对诸如用户密码等信息进行保护时候应该做的事情。作者以使用JSON格式保存用户账户和密码为例，讲解了使用&lt;code>json.Unmarshaler&lt;/code>接口类型过滤敏感信息。&lt;/p></description></item><item><title>gRPC性能优化</title><link>https://www.4async.com/2018/04/2018-04-20-grpc-performance-optimizing/</link><pubDate>Fri, 20 Apr 2018 12:00:00 +0000</pubDate><guid>https://www.4async.com/2018/04/2018-04-20-grpc-performance-optimizing/</guid><description>背景介绍 我们在项目中逐渐切换使用了gRPC作为服务间调用的主要手段，逐步替换RESTful API在目前我们项目中的使用。在使用过程中，gRPC的效率是我们想对比较关心并且从目前来看相对难以优化的组件，所以本文就是探讨如何能够在不修改gRPC源码的前提下尽量提升gRPC的性能。
grpc官方提供了性能benchmark可以供大家查看，具体的链接可以在 gRPC Performance Dashboard 中查看。
性能测试 性能测试采用我们的线上标配，目前由于业务量原因，其实性能并不高，这里只是对比参考，建议你在后续处理过程中自行测试。其实最简单的处理方式就是创建多个gRPC client。
单Client处理：
➜ client ./client -n 100000 -c 1 2017/08/04 16:49:39 concurrency: 1 requests per client: 100000 2017/08/04 15:59:39 message size: 581 bytes 2017/08/04 16:00:04 took 24467 ms for 100000 requests 2017/08/04 16:00:04 sent requests : 100000 2017/08/04 16:00:04 received requests : 100000 2017/08/04 16:00:04 received requests_OK : 100000 2017/08/04 16:00:04 throughput (TPS) : 4087 2017/08/04 16:00:04 mean: 244283 ns, median: 241106 ns, max: 6107692 ns, min: 138633 ns, p99: 678374 ns 2017/08/04 16:00:04 mean: 0 ms, median: 0 ms, max: 6 ms, min: 0 ms, p99: 0 ms 修改Client数目为10：</description></item><item><title>gRPC 调用超时控制</title><link>https://www.4async.com/2017/04/2017-05-19-grpc-call-timeout/</link><pubDate>Thu, 06 Apr 2017 18:00:00 +0000</pubDate><guid>https://www.4async.com/2017/04/2017-05-19-grpc-call-timeout/</guid><description>我们在进行服务间调用时广泛采用 gRPC 作为主要的调用协议，借助 gRPC 的模块化与语言无关的特性，可以在我们拓展多语言模块之间提供更好的支持。但是我们在使用 gRPC 之中也出现了一些问题，这些问题会做一些记录，希望可以与大家一起沟通与交流。
某日，我们的客服反馈，我们的基础设施操作工具出现了长时间无响应的问题。该问题出现在我们对某些设备进行 OTA 升级时，操作长时间无返回，与之前预期的 10 秒内返回存在较大出入。经过我们的工程师分析，我们发现在 gRPC 处理过程中，我们的操作工具通过 gRPC 调用远程服务端接口时，接口长时间没有返回结果。
我们首先怀疑是 gRPC 调用过程中出现了连接问题。gRPC 过程中可能由于多种原因导致连接断开或者服务器无法连接。在调用 gRPC 方法过程中，我们可以通过 FailFast(true) 方式进行快速失败。实际上，这个值默认情况下为 true。
那么接下来我们就需要从调用从使用角度上寻找问题。我们使用过程中默许服务端在处理某些操作时进行较长时间操作（如长时间操作），但是从客户端角度而言，部分操作正常情况下我们是希望可以在有预定特定环境下达到某些时间仍旧未返回结果可以标记为结果失败。这样就需要通过 gRPC 的机制进行调控。由于目前我们的接口很多情况下调用接口实际为硬件接口，因此，我们采用通过控制 gRPC 客户端接口超时的方法控制。
在 gRPC 中，提供了 MethodConfig 用于控制每个方法的超时时间，这样可以对不同的 RPC 方法设置超时。
下面，我们用 官方的 gRPC 示例 演示如何进行调用超时控制。
首先，我们在 examples/helloworld/greeter_server/main.go 中的 SayHello 中添加一个长时间操作模拟：time.Sleep(10*time.Second)。
这时，如果我们需要客户端在 5 秒以内返回结果，应该如何操作呢？
那么我们修改 examples/helloworld/greeter_client/main.go 中的 main，添加超时处理内容：
func main() { // Set up method timeout configure. var wg sync.WaitGroup wg.Add(1) ch := make(chan grpc.</description></item><item><title>更优雅的 Golang 错误处理</title><link>https://www.4async.com/2017/02/2017-02-08-more-effective-golang-error/</link><pubDate>Wed, 08 Feb 2017 18:00:00 +0000</pubDate><guid>https://www.4async.com/2017/02/2017-02-08-more-effective-golang-error/</guid><description>Golang 中的错误处理是一个被大家经常拿出来讨论的 话题(另外一个是 泛型)。其中泛型这个问题，rsc 在最近的计划中也提出 了纳入他今年的考虑计划中，同时，泛型的提案 在 2016 年也进行了一些更新，相信未来会有一些更好的方案提出。这个文章我们讨论一下如何在现行的 Golang 框架下提供更友好和优雅的错误处理。
从现状谈起 Golang 中的错误处理原则，开发者曾经之前专门发布了几篇文章 (Error handling and Go 和 Defer, Panic, and Recover、Errors are values ) 介绍。分别介绍了 Golang 中处理一般预知到的错误与遇到崩溃时的错误处理机制。
一般情况下，我们还是以官方博客中的错误处理例子为例：
func main() {f, err := os.Open(&amp;#34;filename.ext&amp;#34;) if err != nil {log.Fatal(err) // 或者更简单的： // return err } ... } 当然对于简化代码行数，还有另外一种写法：
func main() { ... if f, err = os.Open(&amp;#34;filename.ext&amp;#34;); err != nil{log.Fatal(err) } ... } 正常情况下，Golang 现有的哲学中，要求你尽量手工处理所有的错误返回，这稍微增加了开发人员的心智负担。关于这部分设计的讨论，请参考本文最开始提供的参考链接，此处不做太多探讨。
本质上，Golang 中的错误类型 error 是一个接口类型：</description></item><item><title>Docker for Mac 尝鲜</title><link>https://www.4async.com/2016/04/2016-04-26-docker-for-mac-beta/</link><pubDate>Tue, 26 Apr 2016 18:00:00 +0000</pubDate><guid>https://www.4async.com/2016/04/2016-04-26-docker-for-mac-beta/</guid><description>之前作为 Docker beta 的第一批用户获得了 beta 的授权，但是因为邮件进了垃圾邮件，所以一直没有发现。今天给 Docker 发邮件申请 beta 测试才知道已经通过了，赶紧尝鲜起来。如果你没有权限，可以尝试到 Docker Beta 申请测试资格。
测试版本可能存在风险，请自行判断。
安装之前 Docker for Mac 需要一些前置要求，官方文档提供的数据如下：
2010 年之后的 Intel Mac 机型，支持 MMU(Memory Management Unit) 虚拟化、EPT(Extended Page Table) 等特性 OSX 10.10.3 以上系统 至少 4GB 内存 VirtualBox 4.x 与 Docker for Mac 冲突，因此如果你安装这个系列的 Virtualbox 需要卸载。 如果之前装过 Docker Toolbox 的话，需要一些额外的操作去与 Docker Toolbox 兼容。（我选择了直接卸载现有的 Docker Toolbox。XD ）
安装 Docker for Mac Docker for Mac 是一个 98.3M(Mac 显示为 103.1MB) 的 DMG 文件，下载下来之后双击文件，将鲸鱼拖拽到 Applications 文件夹中即可。</description></item><item><title>编写测试友好的 Golang 代码</title><link>https://www.4async.com/2016/04/2016-04-18-writing-testable-golang-code/</link><pubDate>Mon, 18 Apr 2016 18:40:00 +0000</pubDate><guid>https://www.4async.com/2016/04/2016-04-18-writing-testable-golang-code/</guid><description>目前我们有大量的应用采用了 Golang 程序进行构建，但是在执行研发流程里我们会发现一些来自于静态编译程序的不便：相对于我们之前使用的 Python 语言程序而言，我们无法在程序功能的单元测试里大量的使用 Mock 方式来进行高效测试。
而这些东西往往可以在开发人员编写单元测试用例时有效的节省时间和一些额外的环境准备成本。因此，这也给我们的程序的单元覆盖率带来了很多麻烦的地方：一些依赖于额外验证和表现的情况或者小几率出现的情况需要复杂的模拟步骤，对开发进度和效率带来了一些额外的影响。如何编写一个测试友好的 Golang 程序成为一个无法绕开的问题。
从动态语言到静态语言 动态语言有良好的运行时修改属性，在运行时的动态修改函数，可以进行有效的 Mock。比如在 Python（以 3 为例，内置了 unittest.mock 标准库）程序中:
with patch.object(ProductionClass,&amp;#39;method&amp;#39;, return_value=None) as mock_method: thing = ProductionClass() thing.method(1, 2, 3) 自然而然的，我们想到了这样的用法：
var imp = func() bool {return true} func TestFunc(t *testing.T) {defer func(org func() bool) {imp = org}(imp) img = func() bool {return false} // testing or something else... } 这样实现 Mock 是完全可以的，但是实际上会带来一些额外的问题，比如说在 MVC 框架中，我们正常采用的方式一般是这样的：
import (&amp;#34;models&amp;#34; ... ) func A(ctx Context) error { .</description></item><item><title>Mgo 库的常见坑总结</title><link>https://www.4async.com/2016/01/2016-01-26-something-about-mgo-driver/</link><pubDate>Tue, 26 Jan 2016 21:30:00 +0000</pubDate><guid>https://www.4async.com/2016/01/2016-01-26-something-about-mgo-driver/</guid><description>mgo 库 是一个很好用的 MongoDB 驱动。对我们来说，主力数据库是 MongoDB，因此这个驱动对我们来说也是非常重要的。但是，mgo 库有些问题算是一些坑，这里我做了一些简单的整理。
一些关于 bson.ObjectId 的问题 ObjectId 为空的判断 如果你看 bson.ObjectId 定义的话，它是一个 string 类型的数据。但是如果你直接定义一个结构，并且生成对象时，这个对象并不是这样的。
我们首先定义一个结构体：
type Home struct {ID bson.ObjectId `bson:&amp;#34;_id,omitempty&amp;#34;` Name string `bson:&amp;#34;name&amp;#34;` } 然后看看一个生成的内容
h := Home{Name:&amp;#34;123&amp;#34;} fmt.Println(h.ID) 结果是 ObjectIdHex(&amp;quot;&amp;quot;)。换句话说，如果你是想判断一个结构体的 ObjectId 是否为空，使用 h.ID ==&amp;quot;&amp;quot; 是一定会结果为 false 的。如果你想判断是否为空，正确的方式应该为：
h := Home{Name:&amp;#34;123&amp;#34;} fmt.Println(h.ID) fmt.Println(h.ID.Hex() == &amp;#34;&amp;#34;) 正确的生成 ObjectId 首先值得注意的是 NewObjectIdWithTime(t time.Time) 这个方法生成的 ObjectId 并不是唯一的，结果可能导致的是插入失败。最有效的方式是设定 ObjectId 对象支持 omitempty 属性，就像我上面生成的结构体一样，由数据库统一调配生成 ObjectId。如果真的确实需要，可以选择 NewObjctId()。
时间问题 之前看到有人问，为什么保存的时间进入到数据库中慢了 8 个小时呢？原因是在保存进入 MongoDB 时，数据是按照 UTC 时间（不懂什么是 UTC？看这里）进行的保存，但是取出是按照当前时区来取出。那么问题来了，我的客户如果不都是国人，我怎么保存时间呢？目前我们采用了两种方式来确定数据库的保存时间。一种是 Unix 时间戳 ，这个是不受到时区的影响的，由前端格式化为对应的时区时间；另外一种则是需要在额外的对从 MongoDB 数据库中取出的数据进行额外的时区校准，简单来说可以这样：</description></item><item><title>使用 vendor 管理 Golang 项目依赖</title><link>https://www.4async.com/2016/01/2016-01-05-golang-vendor/</link><pubDate>Tue, 05 Jan 2016 23:13:00 +0000</pubDate><guid>https://www.4async.com/2016/01/2016-01-05-golang-vendor/</guid><description>我们在项目中除了 大量的使用 Python 外，也大量的使用了 Golang 构建高效基础运行服务。在使用 Golang 过程中，我们发现 Golang 程序缺少依赖库版本功能是一个非常令人头大的问题：某些依赖在某个 commit 之后发生了 API 变更之后，如果不修改代码很难兼容，然而开发者之间很有可能因为参与的时间不同，导致执行 go get 命令获取的版本不同，而导致在不同电脑上出现编译不通过问题。同时，在多个程序中，如果使用的 commit 版本不同，也可能会导致程序编译过程中出现不同的问题。
在之前，我们解决这个问题有两个方案，一种是拆解 go get 命令的执行，首先创建对应依赖目录，利用 git 命令切换至指定的 commit，然后执行 go install 命令。另外一种比较省事的方法是使用 godep 工具，这里就不做过多介绍了，具体可以参考文档或者搜索中文教程。
在 Golang1.5 之后，Go 提供了 GO15VENDOREXPERIMENT 环境变量，用于将 go build 时的应用路径搜索调整成为 当前项目目录 / vendor 目录方式。通过这种形式，我们可以实现类似于 godep 方式的项目依赖管理。不过起码在程序编译过程中，再也无需在其他端部署一个 godep 工具。
在使用之前，需要安装一个辅助工具（如果 Golang 自改一个就好了）：go get -u -v github.com/kardianos/govendor。
下面，我们用一个例子来说明。首先有一个名为 vendorproj 的项目。假如只有一个文件：
package main import (&amp;#34;github.com/yeeuu/echoic&amp;#34;) func main() {e := echoic.New() e.SetDebug(true) e.Run(&amp;#34;127.0.0.1:4321&amp;#34;) } 执行一下命令就可以生成 vendor 文件夹：</description></item></channel></rss>