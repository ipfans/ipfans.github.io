<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on ipfans's Blog</title><link>https://www.4async.com/categories/python/</link><description>Recent content in Python on ipfans's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 29 Jan 2019 14:30:00 +0000</lastBuildDate><atom:link href="https://www.4async.com/categories/python/atom.xml" rel="self" type="application/rss+xml"/><item><title>利用Stub File标注Python文件</title><link>https://www.4async.com/2019/01/2019-01-28-python-typing-with-stub-files/</link><pubDate>Tue, 29 Jan 2019 14:30:00 +0000</pubDate><guid>https://www.4async.com/2019/01/2019-01-28-python-typing-with-stub-files/</guid><description>&lt;p>在升级到&lt;code>Python 3.5+&lt;/code>版本之后，最大的项目管理优化来自于&lt;a class="link" href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="noopener"
>&lt;code>PEP-484 Type Hint&lt;/code>&lt;/a>的引入。借助&lt;code>Type Hint&lt;/code>，我们可以进一步提升&lt;code>Python&lt;/code>代码的类型标注，保障在重构过程中避免出现一些低级失误。&lt;/p>
&lt;p>我们可以通过高版本&lt;code>Python&lt;/code>新加的新语法启用这项特性，然后通过&lt;code>mypy&lt;/code>等工具检查：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">greeting&lt;/span>(name: str) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> str:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Hello &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> name
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然而，在实际实践过程中，也往往存在一些问题，这些问题来自于很多方面：&lt;/p></description></item><item><title>OSX 下安装 face_recognition</title><link>https://www.4async.com/2017/08/2017-08-02-install-face-recognition-on-osx/</link><pubDate>Wed, 02 Aug 2017 18:30:00 +0000</pubDate><guid>https://www.4async.com/2017/08/2017-08-02-install-face-recognition-on-osx/</guid><description>face_recognition 是一个热门的人脸识别库，常年占据 Github Trending Python 子类的 Top10。
在官方文档中，介绍安装 face_recognition 步骤非常简单，只需要执行 pip install face_recognition 就可以了，实际在安装过程中 face_recognition 有一些非 Python 依赖，需要单独安装，本文就对内容进行一个简单介绍，权作记录，方便大家手动安装时提前规避。文章基于 OSX 10.12.6+pyenv+python3.6.2 介绍。
问题在哪里？ face_recognition 的依赖大部分都比较好安装，只有一个库例外，那就是 dlib 这个依赖。这个依赖需要安装 boost 和 boost-python 两个非 Python 依赖。
安装 Boost 和 boost-python 这两个库可以通过 Homebrew 快速安装，使用如下命令进行安装：
brew install boost brew install boost-python --with-python3 需要注意的是，如果是 Python3 使用，需要额外参数，使用源码编译安装。如果使用 Python2 可以使用 Homebrew 的预编译包。
确认 Python dlib 要求 Python 编译时使用 --enable-shared 参数编译，默认情况下，pyenv 未启用该参数，因此编译需要使用下面参数进行 Python 重新编译
PYTHON_CONFIGURE_OPTS=&amp;#34;--with-dtrace --enable-shared&amp;#34; pyenv install 3.6.2 前面一个参数是我一直编译 Python 3.</description></item><item><title>使用 Python 和 Pandas 分析 Pronto CycleShare 数据</title><link>https://www.4async.com/2017/02/2017-02-19-analyzing-pronto-cycleshare-data-with-python-and-pandas/</link><pubDate>Sun, 19 Feb 2017 18:00:00 +0000</pubDate><guid>https://www.4async.com/2017/02/2017-02-19-analyzing-pronto-cycleshare-data-with-python-and-pandas/</guid><description>这是一篇非常不错的 pandas 分析入门文章，在此简单翻译摘录如下。
本周，西雅图的自行车共享系统 Pronto CycleShare 一周岁了。 为了庆祝这一点，Pronto 提供了从第一年的数据缓存，并宣布了 Pronto Cycle Share 的数据分析挑战。
你可以用很多工具分析这些数据，但我的选择工具是 Python。 在这篇文章中，我想展示如何开始分析这些数据，并使用 PyData 技术栈，即 NumPy，Pandas，Matplotlib 和 Seaborn 与其他可用的数据源。
这篇文章以 Jupyter Notebook 形式组织，它是一种开放的文档格式。结合了文本、代码、数据和图形，并且通过 Web 浏览器查看。本文中的内容可以下载 对应的 Notebook 文件，并通过 Jupyter 打开。
下载 Pronto 的数据 我们可以从 Pronto 官网 下载对应的 数据文件。总下载大约 70MB，解压缩的文件大约 900MB。
接下来我们需要导入一些 Python 包：
In [2]:
%matplotlib inline import matplotlib.pyplot as plt import pandas as pd import numpy as np import seaborn as sns; sns.set() 现在我们使用 Pandas 加载所有的行程记录：</description></item><item><title>使用 dtrace 跟踪 Python 应用</title><link>https://www.4async.com/2016/09/2016-09-15-tracing-python-program-with-dtrace/</link><pubDate>Thu, 15 Sep 2016 18:00:00 +0000</pubDate><guid>https://www.4async.com/2016/09/2016-09-15-tracing-python-program-with-dtrace/</guid><description>今年在 Pycon China 上，来自饿了么的郭浩川分享了 利用 systemtap 进行 Python 执行情况分析 的内容。分享利用 systemtap 在线上环境中实时监控 gevent patch 的 green thread 程序的执行状况。
dtrace 和 systemtap 均支持在 Linux 上进行分析，在 macOS 系统上则只有 dtrace 使用。在 Python3.5 和之前版本中，需要使用手工 Patch 的方式进行埋点监控。在 Python 3.6 以上中 dtrace 和 systemtap 埋点支持功能可以通过编译参数 &amp;ndash;with-dtrace 开启。
从 dtrace 开始 dtrace 是一个低开销的成本动态跟踪工具，可以通过埋点 probs 方式监控各项程序运行状态。dtrace 最初内置在 Solaris 系统中，因此我们可以借助 Solaris 系统的相关文档了解 dtrace 的基本操作。DTrace 用户指南 是 Oracle 提供的基于 Solaris 系统的 dtrace 操作手册，操作基本与其它系统相同，推荐在最初开始阶段阅读该使用手册。
在 macOS 上，已经很多系统底层功能和 framework 中已经集成了 dtrace 的功能。</description></item><item><title>利用 Type Hint 提升 Python 程序开发效率</title><link>https://www.4async.com/2016/07/2016-07-13-type-hint-improve-python-programming/</link><pubDate>Wed, 13 Jul 2016 20:00:00 +0000</pubDate><guid>https://www.4async.com/2016/07/2016-07-13-type-hint-improve-python-programming/</guid><description>Type Hint（或者叫做 PEP-484）提供了一种针对 Python 程序的类型标注标准。
为什么使用 Type Hint？对于动态语言而言，常常出现的情况是当你写了一段代码后，隔段时间你可能忘记这个方法的原型是什么样子的了，你也不清楚具体应该传入什么类型的参数，这样往往需要你去阅读代码才能定义每个类型具体是什么。或者当你使用一个文档并不是特别完全的第三方库，你不知道这个库应该如何使用，这都会很痛苦。
现在，借助 Type Hint，你可以实现：
实现类型检查，防止运行时出现的类型不符合情况。 作为文档附加属性，方便开发者调用时传入传出的参数类型。 提升 IDE 的检查机制，在智能提示时更快给出提示和类型检查结果。 实现这个过程中，你需要使用 Python 3.5+ 中提供的新模块 typing。值得注意的是，这个改动并不会影响程序运行，仅仅是为了方便类型检查器实现的。
Type Hint 类型检查器 目前，比如 JetBrains 家的 PyCharm 已经支持 Type Hint 语法检查功能，如果你使用了这个 IDE，可以通过 IDE 功能进行实现。如果你像我一样，使用了 SublimeText 编辑器，那么第三方工具 mypy 可以帮助到你。AnacondaST3 最近要发布的 2.0 版本也内置了 mypy 功能的支持，具体的进度可以看一下 这个 issue。一些其它的 Python 工具 (比如 代码提示工具 jedi 0.10+) 也支持了 Type Hint 功能。
从简单的例子开始 从简单的例子开始，我们先从一个简单的程序开始，运行环境为 Python 3.5.2，使用 mypy 工具进行检查。
首先通过 pip install mypy-lang 命令安装 mypy 工具。注意是 mypy-lang，之所以是这样，是因为在 pypi 里 mypy 这个名字已经被占用掉了。</description></item><item><title>从 asyncio 简单实现看异步是如何工作的</title><link>https://www.4async.com/2016/02/2016-02-03-simple-implement-asyncio-to-understand-how-async-works/</link><pubDate>Wed, 03 Feb 2016 15:40:00 +0000</pubDate><guid>https://www.4async.com/2016/02/2016-02-03-simple-implement-asyncio-to-understand-how-async-works/</guid><description>从 asyncio 简单实现看异步是如何工作的
by ipfans
注：请使用 Python 3.5+ 版本运行以下代码。
先从例子看起 首先我们来看一个 socket 通讯的例子，这个例子我们可以在官方 socket 模块的文档中找到部分原型代码：
# echo.py from socket import * # 是的，这是一个不好的写法 def echo_server(address): sock = socket(AF_INET, SOCK_STREAM) sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) sock.bind(address) sock.listen(5) while True: client, addr = sock.accept() print(&amp;#34;connect from&amp;#34;, addr) echo_handler(client) def echo_handler(client): while True: data = client.recv(10000) if not data: break client.</description></item></channel></rss>