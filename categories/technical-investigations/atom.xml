<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Technical Investigations on ipfans's Blog</title><link>https://www.4async.com/categories/technical-investigations/</link><description>Recent content in Technical Investigations on ipfans's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 15 May 2021 18:38:00 +0000</lastBuildDate><atom:link href="https://www.4async.com/categories/technical-investigations/atom.xml" rel="self" type="application/rss+xml"/><item><title>构建属于你自己的dapr绑定组件</title><link>https://www.4async.com/2021/05/building-your-own-dapr-binding/</link><pubDate>Sat, 15 May 2021 18:38:00 +0000</pubDate><guid>https://www.4async.com/2021/05/building-your-own-dapr-binding/</guid><description>在上一篇文章中，吐槽了拖延症的危害，因此这次我来分享一下我最新推送到dapr的最新的一个新的绑定组件，通过这个来看一下如何实现自己的绑定组件。
文中提到的PR可以在 dapr/components-contrib#872 查看对应的具体代码。
什么是 dapr 的绑定组件？ 在dapr中，绑定是用于使用外部系统功能（比如事件或者接口）的扩展组件。它的优势在于：
免除连接到消息传递系统(如队列和消息总线)并进行轮询的复杂性； 聚焦于业务逻辑，而不是如何与系统交互的实现细节； 使代码不受 SDK 或库的跟踪； 处理重试和故障恢复； 在运行时在绑定之间切换； 构建具有特定于环境的绑定的可移植应用程序，不需要进行代码更改； 在官方文档中，也提到了一个具体的例子：以twilio发送短信为例，一般开发过程中应用程序需要依赖Twilio SDK才可以实现功能，但是借助绑定组件，你可以将SDK的绑定转移至dapr程序领域内，在本身应用程序中不再绑定对应的SDK，不用担心未来SDK过期或者变更带来的重复工作（仅需要更新dapr即可）。
根据订阅的进出方向，绑定组件也分为输入绑定和输出绑定。这些绑定均是通过yaml文件描述类型和元数据，通过HTTP/gRPC进行调用。
如何实现自己的绑定组件？ 官方例子中提供了一个基础的介绍，上一节中我们也提到了在程序中，根据进出方向可以把绑定组件分为输出绑定和输入绑定。你可以通过官方教程中的例子提供查看：
在这个例子用，你可以看到，根据方向吧dapr发布消息到Kafka作为输出组件，把Kafka读取消息到dapr作为输入组件。
绑定的声明yaml文件的规范则如下：
apiVersion: dapr.io/v1alpha1 kind: Component metadata: name: &amp;lt;NAME&amp;gt; namespace: &amp;lt;NAMESPACE&amp;gt; spec: type: bindings.&amp;lt;TYPE&amp;gt; version: v1 metadata: - name: &amp;lt;NAME&amp;gt; value: &amp;lt;VALUE&amp;gt; 其中metadata.name则是绑定置名称，spec.metadata.name和spec.metadata.value则是配置的属性和对应值。这个值我们可以通过实现接口InputBinding或者OutputBinding实现输入绑定和输出绑定.
type InputBinding interface { Init(metadata Metadata) error Read(handler func(*ReadResponse) ([]byte, error)) error } type OutputBinding interface { Init(metadata Metadata) error Invoke(req *InvokeRequest) (*InvokeResponse, error) Operations() []OperationKind } 接下来需要实现一个生成对象的方法，比如说我们需要实现一个飞书推送Webhook的绑定组件，则可以：</description></item><item><title>构建属于你自己的dapr服务发现</title><link>https://www.4async.com/2021/05/building-your-own-dapr-service-discovery/</link><pubDate>Sat, 08 May 2021 18:38:00 +0000</pubDate><guid>https://www.4async.com/2021/05/building-your-own-dapr-service-discovery/</guid><description>写在最前: 这篇文章其实算是马后炮了，因为一直拖延症的问题，顺带过了一个五一假期，结果发现已经有社区贡献者提供了Consul的服务发现实现，于是本来写了一半的文章只能进行调整了。拖延症害人啊！几个草稿的文章看来要尽快赶出来了🤦‍♂️
在上一篇文章中，我其实遗留了一个问题：如何定义dapr的服务发现呢？其实在后面阅读dapr的源码之后也前一篇文章的评论中提到了答案：目前dapr提供了内置两种服务发现模式：K8s模式和用于独立部署的mDNS模式。mDNS模式在某些网络环境下可能存在问题（比如跨机房），不过没有关系，dapr同时提供了可扩展能力，可以通过定义自主的服务发现能力扩展dapr的边界。
从 NameResolution 到 Resolver 接口 在 pkg/components/nameresolution/registry.go 文件中，dapr定义了一个 NameResolution 结构体用于服务注册和发现：
type ( // NameResolution is a name resolution component definition. NameResolution struct { Name string FactoryMethod func() nr.Resolver } // Registry handles registering and creating name resolution components. Registry interface { Register(components ...NameResolution) Create(name, version string) (nr.Resolver, error) } nameResolutionRegistry struct { resolvers map[string]func() nr.Resolver } ) 其中真正的服务解析则是依靠 components-contrib 中实现了 Resolver 接口的具体实现执行。
// Resolver is the interface of name resolver.</description></item><item><title>在非容器(集群)环境下运行dapr</title><link>https://www.4async.com/2021/03/2021-03-11-running-dapr-without-container/</link><pubDate>Thu, 11 Mar 2021 18:38:00 +0000</pubDate><guid>https://www.4async.com/2021/03/2021-03-11-running-dapr-without-container/</guid><description>前一段时间一直关注的dapr正式发布了v1.0版本(实际上本文发布时还更新了v1.0.1)，代表dapr在某些程度上进入稳定状态，可以尝试在实际中进行运用。作为我一直关注的项目，在第一时间中进行了尝试，并试图引入实际项目中，本文则是针对这些的一些先期测试内容.
什么是dapr？ dapr最早是由微软开源的(不愧是你)，一个可移植的、事件驱动的程序运行时，它使任何开发者都能轻松地构建运行在云和边缘的弹性、无状态/有状态的应用程序，并且可以灵活支持多种开发语言。换而言之，在我看来，dapr可以作为一个serverless落地方案看待和处理，对程序而言，只关注提供的store和消息队列接口，无需关心架构层面更多内容。
不过在官方的示例教程中，使用的环境为容器环境部署和管理dapr。实际上，除了在容器环境或者容器集群环境下，dapr可以配置为在本地机器上以自托管模式运行。
本地安装 dapr安装可以通过官方的dapr-cli实现，dapr-cli可以通过一键安装命令快速安装：
# wget -q https://raw.githubusercontent.com/dapr/cli/master/install/install.sh -O - | /bin/bash Your system is linux_amd64 Dapr CLI is detected: main: line 86: 43656 Segmentation fault $DAPR_CLI_FILE --version Reinstalling Dapr CLI - /usr/local/bin/dapr... Getting the latest Dapr CLI... Installing v1.0.0 Dapr CLI... Downloading https://github.com/dapr/cli/releases/download/v1.0.0/dapr_linux_amd64.tar.gz ... dapr installed into /usr/local/bin successfully. CLI version: 1.0.0 Runtime version: n/a To get started with Dapr, please visit https://docs.dapr.io/getting-started/ 可以通过输入dapr命令确认dapr-cli程序是否被正常安装成功。
接下来使用dapr-cli安装所有的runtime等应用。
# dapr init --slim ⌛ Making the jump to hyperspace.</description></item><item><title>NATS-Server(JetStream)和NATS Streaming Server对比</title><link>https://www.4async.com/2021/03/2021-03-02-nats-server-usage/</link><pubDate>Tue, 02 Mar 2021 18:38:00 +0000</pubDate><guid>https://www.4async.com/2021/03/2021-03-02-nats-server-usage/</guid><description>在我吐槽了无数次之后，NATS JetStream终于结束了beta阶段正式进入RC阶段。终于官方也在最近刚刚正式回复了我正式版本在处理几个问题之后就会正式发布。那么在这个比较重要的NATS-Server特性发布之际聊一下NATS产品本身区别和新特性的使用，还有更多的潜在的区别。
概念区分：NATS-Server / NATS Streaming Server / NATS JetStream NATS-Server NATS-Server（或者叫nats）是一个开源的、云原生的、高性能的消息传递系统，是NATS的最基础的产品。它的核心是一个发布/订阅（Pub/Sub）系统，客户端可以在不同集群中的服务间nats进行通讯，而不需要关注具体的消息在哪个服务上。换而言之，客户端可以在任意一个集群的服务端上发布消息，同时在任意集群客户端上尝试读取消息。在官方与其他同类消息队列产品功能对比中，我们也可以管窥一下产品的功能列表。nats支持多流多服务进行pub/sub，负载均衡，保障消息最多/最少一次送达，多租户和用户认证等功能。虽然看上去优点很多，但是nats不是一个应用很广的消息队列的重要原因是，它缺少了一些对消息队列而言很最重要的产品特性，比如持久化支持，比如消息确保一次送达。这意味着当你的消息发送出去之后，你的消息是在处理过程中可能丢失的，甚至是可能送达不到的。
NATS Streaming Server NATS Streaming Server（或者叫stan）是用于尝试解决上面提到的nats的已存在问题的。stan添加了持久化功能和消息送达策略支持。stan中自带了nats服务端，但是在使用过程中，nats和stan不能进行混用。在官方文档中，是这么描述stan和nats之间的关系的：
NATS客户端和NATS Streaming Server客户端之间不能相互交换数据。也就是说，如果一个NATS Streaming Server客户端在foo上发布消息，在同一主题上订阅的NATS客户端将不会收到消息。NATS Streaming Server消息是由protobuf组成的NATS消息。NATS Streaming Server要向生产者发送ACK，并接收消费者的ACK。如果与NATS客户端自由交换消息，就会引起问题。
stan的具体架构如下图：
但是stan虽然提供了持久化和消息传递策略支持，但是在架构设计上却出现了问题，导致在最开始设计时遗留了很多问题，比如当你确定stan集群是固定的不能无限制水平扩容(#999)，比如不支持多租户功能(#1122)，比如客户端无法主动拉取消息只能被推送等等
NATS JetStream NATS JetStream（或者叫JetStream）是NATS基于Raft算法实现的最新的架构设计尝试解决上述问题的新方案。在区别于原有的stan功能上，提供了新的持久化功能和消息送达策略，同时支持水平扩容。同时，新的JetStream也为大消息做了一些优化，不再将这特性功能作为nats的客户端存在而是嵌入NATS Server中作为其中的一个功能存在。也就是说，如果在对这几项技术进行选择时，JetStream应该是最应该被选择的方案。更多详细情况具体可以查看官方的指导文档。
NATS JetStream使用 理论介绍过了，接下来说说实际使用的事情。现在JetStream还是RC阶段，
编译和启动客户端 下载nats-server源码，解压之后执行：
cd nats-server-master go build -o nats-server -ldflags=&amp;quot;-s -w -buildid=&amp;quot; . ./nats-server -js 这样就可以启动一个支持JetStream功能的服务端了。
[54738] 2021/03/02 18:27:02.605197 [INF] Starting nats-server [54738] 2021/03/02 18:27:02.605236 [INF] Version: 2.2.0-RC.2 [54738] 2021/03/02 18:27:02.605238 [INF] Git: [not set] [54738] 2021/03/02 18:27:02.</description></item><item><title>OpenTelemetry入门</title><link>https://www.4async.com/2020/03/2020-03-31-intro-opentelemetry/</link><pubDate>Tue, 31 Mar 2020 11:10:00 +0000</pubDate><guid>https://www.4async.com/2020/03/2020-03-31-intro-opentelemetry/</guid><description>&lt;p>今天早些时候，&lt;a class="link" href="https://opentelemetry.io/" target="_blank" rel="noopener"
>OpenTelemetry&lt;/a>正式&lt;a class="link" href="https://medium.com/opentelemetry/opentelemetry-is-officially-in-beta-352fa859db10" target="_blank" rel="noopener"
>进入Beta版本阶段&lt;/a>，这标志着OpenTelemetry的基本模型已经正式确定，可以开始将OpenTelemetry集成到应用程序和客户端库中，以捕获应用程序级指标和分布式跟踪。&lt;/p></description></item><item><title>利用Stub File标注Python文件</title><link>https://www.4async.com/2019/01/2019-01-28-python-typing-with-stub-files/</link><pubDate>Tue, 29 Jan 2019 14:30:00 +0000</pubDate><guid>https://www.4async.com/2019/01/2019-01-28-python-typing-with-stub-files/</guid><description>&lt;p>在升级到&lt;code>Python 3.5+&lt;/code>版本之后，最大的项目管理优化来自于&lt;a class="link" href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="noopener"
>&lt;code>PEP-484 Type Hint&lt;/code>&lt;/a>的引入。借助&lt;code>Type Hint&lt;/code>，我们可以进一步提升&lt;code>Python&lt;/code>代码的类型标注，保障在重构过程中避免出现一些低级失误。&lt;/p>
&lt;p>我们可以通过高版本&lt;code>Python&lt;/code>新加的新语法启用这项特性，然后通过&lt;code>mypy&lt;/code>等工具检查：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">greeting&lt;/span>(name: str) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> str:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Hello &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> name
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然而，在实际实践过程中，也往往存在一些问题，这些问题来自于很多方面：&lt;/p></description></item><item><title>聊聊新的Go语言错误处理方案</title><link>https://www.4async.com/2019/01/2019-01-25-go-new-xerrors/</link><pubDate>Fri, 25 Jan 2019 23:20:00 +0000</pubDate><guid>https://www.4async.com/2019/01/2019-01-25-go-new-xerrors/</guid><description>今天早些时候，golang/x/exp中默默的更新了一个名曰xerrors的包，这个包和同样处于golang/x/exp下的另一个名叫errors的包名字十分相似，就连介绍也都一致：
Package errors implements functions to manipulate errors. This package implements the Go 2 draft designs for error inspection and printing 从目前的情况来看，基本上错误的处理形式基本已经定型，处理方式则是类似于之前的另一个github.com/pkg/errors包，但是具体细节不尽相同。
如何处理error？ 在之前介绍文章中提到过github.com/pkg/errors包的设计思路，那么在Go团队的实现中，这种思路也得到了继承。先从一个小例子开始：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;golang.org/x/exp/xerrors&amp;#34; ) func raiseError() error { return xerrors.New(&amp;#34;a new error&amp;#34;) } func main() { err := xerrors.Errorf(&amp;#34;raiseError: %w&amp;#34;, raiseError()) fmt.Println(err) } 输出结果：
raiseError: a new error 看起来非常类似于之前github.com/pkg/errors的显示内容。而其中xerrors.Errorf则充当了之前errors.Wrap的功能。 其中值得一提的是%w，这个用于包装错误，后续验证错误中也会用到其中的值。
同时，这个包中也包含了几个非常有用的辅助函数，分别是：验证错误类型方法Is、错误类型转换方法As、错误关系链解除方法Opaque和提取内层错误方法Unwrap。我们可以用一个简单的演示来说明这种关系：
var ( ErrBase = xerrors.New(&amp;#34;a new error&amp;#34;) ) func main() { err := xerrors.</description></item></channel></rss>