<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ipfans's Blog" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://www.4async.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ipfans&#39;s Blog">
<meta property="og:url" content="https://www.4async.com/page/3/index.html">
<meta property="og:site_name" content="ipfans&#39;s Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ipfans&#39;s Blog">

<link rel="canonical" href="https://www.4async.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ipfans's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b9862358b198078f40d7e1596b7c5968";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ipfans's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2017/02/2017-02-08-more-effective-golang-error/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/2017-02-08-more-effective-golang-error/" class="post-title-link" itemprop="url">更优雅的 Golang 错误处理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-02-08 18:00:00" itemprop="dateCreated datePublished" datetime="2017-02-08T18:00:00+08:00">2017-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/02/2017-02-08-more-effective-golang-error/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/02/2017-02-08-more-effective-golang-error/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Golang 中的错误处理是一个被大家经常拿出来讨论的 <a href="http://www.infoq.com/cn/news/2012/11/go-error-handle" target="_blank" rel="noopener">话题</a>(另外一个是 <a href="http://www.weibo.com/1609119537/CdzJVejwg?type=comment" target="_blank" rel="noopener">泛型</a>)。其中泛型这个问题，rsc 在最近的计划中也<a href="https://mp.weixin.qq.com/s?__biz=MjM5OTcxMzE0MQ==&mid=2653369836&idx=1&sn=ddff3df7dbf52bb5bcc8b0ace78e0121&chksm=bce4d5f68b935ce0ece41ada8a49bbd33b638d184901ca8a61b5288daaf7c5a2d63af0cc3b34" target="_blank" rel="noopener">提出</a> 了纳入他今年的考虑计划中，同时，<a href="https://github.com/golang/proposal/blob/master/design/15292-generics.md" target="_blank" rel="noopener">泛型的提案</a> 在 2016 年也进行了一些更新，相信未来会有一些更好的方案提出。这个文章我们讨论一下如何在现行的 Golang 框架下提供更友好和优雅的错误处理。</p>
<h2 id="从现状谈起"><a href="#从现状谈起" class="headerlink" title="从现状谈起"></a>从现状谈起</h2><p>Golang 中的错误处理原则，开发者曾经之前专门发布了几篇文章 (<a href="https://blog.golang.org/error-handling-and-go" target="_blank" rel="noopener">Error handling and Go</a> 和 <a href="https://blog.golang.org/defer-panic-and-recover" target="_blank" rel="noopener">Defer, Panic, and Recover</a>、<a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">Errors are values</a> ) 介绍。分别介绍了 Golang 中处理一般预知到的错误与遇到崩溃时的错误处理机制。</p>
<p>一般情况下，我们还是以官方博客中的错误处理例子为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;f, err := os.Open(<span class="string">"filename.ext"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;log.Fatal(err)</span><br><span class="line">        <span class="comment">// 或者更简单的：</span></span><br><span class="line">        <span class="comment">// return err</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然对于简化代码行数，还有另外一种写法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">if</span> f, err = os.Open(<span class="string">"filename.ext"</span>); err != <span class="literal">nil</span>&#123;log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，Golang 现有的哲学中，要求你尽量手工处理所有的错误返回，这稍微增加了开发人员的心智负担。关于这部分设计的讨论，请参考本文最开始提供的参考链接，此处不做太多探讨。</p>
<p>本质上，Golang 中的错误类型 <code>error</code> 是一个接口类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要满足这一接口定义的所有数值都可以传入 <code>error</code> 类型的位置。在 <a href="http://go-proverbs.github.io/" target="_blank" rel="noopener">Go Proverbs</a> 中也提到了关于错误的描述： <figure class="highlight plain"><figcaption><span>are values```。这一句如何理解呢？</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Errors are values</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">事实上，在实际使用过程中，你可能也发现了对 Golang 而言，所有的信息是非常不足的。比如下面这个例子：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">buf := make([]byte, 100)</span><br><span class="line">n, err := r.Read(buf)</span><br><span class="line">buf = buf[:n]</span><br><span class="line">if err == io.EOF &#123;log.Fatal(&quot;read failed:&quot;, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>事实上这只会打印信息 <code>2017/02/08 13:53:54 read failed:EOF</code>，这对我们真实环境下的错误调试与分析其实是并没有任何意义的，我们在查看日志获取错误信息的时候能够获取到的信息十分有限。</p>
<p>于是乎，一些提供了上下文方式的一些错误处理形式便在很多类库中非常常见：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err := os.Remove(<span class="string">"/tmp/nonexist"</span>)</span><br><span class="line">log.Println(err)</span><br></pre></td></tr></table></figure>

<p>输出了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2017/02/08 14:09:22 remove /tmp/nonexist: no such file or directory</span><br></pre></td></tr></table></figure>

<p>这种方式提供了一种更加直观的上下文信息，比如具体出错的内容，也可以是出现错误的文件等等。通过查看 Remove 的实现，我们可以看到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PathError records an error and the operation and file path that caused it.</span></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Op   <span class="keyword">string</span></span><br><span class="line">	Path <span class="keyword">string</span></span><br><span class="line">	Err  error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.Op +<span class="string">" "</span>+ e.Path +<span class="string">": "</span>+ e.Err.Error() &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file_unix.go 针对 *nix 系统的实现</span></span><br><span class="line"><span class="comment">// Remove removes the named file or directory.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// System call interface forces us to know</span></span><br><span class="line">	<span class="comment">// whether name is a file or directory.</span></span><br><span class="line">	<span class="comment">// Try both: it is cheaper on average than</span></span><br><span class="line">	<span class="comment">// doing a Stat plus the right one.</span></span><br><span class="line">	e := syscall.Unlink(name)</span><br><span class="line">	<span class="keyword">if</span> e == <span class="literal">nil</span> &#123;<span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line">	e1 := syscall.Rmdir(name)</span><br><span class="line">	<span class="keyword">if</span> e1 == <span class="literal">nil</span> &#123;<span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Both failed: figure out which error to return.</span></span><br><span class="line">	<span class="comment">// OS X and Linux differ on whether unlink(dir)</span></span><br><span class="line">	<span class="comment">// returns EISDIR, so can't use that. However,</span></span><br><span class="line">	<span class="comment">// both agree that rmdir(file) returns ENOTDIR,</span></span><br><span class="line">	<span class="comment">// so we can use that to decide which error is real.</span></span><br><span class="line">	<span class="comment">// Rmdir might also return ENOTDIR if given a bad</span></span><br><span class="line">	<span class="comment">// file path, like /etc/passwd/foo, but in that case,</span></span><br><span class="line">	<span class="comment">// both errors will be ENOTDIR, so it's okay to</span></span><br><span class="line">	<span class="comment">// use the error from unlink.</span></span><br><span class="line">	<span class="keyword">if</span> e1 != syscall.ENOTDIR &#123;e = e1&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;PathError&#123;<span class="string">"remove"</span>, name, e&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上这里 Golang 标准库中返回了一个名为 <code>PathError</code> 的结构体，这个结构体定义了操作类型、路径和原始的错误信息，然后通过 <code>Error</code> 方法对所有信息进行了整合。</p>
<p>但是这样也会存在问题，比如需要进行单独类型复杂的分类处理，比如上面例子中，需要单独处理 <code>PathError</code> 这种问题，你可能需要一个单独的类型推导：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">err := xxxx()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;swtich err := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *os.PathError:</span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样反倒会增加错误处理的复杂度。同时，这些错误必须变为导出类型，也会增加整个系统的复杂度。</p>
<p>另外一个问题是，我们在出现错误时，我们通常也希望获取更多的堆栈信息，方便我们进行后续的故障追踪。在现有的错误体系中，这相对比较复杂：你很难通过一个接口类型获取完整的调用堆栈。这时，我们可能就需要一个第三方库区去解决遇到的这些错误处理问题。</p>
<p>还有一种情况是，我们希望在错误处理过程中同样可以附加一些信息，这些也会相对比较麻烦。</p>
<h2 id="更优雅的错误处理"><a href="#更优雅的错误处理" class="headerlink" title="更优雅的错误处理"></a>更优雅的错误处理</h2><p>之前提到了多种实际应用场景中出现的错误处理方法和遇到的一些问题，这里推荐使用第三方库去解决部分问题：<code>github.com/pkg/errors</code>。</p>
<p>比如当我们出现问题时，我们可以简单的使用 <code>errors.New</code> 或者 <code>errors.Errorf</code> 生成一个错误变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">"whoops"</span>)</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">err := errors.Errorf(<span class="string">"whoops: %s"</span>, <span class="string">"foo"</span>)</span><br></pre></td></tr></table></figure>

<p>当我们需要附加信息时，则可以使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cause := errors.New(<span class="string">"whoops"</span>)</span><br><span class="line">err := errors.Wrap(cause,<span class="string">"oh noes"</span>)</span><br></pre></td></tr></table></figure>

<p>当需要获取 @用堆栈时，则可以使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">"whoops"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%+v"</span>, err)</span><br></pre></td></tr></table></figure>

<h2 id="其他建议"><a href="#其他建议" class="headerlink" title="其他建议"></a>其他建议</h2><p>在上面做类型推导时，我们发现在处理一类错误时可能需要多个错误类型，这可能在某些情况下相对来说比较复杂，很多时候我们可以使用接口形式去方便处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> temporary <span class="keyword">interface</span> &#123;Temporary() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsTemporary returns true if err is temporary.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsTemporary</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;te, ok := errors.Cause(err).(temporary)</span><br><span class="line">	<span class="keyword">return</span> ok &amp;&amp; te.Temporary()&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以提供更加方便的错误解析和处理。</p>
<h3 id="广告时间"><a href="#广告时间" class="headerlink" title="广告时间"></a>广告时间</h3><p>我们正在招收新人 Gopher，应届毕业生 or 实习生欢迎投递简历。我们正在努力实现开发流程标准化，如果你想获得提高，相信也是一个非常不错的机会。简历投递 kevin [at] yeeuu [dot] com。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/09/2016-09-15-tracing-python-program-with-dtrace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/2016-09-15-tracing-python-program-with-dtrace/" class="post-title-link" itemprop="url">使用 dtrace 跟踪 Python 应用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-09-15 18:00:00" itemprop="dateCreated datePublished" datetime="2016-09-15T18:00:00+08:00">2016-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/09/2016-09-15-tracing-python-program-with-dtrace/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/2016-09-15-tracing-python-program-with-dtrace/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今年在 Pycon China 上，来自饿了么的郭浩川分享了 <a href="http://ocgxshkaw.bkt.clouddn.com/4%20%E3%80%8A%E7%94%A8%E9%AB%98%E9%AD%94%E7%9A%84%E5%A7%BF%E5%8A%BF%E8%B0%83%20python%20%E7%A8%8B%E5%BA%8F%E3%80%8B%E9%83%AD%E6%B5%A9%E5%B7%9D.pdf" target="_blank" rel="noopener">利用 systemtap 进行 Python 执行情况分析</a> 的内容。分享利用 systemtap 在线上环境中实时监控 gevent patch 的 green thread 程序的执行状况。</p>
<p>dtrace 和 systemtap 均支持在 Linux 上进行分析，在 macOS 系统上则只有 dtrace 使用。在 Python3.5 和之前版本中，需要使用手工 Patch 的方式进行埋点监控。在 Python 3.6 以上中 dtrace 和 systemtap 埋点支持功能可以通过编译参数 –with-dtrace 开启。</p>
<h2 id="从-dtrace-开始"><a href="#从-dtrace-开始" class="headerlink" title="从 dtrace 开始"></a>从 dtrace 开始</h2><p>dtrace 是一个低开销的成本动态跟踪工具，可以通过埋点 probs 方式监控各项程序运行状态。dtrace 最初内置在 Solaris 系统中，因此我们可以借助 Solaris 系统的相关文档了解 dtrace 的基本操作。<a href="http://wenku.baidu.com/view/adb13ec7f61fb7360b4c65ad.html" target="_blank" rel="noopener">DTrace 用户指南</a> 是 Oracle 提供的基于 Solaris 系统的 dtrace 操作手册，操作基本与其它系统相同，推荐在最初开始阶段阅读该使用手册。</p>
<p>在 macOS 上，已经很多系统底层功能和 framework 中已经集成了 dtrace 的功能。</p>
<p>比如说我们需要监控 read 这个 syscall 的入口，可以通过下面这个命令实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo dtrace -n syscall::read:entry</span><br><span class="line"></span><br><span class="line">dtrace: description &apos;syscall::read:entry&apos; matched 1 probe</span><br><span class="line"></span><br><span class="line">CPU     ID                    FUNCTION:NAME</span><br><span class="line">  0    156                       read:entry</span><br><span class="line">  0    156                       read:entry</span><br><span class="line">  0    156                       read:entry</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中 <code>-n</code> 参数表示打印特定的 probs 内容的调用。现在这样仅仅显示了调用，但是调用的信息还是不详细的。这个时候就需要使用 dtrace 的脚本获取更多的信息。</p>
<h2 id="dtrace-的脚本"><a href="#dtrace-的脚本" class="headerlink" title="dtrace 的脚本"></a>dtrace 的脚本</h2><p>dtrace 的名字暗示了自己的脚本，dtrace 使用了 D 语言作为脚本语言（WTF）。这个时候就需要学习一下基础的 D 语言内容。dtrace 中 D 语言的使用，可以在上面提到的 dtrace 用户指南中的对应章节。</p>
<p>我们继续上一节中的例子，检测调用 read syscall 的参数内容。在进行操作之前，我们需要了解一下 read 的参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> read(<span class="keyword">int</span> fildes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyte);</span><br></pre></td></tr></table></figure>

<p>我们想知道调用来自于哪些进程，读取了多少字节。首先，我们需要创建一个叫 <code>syscall.d</code> 文件。</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syscall::read:entry</span><br><span class="line">&#123;printf (<span class="string">"%s called read, asking for %d bytes\n"</span>, execname, arg2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过命令行执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo dtrace -s syscall.d</span><br><span class="line"></span><br><span class="line">dtrace: script &apos;syscall.d&apos; matched 1 probe</span><br><span class="line"></span><br><span class="line">CPU     ID                    FUNCTION:NAME</span><br><span class="line">  0    156                       read:entry steam_osx called read, asking for 128 bytes</span><br><span class="line">  0    156                       read:entry steam_osx called read, asking for 128 bytes</span><br><span class="line">  0    156                       read:entry steam_osx called read, asking for 128 bytes</span><br><span class="line">  0    156                       read:entry steam_osx called read, asking for 128 bytes</span><br><span class="line">  0    156                       read:entry iTerm2 called read, asking for 32 bytes</span><br><span class="line">  0    156                       read:entry iTerm2 called read, asking for 1024 bytes</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="从-dtrace-到-Python-跟踪"><a href="#从-dtrace-到-Python-跟踪" class="headerlink" title="从 dtrace 到 Python 跟踪"></a>从 dtrace 到 Python 跟踪</h2><p>在 Pycon 上的分享上，提供了一种 CPython 虚拟机代码 Patch 方式进行跟踪的方案，这种方案需要系统支持，比如 REHL 系列系统默认支持，假如你是用了 Ubuntu 系统，除了重新编译 CPython 以外没有其他办法。不过除此之外，还有一种更简单的方式，就是使用 <code>Python USDT</code>。但是值得注意的是 <code>Python USDT</code> 是一种用户态修饰器监控方法，这种方式与 patch CPython 的方式相比差距较大，毕竟 USDT 无法监控一些系统底层的尤其是涉及到比如 gevent 导致的上下文切换时的混乱。同样的，systemtap 也有一个专门的库：<a href="https://github.com/wooparadog/python-systemtap" target="_blank" rel="noopener">python-systemtap</a>。</p>
<p>不过还是从 USDT 开始。USDT 可以通过 pip 直接安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install usdt</span><br></pre></td></tr></table></figure>

<p>接下来用 ipython 演示一下 usdt 的基础使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ipython</span><br><span class="line">Python 2.7.12 (default, Jul  4 2016, 11:33:35)</span><br><span class="line">Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line"></span><br><span class="line">IPython 5.0.0 -- An enhanced Interactive Python.</span><br><span class="line">?         -&gt; Introduction and overview of IPython&apos;s features.</span><br><span class="line">%quickref -&gt; Quick reference.</span><br><span class="line">help      -&gt; Python&apos;s own help system.</span><br><span class="line">object?   -&gt; Details about &apos;object&apos;, use &apos;object??&apos; for extra details.</span><br><span class="line"></span><br><span class="line">In [1]: import os</span><br><span class="line"></span><br><span class="line">In [2]: os.getpid()</span><br><span class="line">Out[2]: 7777</span><br><span class="line"></span><br><span class="line">In [3]: from usdt.tracer import fbt</span><br><span class="line"></span><br><span class="line">In [4]: @fbt</span><br><span class="line">   ...: def example(v):</span><br><span class="line">   ...:     pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [5]: example(&quot;hello&quot;)</span><br></pre></td></tr></table></figure>

<p>我们使用监听进程的方式监控来自于 usdt 的探针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo dtrace -l -p 7777 -m fbt</span><br><span class="line"></span><br><span class="line">   ID   PROVIDER            MODULE                          FUNCTION NAME</span><br><span class="line"> 1206 python-fbt7777               fbt                           example entry</span><br><span class="line"> 1207 python-fbt7777               fbt                           example return</span><br></pre></td></tr></table></figure>

<p>其中 <code>-p</code> 用于指定进程，<code>-m</code> 指定对应的模块。如果不进行模块过滤的话，你很有可能被很多相关的调试信息淹没。</p>
<p>在新版的 Python 3.6 以上版本中通过开启 <code>--with-dtrace</code> 开关的方式可以获取详细的 Python 运行状态信息，包括：</p>
<ul>
<li>函数调用与返回</li>
<li>GC 开始与结束</li>
<li>执行代码行数</li>
</ul>
<p>首先运行一个 Python 3.6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ipython</span><br><span class="line">Python 3.6.0b1 (default, Sep 15 2016, 10:16:39)</span><br><span class="line">Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line"></span><br><span class="line">IPython 5.1.0 -- An enhanced Interactive Python.</span><br><span class="line">?         -&gt; Introduction and overview of IPython&apos;s features.</span><br><span class="line">%quickref -&gt; Quick reference.</span><br><span class="line">help      -&gt; Python&apos;s own help system.</span><br><span class="line">object?   -&gt; Details about &apos;object&apos;, use &apos;object??&apos; for extra details.</span><br><span class="line"></span><br><span class="line">In [1]: import os</span><br><span class="line"></span><br><span class="line">In [2]: os.getpid()</span><br><span class="line">Out[2]: 33164</span><br><span class="line"></span><br><span class="line">In [3]:</span><br></pre></td></tr></table></figure>

<p>接下来通过 dtrace 来获取所有的 Python 探针输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo dtrace -l -m python3.6</span><br><span class="line"></span><br><span class="line">   ID   PROVIDER            MODULE                          FUNCTION NAME</span><br><span class="line">35775 python33164         python3.6          _PyEval_EvalFrameDefault function-entry</span><br><span class="line">35776 python33164         python3.6          _PyEval_EvalFrameDefault function-return</span><br><span class="line">35777 python33164         python3.6                           collect gc-done</span><br><span class="line">35778 python33164         python3.6                           collect gc-start</span><br><span class="line">35779 python33164         python3.6          _PyEval_EvalFrameDefault line</span><br></pre></td></tr></table></figure>

<p>如果想要实现一个类似 pycon 中监控程序执行具体内容的 dtrace 脚本，请参考官方文档 <a href="https://docs.python.org/3.6/howto/instrumentation.html#instrumentation" target="_blank" rel="noopener">Instrumenting CPython with DTrace and SystemTap</a> 中的现成脚本即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>dtrace 提供了一种方便的、低干扰的 Python 内部执行探查方式。通过这种方式可以方便的了解目前 Python 的具体执行状况。同时，通过脚本，可以快速获取和定位相关想要了解的具体内容。当然，你也可以像郭浩川分享的那样，做一个比较炫酷的烈焰图。XD</p>
<p>[^systemtap]: <a href="http://ocgxshkaw.bkt.clouddn.com/4%20%E3%80%8A%E7%94%A8%E9%AB%98%E9%AD%94%E7%9A%84%E5%A7%BF%E5%8A%BF%E8%B0%83%20python%20%E7%A8%8B%E5%BA%8F%E3%80%8B%E9%83%AD%E6%B5%A9%E5%B7%9D.pdf" target="_blank" rel="noopener">利用 systemtap 进行 Python 执行情况分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/08/2016-08-01-introduce-traefik-load-balance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/2016-08-01-introduce-traefik-load-balance/" class="post-title-link" itemprop="url">traefik 简介</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-08-01 11:00:00" itemprop="dateCreated datePublished" datetime="2016-08-01T11:00:00+08:00">2016-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/08/2016-08-01-introduce-traefik-load-balance/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/2016-08-01-introduce-traefik-load-balance/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>traefik(<a href="https://traefik.io/" target="_blank" rel="noopener">https://traefik.io/</a>) 是一款开源的反向代理与负载均衡工具。它最大的优点是能够与常见的微服务系统直接整合，可以实现自动化动态配置。目前支持 Docker, Swarm, Mesos/Marathon, Mesos, Kubernetes, Consul, Etcd, Zookeeper, BoltDB, Rest API 等等后端模型。</p>
<p>traefik 的具体模型如下：<br><img src="https://github.com/containous/traefik/raw/master/docs/img/architecture.png" alt="traefik"></p>
<h2 id="为什么选择-traefik？"><a href="#为什么选择-traefik？" class="headerlink" title="为什么选择 traefik？"></a>为什么选择 traefik？</h2><p>事实上在之前我对 LB 的选择一直更倾向于使用 <a href="http://www.haproxy.org" target="_blank" rel="noopener">HAProxy</a>。但是选择 traefik 主要是有以下特点让我们决定使用：</p>
<ul>
<li>Golang 编写，单文件部署，与系统无关，同时也提供小尺寸 Docker 镜像。</li>
<li>支持 Docker/Etcd 后端，天然连接我们的微服务集群。</li>
<li>内置 Web UI，管理相对方便。</li>
<li>自动配置 ACME(Let’s Encrypt) 证书功能。</li>
<li>性能尚可，我们也没有到压榨 LB 性能的阶段，易用性更重要。</li>
</ul>
<p>除了这些以外，traefik 还有以下特点：</p>
<ul>
<li>Restful API 支持。</li>
<li>支持后端健康状态检查，根据状态自动配置。</li>
<li>支持动态加载配置文件和 graceful 重启。</li>
<li>支持 WebSocket 和 HTTP/2。</li>
</ul>
<p>除了上面提到的微服务化集群支持，一些 AB 测试阶段也可以通过 frontend 的路由特性进行动态分配，当然这些对 HAProxy 等软件都是标准支持的。</p>
<h2 id="traefik-的配置"><a href="#traefik-的配置" class="headerlink" title="traefik 的配置"></a>traefik 的配置</h2><p>traefik 支持的配置方式支持文件方式进行配置，这个也是比较常见的配置方式，我们这里简单介绍一下。</p>
<p>traefik 支持的 toml 方式进行配置，官方提供了一个 <a href="https://docs.traefik.io/toml/" target="_blank" rel="noopener">示例的 traefik.toml 文件</a> 用于演示配置。除此之外，后端服务一般是采用单独文件进行存储，比如演示配置中指定的 rules.toml。</p>
<p>具体一个例子，如果我们有两个后端，127.0.0.1:7727，127.0.0.1:7728，我们希望所有的 Chrome 用户都可以访问 127.0.0.1:7727，其它人都访问 127.0.0.1:7728，这样这个 rules.toml 应该如何配置呢？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rules.toml</span></span><br><span class="line"><span class="section">[backends]</span></span><br><span class="line"><span class="section">  [backends.backend1]</span></span><br><span class="line"><span class="section">    [backends.backend1.servers.server1]</span></span><br><span class="line">    url = "http://127.0.0.1:7727"</span><br><span class="line"><span class="section">  [backends.backend2]</span></span><br><span class="line"><span class="section">    [backends.backend2.servers.server1]</span></span><br><span class="line">    url = "http://127.0.0.1:7728"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[frontends]</span></span><br><span class="line"><span class="section">  [frontends.frontend1]</span></span><br><span class="line">  entrypoints = ["http"]</span><br><span class="line">  backend = "backend1"</span><br><span class="line"><span class="section">    [frontends.frontend1.routes.test_1]</span></span><br><span class="line">    rule = "HeadersRegexp: User-Agent, Chrome"</span><br><span class="line"><span class="section">  [frontends.frontend2]</span></span><br><span class="line">  entrypoints = ["http"]</span><br><span class="line">  backend = "backend2"</span><br></pre></td></tr></table></figure>

<p>首先定义两个后端服务，每个后端服务可以支持多个服务单元，这里我们只有一个。前端 frontends 用于匹配请求落到哪个后端服务中。我们这里定义一个规则 test_1，设置规则为根据 HTTP 请求头部正则进行分配：如果 UserAgent 中包含 Chrome 字样，则访问到 127.0.0.1:7727。匹配的规则方式包含了以下几种方式:</p>
<ul>
<li><code>Headers</code>/<code>HeaderRegexp</code>: 头部匹配方式，分别对应按值和正则表达式两种方式。</li>
<li><code>Host</code>/<code>HostRegexp</code>: 按照请求主机名进行匹配，与头部信息相似。</li>
<li><code>Method</code>: 按照请求方式区分。</li>
<li><code>Path</code>/<code>PathStrip</code>/<code>PathPrefix</code>/<code>PathPrefixStrip</code>: 按照路径区分后端。</li>
</ul>
<h2 id="traefik-与微服务集群"><a href="#traefik-与微服务集群" class="headerlink" title="traefik 与微服务集群"></a>traefik 与微服务集群</h2><p>这个有人已经写过相关的文章了，我在这里简单推荐一下： <a href="http://blog.hypriot.com/post/microservices-bliss-with-docker-and-traefik/" target="_blank" rel="noopener">Microservices Bliss with Docker and Traefik</a>（<a href="http://dockone.io/article/1418" target="_blank" rel="noopener">中文译文</a>）。我就不做额外的描述了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/07/2016-07-13-type-hint-improve-python-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/2016-07-13-type-hint-improve-python-programming/" class="post-title-link" itemprop="url">利用 Type Hint 提升 Python 程序开发效率</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-13 20:00:00" itemprop="dateCreated datePublished" datetime="2016-07-13T20:00:00+08:00">2016-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/07/2016-07-13-type-hint-improve-python-programming/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/2016-07-13-type-hint-improve-python-programming/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Type Hint（或者叫做 PEP-484）提供了一种针对 Python 程序的类型标注标准。</p>
<p>为什么使用 Type Hint？对于动态语言而言，常常出现的情况是当你写了一段代码后，隔段时间你可能忘记这个方法的原型是什么样子的了，你也不清楚具体应该传入什么类型的参数，这样往往需要你去阅读代码才能定义每个类型具体是什么。或者当你使用一个文档并不是特别完全的第三方库，你不知道这个库应该如何使用，这都会很痛苦。</p>
<p>现在，借助 Type Hint，你可以实现：</p>
<ul>
<li>实现类型检查，防止运行时出现的类型不符合情况。</li>
<li>作为文档附加属性，方便开发者调用时传入传出的参数类型。</li>
<li>提升 IDE 的检查机制，在智能提示时更快给出提示和类型检查结果。</li>
</ul>
<p>实现这个过程中，你需要使用 <figure class="highlight python"><figcaption><span>3.5+``` 中提供的新模块 [```typing```](https://docs.python.org/3.5/library/typing.html)。值得注意的是，这个改动并不会影响程序运行，仅仅是为了方便类型检查器实现的。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## Type Hint 类型检查器</span></span><br><span class="line"></span><br><span class="line">目前，比如 ```JetBrains``` 家的 ```PyCharm``` 已经支持 Type Hint 语法检查功能，如果你使用了这个 IDE，可以通过 IDE 功能进行实现。如果你像我一样，使用了 SublimeText 编辑器，那么第三方工具 [```mypy```](https://github.com/python/mypy) 可以帮助到你。```AnacondaST3``` 最近要发布的 <span class="number">2.0</span> 版本也内置了 ```mypy``` 功能的支持，具体的进度可以看一下 [这个 issue](https://github.com/DamnWidget/anaconda/issues/<span class="number">439</span>)。一些其它的 Python 工具 (比如 [代码提示工具 jedi <span class="number">0.10</span>+](https://github.com/davidhalter/jedi/pull/<span class="number">661</span>)) 也支持了 Type Hint 功能。</span><br><span class="line"></span><br><span class="line"><span class="comment">## 从简单的例子开始</span></span><br><span class="line"></span><br><span class="line">从简单的例子开始，我们先从一个简单的程序开始，运行环境为 ```Python <span class="number">3.5</span><span class="number">.2</span>```，使用 ```mypy``` 工具进行检查。</span><br><span class="line"></span><br><span class="line">首先通过 ```pip install mypy-lang``` 命令安装 ```mypy``` 工具。注意是 ```mypy-lang```，之所以是这样，是因为在 ```pypi``` 里 ```mypy``` 这个名字已经被占用掉了。</span><br><span class="line"></span><br><span class="line">接下来，通过 ```mypy``` 检查下面这个文件</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="comment"># fib.py</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n: int)</span> -&gt; Iterator[int]:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line">i = fib(<span class="number">3.2</span>)</span><br><span class="line">print(next(i))</span><br><span class="line">print(next(i))</span><br></pre></td></tr></table></figure></p>
<p>在命令行中执行命令 <figure class="highlight plain"><figcaption><span>fib.py```，获取返回结果：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>➜ mypy fib.py<br>fib.py:11: error: Argument 1 to “fib” has incompatible type “float”; expected “int”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是在实际的应用过程中，这个功能在 Python 里是可以正常运行的：</span><br></pre></td></tr></table></figure>

<p>➜  mypy python fib.py<br>0<br>1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到，mypy 工具提示了我们的代码中存在一处类型不匹配的问题，但是如果不进行检查，代码有可能执行出不可预知的结果。</span><br><span class="line"></span><br><span class="line">在这个例子里面，我们使用了两种类型，一种是 Python 基础数据类型，比如 ```str```、```int``` 等等，这些类型数据是可以直接使用的；另外一种是来自于 ```typing``` 中引入的 ```Iterator```，用来表示迭代器类型。另外一个值得注意的是，```typing``` 中部分类型也会随时添加，一般我们以演示版本为准。</span><br><span class="line"></span><br><span class="line">从简单到复杂，类型组合怎么办？</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">实际上，在我们使用过程中还有可能传递一些更加复杂的参数类型，比如 list 类型，tuple 类型等等，这类型的数据如何声明呢？我们可以先看一个例子：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">def foo(strings, string_list, count, total):</span><br></pre></td></tr></table></figure>

<p>这个函数的参数我们从字面可以看出来分别是 <figure class="highlight plain"><figcaption><span>```str``` 的 ```list``` 类型和两个整数参数。我们假定一个返回值为 ```((int, int), str)```，那么这个类型检查可以这样定义：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">from typing import List, Tuple</span><br><span class="line"></span><br><span class="line">Result = Tuple[Tuple[int, int], str]</span><br><span class="line"></span><br><span class="line">def foo(strings: str, lines: List[str],  line_number: int, total_lines: int) -&gt; Result:</span><br></pre></td></tr></table></figure></p>
<p>其它的一些类型提示、协程等等的支持都可以在官方的 <a href="https://docs.python.org/3.5/library/typing.html" target="_blank" rel="noopener"><code>typing</code> 模块文档</a> 中进行查看。</p>
<h2 id="关于生产的一些闲扯"><a href="#关于生产的一些闲扯" class="headerlink" title="关于生产的一些闲扯"></a>关于生产的一些闲扯</h2><p>我们现在也在进行一些 <code>mypy</code> 工具在生产环境中的具体使用测试，但是我们也发现了一些存在的问题，比如 <code>Python</code> 本身的动态语言特性给类型标注就带来了一些麻烦。另外，变量复用导致的类型变换有可能会提示采用新的变量实现。这对于一个已经存在的线上项目来说相对成本较高，我们后续也会在一些新项目中采用这种方式。另外 <code>mypy</code> 还是一个比较新的项目，本身是拥有一些 bug。另外一个是在某些 <code>mypy</code> 的非类型错误提示其实非常的模糊，导致很多错误有时需要进行人工排查。</p>
<p>不管怎样，即便在 <code>mypy</code> 存在一些缺陷，但是仍旧是未来非常有潜力的工具，提前了解和应用也能有效的提升程序的强壮性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/05/2016-05-31-learning-coreos-part3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/05/2016-05-31-learning-coreos-part3/" class="post-title-link" itemprop="url">CoreOS 折腾笔记（三）了解 Etcd</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-05-31 09:13:00" itemprop="dateCreated datePublished" datetime="2016-05-31T09:13:00+08:00">2016-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/05/2016-05-31-learning-coreos-part3/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/05/2016-05-31-learning-coreos-part3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>服务发现是微服务化架构中重要的一环，服务的配置信息需要有一种可靠高效的发现机制，保证服务上线时可以及时被使用，服务失效中断时可以及时切走。服务发现工具 Etcd 就是为了这种需求开发的。</p>
<h2 id="什么是-Etcd？"><a href="#什么是-Etcd？" class="headerlink" title="什么是 Etcd？"></a>什么是 Etcd？</h2><p>Etcd 是一个分布式 KV 数据库，通过将数据分散存储在多台独立的设备上，从而提高数据的可靠性或读写性能。Etcd 是几个比较常见的服务发现应用之一，它支持 TTL 的支持和 HTTP Restful API，同时通过 Raft 一致性算法处理日志复制以保证强一致性。关于 Raft 算法，请参考 <a href="http://www.infoq.com/cn/articles/coreos-analyse-etcd" target="_blank" rel="noopener">这篇文章</a>，这里不多介绍。Etcd 本来就是 CoreOS 团队开发支持的，因此也是原生存在在 CoreOS 系统中。</p>
<p>Etcd 中提供了订阅通知机制，同时提供了一个线上服务 <figure class="highlight plain"><figcaption><span>Fleet 等等工具也是基于 Etcd 去发现网络中的节点服务器。在 CoreOS 机器部署之后，系统中一个叫做 ```cloud-init``` 的服务会根据之前的 ```user-data``` 文件去启动 Etcd。Etcd 会更新对应的自己的节点信息，并且获取其它的节点信息。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另外比较常见的服务发现还有 ZooKeeper（应用最广泛）、Consul 等等，如果有兴趣，可以自己在进行研究。</span><br><span class="line"></span><br><span class="line">## Etcdctl 使用</span><br><span class="line"></span><br><span class="line">工具 ```etcdctl``` 是 ```etcd``` 的控制程序，我们可以通过执行命令查看所有键值：</span><br></pre></td></tr></table></figure></p>
<p>core@core-01 ~ $ etcdctl ls / –recursive<br>/coreos.com<br>/coreos.com/network<br>/coreos.com/network/config<br>/coreos.com/network/subnets<br>/coreos.com/network/subnets/10.1.64.0-24<br>/coreos.com/network/subnets/10.1.48.0-24<br>/coreos.com/network/subnets/10.1.10.0-24<br>/coreos.com/updateengine<br>/coreos.com/updateengine/rebootlock<br>/coreos.com/updateengine/rebootlock/semaphore</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">还可以通过类似 Redis 的 ```get``` 等命令获取具体存储内容：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ etcdctl get /coreos.com/network/subnets/10.1.64.0-24<br>{“PublicIP”:”172.17.8.101”}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">区别是 Etcd 是支持目录的：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ etcdctl mkdir hello<br>core@core-01 ~ $ etcdctl get hello<br>/hello: is a directory<br>core@core-01 ~ $ etcdctl rmdir hello</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">刚刚我们介绍时也提到，Etcd 支持 HTTP 方式调用，比如：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ curl -L -X PUT <a href="http://127.0.0.1:2379/v2/keys/message" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/message</a> -d value=”Hello”<br>{“action”:”set”,”node”:{“key”:”/message”,”value”:”Hello”,”modifiedIndex”:10318,”createdIndex”:10318},”prevNode”:{“key”:”/message”,”value”:”Hello”,”modifiedIndex”:10300,”createdIndex”:10300}}<br>core@core-01 ~ $ etcdctl get /message<br>Hello<br>core@core-01 ~ $ curl -L -X DELETE <a href="http://127.0.0.1:2379/v2/keys/message" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/message</a><br>{“action”:”delete”,”node”:{“key”:”/message”,”modifiedIndex”:10462,”createdIndex”:10318},”prevNode”:{“key”:”/message”,”value”:”Hello”,”modifiedIndex”:10318,”createdIndex”:10318}}<br>core@core-01 ~ $ etcdctl get /message<br>Error:  100: Key not found (/message) [10467]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TTL 的特性可以在设置状态时进行设定：</span><br></pre></td></tr></table></figure>

<p>etcdctl set /foo “Expiring Soon” –ttl 20</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这个 KV 对就会在 20 秒内时效。</span><br><span class="line"></span><br><span class="line">## Etcd 集群管理</span><br><span class="line"></span><br><span class="line">除了本身的 KV 数据库特性外，作为集群服务发现工具时，也可以通过 restful api 方式发现当前集群信息：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ curl -L <a href="http://127.0.0.1:4001/v2/stats/leader" target="_blank" rel="noopener">http://127.0.0.1:4001/v2/stats/leader</a><br>{“leader”:”efb737dfdc9ee528”,”followers”:{“6219cfe16536320”:{“latency”:{“current”:0.003561,”average”:0.0031178274017212987,”standardDeviation”:0.018016615756979302,”minimum”:9e-06,”maximum”:1.338917},”counts”:{“fail”:0,”success”:51588}},”a8cc28a8e121c40d”:{“latency”:{“current”:0.002212,”average”:0.002837358092138387,”standardDeviation”:0.015615452604769925,”minimum”:1.7e-05,”maximum”:1.48721},”counts”:{“fail”:0,”success”:51618}},”e44ee28dd4e590ac”:{“latency”:{“current”:0.001838,”average”:0.006247004906804689,”standardDeviation”:0.4458222893241591,”minimum”:9e-06,”maximum”:105.637627},”counts”:{“fail”:32,”success”:58694}}}}<br>core@core-01 ~ $ curl -L <a href="http://127.0.0.1:4001/v2/stats/self" target="_blank" rel="noopener">http://127.0.0.1:4001/v2/stats/self</a><br>{“name”:”c99fef8aac9b4a3e9d3a44f58b0739a6”,”id”:”efb737dfdc9ee528”,”state”:”StateLeader”,”startTime”:”2016-05-28T09:44:01.416629553Z”,”leaderInfo”:{“leader”:”efb737dfdc9ee528”,”uptime”:”1h59m14.023315023s”,”startTime”:”2016-05-28T09:44:44.495996231Z”},”recvAppendRequestCnt”:0,”sendAppendRequestCnt”:162816,”sendPkgRate”:20.004570208101516,”sendBandwidthRate”:1953.7463493742348}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其它的系列集群接口，也可以在 [官方文档](https://coreos.com/etcd/docs/latest/) 中查看。</span><br><span class="line"></span><br><span class="line">## Etcd 配置</span><br><span class="line"></span><br><span class="line">如果你有印象在第一篇中，如果你打开 ```user-data``` 文件，你就会发现 Etcd 的踪影：</span><br><span class="line"></span><br><span class="line">```yaml</span><br><span class="line">➜  coreos-vagrant git:(master) cat user-data</span><br><span class="line">#cloud-config</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">coreos:</span><br><span class="line">  etcd2:</span><br><span class="line">    advertise-client-urls: http://$public_ipv4:2379</span><br><span class="line">    initial-advertise-peer-urls: http://$private_ipv4:2380</span><br><span class="line">    listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001</span><br><span class="line">    listen-peer-urls: http://$private_ipv4:2380,http://$private_ipv4:7001</span><br><span class="line">    discovery: https://discovery.etcd.io/xxxxxxxxxxxx</span><br><span class="line">  fleet:</span><br><span class="line">    public-ip: &quot;$public_ipv4&quot;</span><br><span class="line">  flannel:</span><br><span class="line">    interface: &quot;$public_ipv4&quot;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>我们这里使用了线上服务 <code>https://discovery.etcd.io/</code> 发现集群中的机器，这个服务同样也可以使用本地内系统。</p>
<h2 id="利用-Etcd-制作服务发现"><a href="#利用-Etcd-制作服务发现" class="headerlink" title="利用 Etcd 制作服务发现"></a>利用 Etcd 制作服务发现</h2><p>之前提到，Etcd 的特性非常方便用做服务发现，具体如何操作呢？在谈具体实现之前，我们来介绍一下两种服务注册方法：一种叫做 <a href="http://microservices.io/patterns/self-registration.html" target="_blank" rel="noopener">自注册方法</a>；另外一种叫 <a href="http://microservices.io/patterns/3rd-party-registration.html" target="_blank" rel="noopener">第三方注册方法</a>。区别是是否由自身来进行健康检查和提醒。另外，服务发现重要的是，在服务失效时可以及时去除无效服务，这个在 Etcd 的 TTL 功能上就会显得比较重要。我们可以设置一个键值的有效期为 3 秒，并且每秒钟都来刷新授权，如果程序异常退出或者刷新不及时，那么这个服务简直就会失效。通过这种方式就可以有效验证服务是否有效。</p>
<p>具体的代码就不再额外给出了，大家可以自己动手实现一下。另外，其实服务发现还有一个重要的是提供自身工作的地址端口信息，这些可以通过环境变量传递到容器的注册过程中去，这个也是能够让负载均衡或者 WebService 服务器可以识别服务的重要手段。比如 Nginx 可以在根据服务注册信息定期更新自己的配置文件，利用重载保证不间断的服务运行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/05/2016-05-28-learning-coreos-part2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/05/2016-05-28-learning-coreos-part2/" class="post-title-link" itemprop="url">CoreOS 折腾笔记（二）Fleet 进阶</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-05-28 18:00:00" itemprop="dateCreated datePublished" datetime="2016-05-28T18:00:00+08:00">2016-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/05/2016-05-28-learning-coreos-part2/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/05/2016-05-28-learning-coreos-part2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果要说什么样子的分布式集群对用户是最友好的，那无疑是对客户来说，像本地执行命令一样方便的执行集群命令肯定是最舒服的了。这个我们在上一节 <a href="http://ipfans.github.io/2016/05/learning-coreos-part1/" target="_blank" rel="noopener">集群部署</a> 里面就提到了一个叫做 “fleetctl” 的命令，这个命令是做什么用的呢？</p>
<h2 id="fleet-是什么"><a href="#fleet-是什么" class="headerlink" title="fleet 是什么"></a>fleet 是什么</h2><p>工具 <figure class="highlight plain"><figcaption><span>是一个在集群层面上的 ```systemd``` 管理工具。它的配置文件语法基于 ```systemd``` 的语法，另外添加了一些自有的属性。如果你希望在集群中运行你的服务，那么使用 ```fleet``` 管理 ```systemd``` 单元是再有必要不过的了。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在比较新的系统 (CentOS 7+、Ubuntu 16+、Debian 8+) 中均采用了 ```systemd``` 作为启动项管理工具。如果你对 ```systemd``` 有疑问的话，请到其 [官方网站](https://www.freedesktop.org/wiki/Software/systemd/) 查看具体的介绍，这里不做赘述。</span><br><span class="line"></span><br><span class="line">之前使用的 ```fleetctl``` 就是 ```fleet``` 的管理工具，默认是在集群中的某台机器上进行管理。当然，```fleetctl``` 同样也可以通过远程进行管理，可以通过如下命令连接远程集群。</span><br></pre></td></tr></table></figure></p>
<p>FLEETCTL_ENDPOINT=http://<a href="IP:[PORT]" target="_blank" rel="noopener">IP:[PORT]</a> fleetctl list-units</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## fleetctl 常见命令</span><br><span class="line"></span><br><span class="line">比较常见的 ```fleetctl``` 命令有：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ fleetctl -h<br>…<br>COMMANDS:<br>    cat                查看已经提交的单元文件内容<br>    destroy            销毁集群中的一个或多个单元<br>    fd-forward        将标准输入输出转向到一个 unix socket 中<br>    journal            将集群中的某个 unit 的日志输出到当前<br>    list-machines    查看集群中的已知机器<br>    list-unit-files    查看集群中存在的单元<br>    list-units        查看集群中的单元状态<br>    load            将一个或多个单元加载到集群中，必要时会先执行 submit 功能<br>    ssh                连接到集群中的某台机器<br>    start            启动集群中一个或多个单元，必要时会先执行 submit 和 load 功能<br>    status            输出集群中一个或多个单元的状态<br>    stop            停止集群中一个或多个单元<br>    submit            上传一个或多个单元到集群中，并不会加载执行<br>    unload            卸载集群中的一个或多个单元</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## fleet 单元文件</span><br><span class="line"></span><br><span class="line">以一个 ```Hello World``` 程序作为演示来讲解：</span><br><span class="line"></span><br><span class="line">```ini</span><br><span class="line">[Unit]</span><br><span class="line">Description=Echo Hello World</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStartPre=-/usr/bin/docker kill busybox</span><br><span class="line">ExecStartPre=-/usr/bin/docker rm busybox</span><br><span class="line">ExecStartPre=/usr/bin/docker pull busybox</span><br><span class="line">ExecStart=/usr/bin/docker run --name busybox busybox /bin/sh -c &quot;trap&apos;exit 0&apos;INT TERM; while true; do echo Hello World; sleep 1; done&quot;</span><br><span class="line">ExecStop=/usr/bin/docker stop busybox</span><br></pre></td></tr></table></figure>

<p>看起来基本与 <figure class="highlight plain"><figcaption><span>语法一致。保存成 ```helloworld.service```，然后执行命令：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>core@core-01 ~ $ fleetctl start helloworld.service<br>Unit helloworld.service inactive<br>Unit helloworld.service launched on 6e1b9fae…/172.17.8.104</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以通过 ```fleetctl``` 查看状态：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ fleetctl list-units<br>UNIT            MACHINE                ACTIVE    SUB<br>helloworld.service    6e1b9fae…/172.17.8.104    active    running<br>core@core-01 ~ $ fleetctl list-unit-files<br>UNIT            HASH    DSTATE        STATE        TARGET<br>helloworld.service    ce68bd4    launched    launched    6e1b9fae…/172.17.8.104</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">同时，可以通过 ```fleetctl journal``` 查看程序是否正常运行了。</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ fleetctl journal helloworld<br>The authenticity of host ‘172.17.8.104’ can’t be established.<br>ECDSA key fingerprint is 11:63:ee:93:e4:b9:5e:06:e9:c6:cd:63:e2:df:ef:9e.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘172.17.8.104’ (ECDSA) to the list of known hosts.<br>– Logs begin at Sat 2016-05-28 08:45:39 UTC, end at Sat 2016-05-28 10:09:13 UTC. –<br>May 28 10:09:04 core-04 docker[1163]: Hello World<br>May 28 10:09:05 core-04 docker[1163]: Hello World<br>May 28 10:09:06 core-04 docker[1163]: Hello World<br>May 28 10:09:07 core-04 docker[1163]: Hello World<br>May 28 10:09:08 core-04 docker[1163]: Hello World<br>May 28 10:09:09 core-04 docker[1163]: Hello World<br>May 28 10:09:10 core-04 docker[1163]: Hello World<br>May 28 10:09:11 core-04 docker[1163]: Hello World<br>May 28 10:09:12 core-04 docker[1163]: Hello World<br>May 28 10:09:13 core-04 docker[1163]: Hello World</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 通过 fleet 单元文件实现高可用服务</span><br><span class="line"></span><br><span class="line">实现高可用服务需要多个服务实例：当其中一个服务实例出现问题时，不会干扰其它服务实例的运行。这里我们还是使用上一节中提到的单元文件，但是需要做额外的修改让其支持多实例运行：</span><br><span class="line"></span><br><span class="line">```ini</span><br><span class="line">[Unit]</span><br><span class="line">Description=Echo Hello World</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStartPre=-/usr/bin/docker kill busybox</span><br><span class="line">ExecStartPre=-/usr/bin/docker rm busybox</span><br><span class="line">ExecStartPre=/usr/bin/docker pull busybox</span><br><span class="line">ExecStart=/usr/bin/docker run --name busybox busybox /bin/sh -c &quot;trap&apos;exit 0&apos;INT TERM; while true; do echo Hello World; sleep 1; done&quot;</span><br><span class="line">ExecStop=/usr/bin/docker stop busybox</span><br><span class="line"></span><br><span class="line">[X-Fleet]</span><br><span class="line">Conflicts=helloworld@*.service</span><br></pre></td></tr></table></figure>

<p>最后新增的内容是 fleet 的专属语法，使用 <figure class="highlight plain"><figcaption><span>可以限定每台机器上仅允许一个 ```helloworld``` 服务运行。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>core@core-01 ~ $ fleetctl stop helloworld<br>Unit helloworld.service loaded on 6e1b9fae…/172.17.8.104<br>core@core-01 ~ $ fleetctl unload helloworld<br>Unit helloworld.service inactive<br>core@core-01 ~ $ mv helloworld.service helloworld@.service<br>core@core-01 ~ $ fleetctl start helloworld@1<br>Unit <a href="mailto:helloworld@1.service" target="_blank" rel="noopener">helloworld@1.service</a> inactive<br>Unit <a href="mailto:helloworld@1.service" target="_blank" rel="noopener">helloworld@1.service</a> launched on 6e1b9fae…/172.17.8.104<br>core@core-01 ~ $ fleetctl start helloworld@2<br>Unit <a href="mailto:helloworld@2.service" target="_blank" rel="noopener">helloworld@2.service</a> inactive<br>Unit <a href="mailto:helloworld@2.service" target="_blank" rel="noopener">helloworld@2.service</a> launched on 91060182…/172.17.8.103<br>core@core-01 ~ $ fleetctl start helloworld@3<br>Unit <a href="mailto:helloworld@3.service" target="_blank" rel="noopener">helloworld@3.service</a> inactive<br>Unit <a href="mailto:helloworld@3.service" target="_blank" rel="noopener">helloworld@3.service</a> launched on af1494a6…/172.17.8.102<br>core@core-01 ~ $ fleetctl start helloworld@4<br>Unit <a href="mailto:helloworld@4.service" target="_blank" rel="noopener">helloworld@4.service</a> inactive<br>Unit <a href="mailto:helloworld@4.service" target="_blank" rel="noopener">helloworld@4.service</a> launched on c99fef8a…/172.17.8.101<br>core@core-01 ~ $ fleetctl list-unit-files<br>UNIT            HASH    DSTATE        STATE        TARGET<br>helloworld.service    ce68bd4    inactive    inactive    -<br><a href="mailto:helloworld@1.service" target="_blank" rel="noopener">helloworld@1.service</a>    ce68bd4    launched    launched    6e1b9fae…/172.17.8.104<br><a href="mailto:helloworld@2.service" target="_blank" rel="noopener">helloworld@2.service</a>    ce68bd4    launched    launched    91060182…/172.17.8.103<br><a href="mailto:helloworld@3.service" target="_blank" rel="noopener">helloworld@3.service</a>    ce68bd4    launched    launched    af1494a6…/172.17.8.102<br><a href="mailto:helloworld@4.service" target="_blank" rel="noopener">helloworld@4.service</a>    ce68bd4    launched    launched    c99fef8a…/172.17.8.101<br>```</p>
<p>卸载之前的 <code>helloworld</code>，执行了新的 4 个实例，通过观察可以看到目前实例都是运行在了 4 台不同机器上。</p>
<h1 id="fleet-的一些疑问"><a href="#fleet-的一些疑问" class="headerlink" title="fleet 的一些疑问"></a>fleet 的一些疑问</h1><p>事实上，通过 fleet，可以将服务进行多副本部署，同时通过 fleet 守护程序的正常运行。但是在实际使用中你会发现有一个实际问题，在微服务化场景中，每个服务部署的机器是无法控制的，那么我们怎么知道服务究竟在哪呢？</p>
<p>如何控制流量流向，或者说服务发现问题，这个我会在下一个 <code>Etcd</code> 的介绍中说一下，敬请期待。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/05/2016-05-28-learning-coreos-part1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/05/2016-05-28-learning-coreos-part1/" class="post-title-link" itemprop="url">CoreOS 折腾笔记（一）集群部署</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-05-28 17:00:00" itemprop="dateCreated datePublished" datetime="2016-05-28T17:00:00+08:00">2016-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/05/2016-05-28-learning-coreos-part1/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/05/2016-05-28-learning-coreos-part1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近在技改完成之后打算进行大量的微服务化改造，而方便进行微服务化的步骤之一，就是将现有的系统移植进入 Docker 环境之中。在标准容器系统的选择上，我把目光放在了 CoreOS 上。实际上，我在 CoreOS 版本还是 2 开头的时候就有简单研究过，但是当时主要作为研究 Docker 的途径，现在则是作为集群化部署的基准系统。从本文开始的一系列折腾则是我在研究 CoreOS 集群化使用的一些纪录，而本文就是介绍一个本地实现容器化机群的步骤。</p>
<h2 id="安装-Vagrant"><a href="#安装-Vagrant" class="headerlink" title="安装 Vagrant"></a>安装 Vagrant</h2><p>略，因为太简单了。另外还需要 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 配置 CoreOS-vagrant</span><br><span class="line"></span><br><span class="line">执行以下命令：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">git clone https://github.com/coreos/coreos-vagrant.git</span><br><span class="line">cd coreos-vagrant</span><br></pre></td></tr></table></figure></p>
<p>下载 CoreOS 的 vagrant 配置。值得在进入正式配置之前一提的是，CoreOS 本身是没有默认密码或者安装密码机制的，也就是说，现有的所有认证登录需要通过 SSH 进行。如果是通过 vagrant 安装，会自动生成登录需要的 SSH 密钥，这个是需要额外注意的内容。</p>
<p>首先，将仓库中提供的两个模版配置文件复制成正式，接下来需要修改对应的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp config.rb.sample config.rb</span><br><span class="line">cp user-data.sample user-data</span><br></pre></td></tr></table></figure>

<p>首先修改 <figure class="highlight plain"><figcaption><span>文件。这里重点是两个参数，一个是启动的实例数量，另外一个是升级的版本，我修改成了</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```ruby</span><br><span class="line">$num_instances=4</span><br><span class="line">$update_channel=&apos;stable&apos;</span><br></pre></td></tr></table></figure></p>
<p>启动 4 个实例，升级选择的版本则是月度升级版。另外一个 <figure class="highlight plain"><figcaption><span>暂时不作修改。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接下来执行：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">vagrant up</span><br></pre></td></tr></table></figure></p>
<p>在一堆输出之后，生成的 4 个实例就已经在运行了。也可以通过命令 <figure class="highlight plain"><figcaption><span>status``` 查看运行状态。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>➜  coreos-vagrant git:(master) vagrant status<br>Current machine states:</p>
<p>core-01                   running (virtualbox)<br>core-02                   running (virtualbox)<br>core-03                   running (virtualbox)<br>core-04                   running (virtualbox)</p>
<p>This environment represents multiple VMs. The VMs are all listed<br>above with their current state. For more information about a specific<br>VM, run <code>vagrant status NAME</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接下来需要把 SSH 密钥添加到 SSH 可以识别的路径中，当然，也可以使用 ```ssh -i``` 每次指定 key。</span><br></pre></td></tr></table></figure>

<p>➜  coreos-vagrant git:(master) ssh-add ~/.vagrant.d/insecure_private_key<br>Identity added: /Users/user/.vagrant.d/insecure_private_key (/Users/user/.vagrant.d/insecure_private_key)<br>➜  coreos-vagrant git:(master) vagrant ssh core-01 – -A<br>CoreOS stable (1010.5.0)<br>core@core-01 ~ $</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里的 ```-- -A``` 前两的个横杆表示 ssh 参数的起始。之后的 ```-A``` 是标准的 SSH 命令参数，表示将主机的 SSH 秘钥传递到虚拟机里面，这样做是为了之后的涉及 SSH 操作更加方便，否则会在某些命令时报错。</span><br><span class="line"></span><br><span class="line">进入 CoreOS 之后，就可以查看现在集群中的机器，可以通过如下命令：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ fleetctl list-machines<br>MACHINE        IP        METADATA<br>6e1b9fae…    172.17.8.104    -<br>91060182…    172.17.8.103    -<br>af1494a6…    172.17.8.102    -<br>c99fef8a…    172.17.8.101    -</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查看设备是否正常加入。当然，也可以很方便的登录其它系统：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ fleetctl ssh -machine af1494a6<br>The authenticity of host ‘172.17.8.102’ can’t be established.<br>ECDSA key fingerprint is 24:34:be:4e:b7:43:be:94:34:33:b2:81:e0:0c:08:9d.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘172.17.8.102’ (ECDSA) to the list of known hosts.<br>CoreOS stable (1010.5.0)<br>core@core-02 ~ $ exit<br>logout<br>```</p>
<p>这样我们的第一步，使用 CoreOS 部署本地集群就已经实现了。</p>
<p>最后，如果需要关闭这些 CoreOS 实例，可以通过 <code>vagrant halt</code> 停止所有，下次可以通过 <code>vagrant up</code> 就可以重新启动了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/04/2016-04-26-docker-for-mac-beta/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/04/2016-04-26-docker-for-mac-beta/" class="post-title-link" itemprop="url">Docker for Mac 尝鲜</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-04-26 18:00:00" itemprop="dateCreated datePublished" datetime="2016-04-26T18:00:00+08:00">2016-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/04/2016-04-26-docker-for-mac-beta/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/04/2016-04-26-docker-for-mac-beta/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前作为 <figure class="highlight docker"><figcaption><span>beta``` 的第一批用户获得了 beta 的授权，但是因为邮件进了垃圾邮件，所以一直没有发现。今天给 Docker 发邮件申请 beta 测试才知道已经通过了，赶紧尝鲜起来。如果你没有权限，可以尝试到 [Docker Beta](https://beta.docker.com) 申请测试资格。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__测试版本可能存在风险，请自行判断。__</span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装之前</span></span><br><span class="line"></span><br><span class="line">Docker for Mac 需要一些前置要求，官方文档提供的数据如下：</span><br><span class="line"></span><br><span class="line">* <span class="number">2010</span> 年之后的 Intel Mac 机型，支持 ```MMU(Memory Management Unit)``` 虚拟化、```EPT(Extended Page Table)``` 等特性</span><br><span class="line">* ```OSX <span class="number">10.10</span>.<span class="number">3</span>``` 以上系统</span><br><span class="line">* 至少 ```<span class="number">4</span>GB``` 内存</span><br><span class="line">* ```VirtualBox <span class="number">4</span>.x``` 与 ```Docker for Mac``` 冲突，因此如果你安装这个系列的 ```Virtualbox``` 需要卸载。</span><br><span class="line"></span><br><span class="line">如果之前装过 ```Docker Toolbox``` 的话，需要一些额外的操作去与 ```Docker Toolbox``` 兼容。（我选择了直接卸载现有的 ```Docker Toolbox```。XD ）</span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装 Docker for Mac</span></span><br><span class="line"></span><br><span class="line">```Docker for Mac``` 是一个 <span class="number">98.3</span>M(Mac 显示为 <span class="number">103.1</span>MB) 的 DMG 文件，下载下来之后双击文件，将鲸鱼拖拽到 ```Applications``` 文件夹中即可。</span><br><span class="line"></span><br><span class="line">![Docker drag](http://ww1.sinaimg.cn/mw690/<span class="number">69</span>e37fdbgw1f3a9ba0ex5j20n40ck75x.jpg)</span><br><span class="line"></span><br><span class="line">第一次打开 ```Docker for Mac``` 需要提供邀请码，同时需要特殊权限写入 ```Docker bin``` 文件。</span><br><span class="line"></span><br><span class="line">![](http://ww3.sinaimg.cn/mw690/<span class="number">69</span>e37fdbgw1f3a9afjankj20g809s0uj.jpg)</span><br><span class="line"></span><br><span class="line">```Docker for Mac``` 包含了 ```Docker``` 引擎，```Docker``` 命令行客户端，```Docker Compose``` 和 ```Docker Machine```。之后双击应用程序中的 ```Docker``` 就可以启用引擎，这时，右上角会有一个鲸鱼的标志。</span><br><span class="line"></span><br><span class="line">![](http://ww2.sinaimg.cn/mw690/<span class="number">69</span>e37fdbgw1f3a9bckt09j20aj020q2x.jpg)</span><br><span class="line"></span><br><span class="line">点击标记可以获得菜单，进行设置，查看日志等等信息。</span><br><span class="line"></span><br><span class="line">![](http://ww3.sinaimg.cn/mw690/<span class="number">69</span>e37fdbgw1f3a9bb23nlj206906e74i.jpg)</span><br><span class="line"></span><br><span class="line">点击检查更新可以验证当前是否为最新版本的 ```Docker for Mac```。</span><br><span class="line"></span><br><span class="line">![](http://ww2.sinaimg.cn/mw690/<span class="number">69</span>e37fdbgw1f3a9feab6kj20hf07tdhe.jpg)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Docker for mac 尝鲜</span></span><br><span class="line"></span><br><span class="line">先看一下 ```Docker``` 的设置，可以设置使用的内存启用方式，是否启用 ```VPN``` 兼容模式 (现在我看论坛有人提到会不兼容 ```Cisco AnyConnect```)，禁用 VM 的时光机备份功能。另外可以在这里提供了直接卸载按钮，不想用的时候也比较方便。</span><br><span class="line"></span><br><span class="line">![](http://ww3.sinaimg.cn/mw690/<span class="number">69</span>e37fdbgw1f3aazp4etzj20e40erq4d.jpg)</span><br><span class="line"></span><br><span class="line">附带的软件版本也是新的 Docker 软件：</span><br><span class="line"></span><br><span class="line">```batch</span><br><span class="line">➜  ~ docker -v</span><br><span class="line">Docker version <span class="number">1.11</span>.<span class="number">0</span>, build <span class="number">4</span>dc5990</span><br><span class="line">➜  ~ docker-compose --version</span><br><span class="line">docker-compose version <span class="number">1.7</span>.<span class="number">0</span>, build <span class="number">0</span>d7bf73</span><br><span class="line">➜  ~ docker-machine --version</span><br><span class="line">docker-machine version <span class="number">0.7</span>.<span class="number">0</span>, build a650a40</span><br></pre></td></tr></table></figure></p>
<p>跑一个 Ubuntu 测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker run -i -t --name ubuntu ubuntu:16.04 /bin/bash</span><br><span class="line">root@d5ceb77516bf:/# uname -a</span><br><span class="line">Linux d5ceb77516bf 4.4.6 #1 SMP Mon Apr 18 19:18:15 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line">root@d5ceb77516bf:/#</span><br></pre></td></tr></table></figure>

<p>我发现一直不怎么会写结尾／结论，那么最后扯个蛋：我们在进行 <code>Docker</code> 在 <code>CI/CD</code>、线上环境中的应用摸索，如果你有兴趣交流，欢迎联系 <code>kevin &lt;at&gt; yeeuu &lt;dot&gt; com</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/04/2016-04-18-writing-testable-golang-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/04/2016-04-18-writing-testable-golang-code/" class="post-title-link" itemprop="url">编写测试友好的 Golang 代码</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-04-18 18:40:00" itemprop="dateCreated datePublished" datetime="2016-04-18T18:40:00+08:00">2016-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/04/2016-04-18-writing-testable-golang-code/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/04/2016-04-18-writing-testable-golang-code/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目前我们有大量的应用采用了 Golang 程序进行构建，但是在执行研发流程里我们会发现一些来自于静态编译程序的不便：相对于我们之前使用的 Python 语言程序而言，我们无法在程序功能的单元测试里大量的使用 Mock 方式来进行高效测试。</p>
<p>而这些东西往往可以在开发人员编写单元测试用例时有效的节省时间和一些额外的环境准备成本。因此，这也给我们的程序的单元覆盖率带来了很多麻烦的地方：一些依赖于额外验证和表现的情况或者小几率出现的情况需要复杂的模拟步骤，对开发进度和效率带来了一些额外的影响。如何编写一个测试友好的 Golang 程序成为一个无法绕开的问题。</p>
<h2 id="从动态语言到静态语言"><a href="#从动态语言到静态语言" class="headerlink" title="从动态语言到静态语言"></a>从动态语言到静态语言</h2><p>动态语言有良好的运行时修改属性，在运行时的动态修改函数，可以进行有效的 Mock。比如在 <figure class="highlight plain"><figcaption><span>3 为例，内置了 unittest.mock 标准库）程序中:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">with patch.object(ProductionClass,&apos;method&apos;, return_value=None) as mock_method:</span><br><span class="line">    thing = ProductionClass()</span><br><span class="line">    thing.method(1, 2, 3)</span><br></pre></td></tr></table></figure></p>
<p>自然而然的，我们想到了这样的用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imp = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFunc</span><span class="params">(t *testing.T)</span></span> &#123;<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(org <span class="keyword">func</span>()</span> <span class="title">bool</span>)</span> &#123;imp = org&#125;(imp)</span><br><span class="line">	</span><br><span class="line">	img = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line">	<span class="comment">// testing or something else...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样实现 Mock 是完全可以的，但是实际上会带来一些额外的问题，比如说在 MVC 框架中，我们正常采用的方式一般是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (<span class="string">"models"</span></span><br><span class="line">	...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(ctx Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	data := models.Data()</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式则是无法在运行中进行动态 Mock 的，除非将其转换为参数方式进行调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFunc</span><span class="params">(t *testing.T)</span></span> &#123;Convey(<span class="string">"test"</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(org <span class="keyword">func</span>()</span> <span class="title">string</span>)</span> &#123;models.Data = org  <span class="comment">// Error: cannot assign to models.Data&#125;(models.Data)</span></span><br><span class="line"></span><br><span class="line">		models.Data = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;<span class="keyword">return</span><span class="string">"mocked!"</span>&#125;</span><br><span class="line">		</span><br><span class="line">		....</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var data = models.Data</span></span><br><span class="line"><span class="comment">// in A: data := data()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFunc</span><span class="params">(t *testing.T)</span></span> &#123;Convey(<span class="string">"test"</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(org <span class="keyword">func</span>()</span> <span class="title">string</span>)</span> &#123;data = org&#125;(data)</span><br><span class="line"></span><br><span class="line">		data = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;<span class="keyword">return</span><span class="string">"mocked!"</span>&#125;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写法略微会多处大量的临时函数指针变量，如果是使用这种方式则需要额外的变量值的对应关系，测试完成后变量值需要恢复成原有指针（如果需要测试正常功能）。</p>
<h2 id="从变量到接口"><a href="#从变量到接口" class="headerlink" title="从变量到接口"></a>从变量到接口</h2><p>除了上面介绍的方法以外，是不是还有看起来稍微优雅一点的测试方法呢？我们尝试将上面的函数形式换成下面的接口形式，将 interface 对应的变量作为全局变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">var</span> fetcher DataFetcherInterface</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DataFetcherInterface <span class="keyword">interface</span> &#123;Data() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DataFetcher <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d DataFetcher)</span> <span class="title">Data</span><span class="params">()</span> <span class="title">string</span></span> &#123;<span class="keyword">return</span><span class="string">"hello world!"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;fmt.Fprintf(w,<span class="string">"%s"</span>, fetcher.Data())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;fetcher = DataFetcher&#123;&#125;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, Func)</span><br><span class="line">	http.ListenAndServe(<span class="string">"127.0.0.1:12821"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话我们就可以在测试文件里面定义一个 FakeDataFetcher，实现相关的功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main_test.go</span></span><br><span class="line"><span class="keyword">type</span> FakeDataFetcher <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FakeDataFetcher)</span> <span class="title">Data</span><span class="params">()</span> <span class="title">string</span></span> &#123;<span class="keyword">return</span><span class="string">"mocked!"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFunc</span><span class="params">(t *testing.T)</span></span> &#123;Convey(<span class="string">"test"</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(org DataFetcherInterface)</span></span> &#123;fetcher = org&#125;(fetcher)</span><br><span class="line"></span><br><span class="line">		fetcher = FakeDataFetcher&#123;&#125;</span><br><span class="line"></span><br><span class="line">		req, _ := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://example.com/"</span>, <span class="literal">nil</span>)</span><br><span class="line">		w := httptest.NewRecorder()</span><br><span class="line">		Func(w, req)</span><br><span class="line">		So(w.Body.String(), ShouldEqual, <span class="string">"mocked!"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以减少变量的生成个数，同时，也可以通过 <figure class="highlight plain"><figcaption><span>传入不同的参数，实现不同的 Faker 测试。值得注意的是，在这个 interface 方法中需要特别注意变量共享的线程安全问题。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 依赖注入</span><br><span class="line"></span><br><span class="line">上面两种方法似乎思路类似，除了这些方案之外，还有没有其他的方案呢？最后介绍一下依赖注入的方式，这种方式也可以与上面提到的接口方式搭配使用。这种方式实现起来比较简单方便，也非常适合利用在一些面向过程场景中。</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">// main.go</span><br><span class="line">type EchoInterface interface &#123;Echo() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Echoer struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e Echoer) Echo() string &#123;return&quot;hello world!&quot;&#125;</span><br><span class="line"></span><br><span class="line">func Echo(e EchoInterface) string &#123;return e.Echo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;provider := Echoer&#123;&#125;</span><br><span class="line">	fmt.Println(Echo(provider))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试文件:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main_test.go</span></span><br><span class="line"><span class="keyword">type</span> FakeEchoer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FakeEchoer)</span> <span class="title">Echo</span><span class="params">()</span> <span class="title">string</span></span> &#123;<span class="keyword">return</span><span class="string">"mocked!"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFunc</span><span class="params">(t *testing.T)</span></span> &#123;Convey(<span class="string">"test"</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;provider := FakeEchoer&#123;&#125;</span><br><span class="line">		So(Echo(provider), ShouldEqual, <span class="string">"mocked!"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的几种测试方法基本上是通过固定的原型将代码转为测试友好的 Golang 代码。这样可以通过 Mock，减少来自于其他数据和前置条件的影响，尽可能的降低代码开发的附加成本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/02/2016-02-03-simple-implement-asyncio-to-understand-how-async-works/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/02/2016-02-03-simple-implement-asyncio-to-understand-how-async-works/" class="post-title-link" itemprop="url">从 asyncio 简单实现看异步是如何工作的</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-02-03 15:40:00" itemprop="dateCreated datePublished" datetime="2016-02-03T15:40:00+08:00">2016-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/02/2016-02-03-simple-implement-asyncio-to-understand-how-async-works/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/02/2016-02-03-simple-implement-asyncio-to-understand-how-async-works/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从 asyncio 简单实现看异步是如何工作的</p>
<p>by ipfans</p>
<p>注：请使用 <code>Python 3.5+</code> 版本运行以下代码。</p>
<h2 id="先从例子看起"><a href="#先从例子看起" class="headerlink" title="先从例子看起"></a>先从例子看起</h2><p>首先我们来看一个 socket 通讯的例子，这个例子我们可以在官方 <code>socket</code> 模块的文档中找到部分原型代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo.py</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *  <span class="comment"># 是的，这是一个不好的写法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_server</span><span class="params">(address)</span>:</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = sock.accept()</span><br><span class="line">        print(<span class="string">"connect from"</span>, addr)</span><br><span class="line">        echo_handler(client)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_handler</span><span class="params">(client)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = client.recv(<span class="number">10000</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        client.send(str.encode(<span class="string">"Got: "</span>) + data)</span><br><span class="line">    print(<span class="string">"connection closed."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    echo_server((<span class="string">''</span>, <span class="number">25000</span>))</span><br></pre></td></tr></table></figure>

<p>但是同步模式会有一个问题，当进行通讯是阻塞的，当一个连接占用时就会阻碍其他连接的继续，这个时候应该怎么更快的运行呢？</p>
<h2 id="回顾历史"><a href="#回顾历史" class="headerlink" title="回顾历史"></a>回顾历史</h2><p>在 asyncio 出现之前，我们都是怎么提高效率的呢？首先想到的方法就是多线程处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo_thread.py</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_server</span><span class="params">(address)</span>:</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = sock.accept()</span><br><span class="line">        print(<span class="string">"connect from"</span>, addr)</span><br><span class="line">        _thread.start_new_thread(echo_handler, (client,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_handler</span><span class="params">(client)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = client.recv(<span class="number">10000</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        client.send(str.encode(<span class="string">"Got: "</span>) + data)</span><br><span class="line">    print(<span class="string">"connection closed."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    echo_server((<span class="string">''</span>, <span class="number">25000</span>))</span><br></pre></td></tr></table></figure>

<p>当然了，我们都知道多线程之下总是会有一些问题的。那么还有更好的方案吗？如果你了解过<a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">C10k 问题</a>，你一定听过 `epoll<figure class="highlight plain"><figcaption><span>之类的大名。那么，能在 Python 中使用这些功能吗？答案是肯定的。那就是[```select```](https://docs.python.org/3.5/library/select.html)。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line"># echo_select.py</span><br><span class="line">from socket import *</span><br><span class="line">import select</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def echo_server(address):</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    sock.listen(5)</span><br><span class="line">    input = [sock,]</span><br><span class="line">    while True:</span><br><span class="line">        r, _, _ = select.select(input, [], [])</span><br><span class="line">        for s in r:</span><br><span class="line">            if s == sock:</span><br><span class="line">                client, addr = sock.accept()</span><br><span class="line">                print(&quot;connect from&quot;, addr)</span><br><span class="line">                echo_handler(client)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def echo_handler(client):</span><br><span class="line">    while True:</span><br><span class="line">        data = client.recv(10000)</span><br><span class="line">        if not data:</span><br><span class="line">            break</span><br><span class="line">        client.send(str.encode(&quot;Got: &quot;) + data)</span><br><span class="line">    print(&quot;connection closed.&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    echo_server((&apos;&apos;, 25000))</span><br></pre></td></tr></table></figure></p>
<p>相比 <code>_thread</code> 来说，<code>select</code> 更加底层，提供了最基础的等待 IO 完成功能。但是缺点是这个功能太单一了，这也就是为什么后面语言提供了 `asyncio<figure class="highlight plain"><figcaption><span>`python-dev` 中 [提出了](https://mail.python.org/pipermail/python-ideas/2012-May/015223.html) 要在标准库中添加基于 `select` 的异步 IO 功能。之后 Python 在 3.4 版本之中就加入了 [```selectors `](https://docs.python.org/3.5/library/selectors.html) 与 [```asyncio```](https://docs.python.org/3.5/library/asyncio.html) 库用于异步 IO。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其他的方法还有 `gevent`、`Twisted`、`Tornado` 等等的方案，这里就不多赘述了。(在 3.4 的时候我一直觉得 `yield form` 太丑陋了，相对我宁愿继续用 `Tornado` 的 `yield` 方式。当然这个更加主观的原因吧，不过现在 `async/await` 方式明显让我又让我爱上了。）</span><br><span class="line"></span><br><span class="line">## 从同步到 asyncio</span><br><span class="line"></span><br><span class="line">那么如何在 asyncio 框架下如何实现异步 socket 通讯的例子呢？事实上官方文档中提供了两个比较高层封装过的 asyncio 库例子 [TCP echo server protocol](https://docs.python.org/3.5/library/asyncio-protocol.html#tcp-echo-server-protocol) 和[TCP echo server using streams](https://docs.python.org/3.5/library/asyncio-stream.html#tcp-echo-server-using-streams)。这两个例子采用的是 `asyncio` 的 `socket` 通讯高级别封装，似乎与我们同步代码相差有点远。这里我们实际例子中使用了更加底层的[Low-level socket operations](https://docs.python.org/3.5/library/asyncio-eventloop.html#low-level-socket-operations)。这个更接近于我们在同步状态下使用 `socket` 的代码。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"># aecho.py</span><br><span class="line">from socket import *</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def echo_server(address):</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    sock.listen(5)</span><br><span class="line">    sock.setblocking(False) # 设置非阻塞</span><br><span class="line">    while True:</span><br><span class="line">        client, addr = await loop.sock_accept(sock)</span><br><span class="line">        print(&quot;connect from&quot;, addr)</span><br><span class="line">        loop.create_task(echo_handler(client))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def echo_handler(client):</span><br><span class="line">    with client:</span><br><span class="line">        while True:</span><br><span class="line">            data = await loop.sock_recv(client, 10000)</span><br><span class="line">            if not data:</span><br><span class="line">                break</span><br><span class="line">            await loop.sock_sendall(client, str.encode(&quot;Got: &quot;) + data)</span><br><span class="line">    print(&quot;connection closed&quot;)</span><br><span class="line"></span><br><span class="line">loop.create_task(echo_server((&apos;&apos;, 25000)))</span><br><span class="line">loop.run_forever()</span><br></pre></td></tr></table></figure></p>
<p>其中遇到的 <code>create_task</code> 会相对同步状态下无法对应，这个方法用于安排一个异步任务的执行，将一个异步方法封装为 <code>future</code> 对象。其他的 <code>Event Loop</code> 中的功能基本与传统的程序相同。</p>
<h2 id="从-asyncio-到自己的实现"><a href="#从-asyncio-到自己的实现" class="headerlink" title="从 asyncio 到自己的实现"></a>从 asyncio 到自己的实现</h2><p>那么在 <code>asyncio.event_loop</code> 中到底发生了什么呢？我们可以尝试用自己的程序实现一下。</p>
<p>如果你阅读过<a href="https://www.python.org/dev/peps/pep-0492/" target="_blank" rel="noopener">PEP-0492</a>，你就知道，实际上 Python 的协程是通过生成器实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># async_yield.py</span></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_wait</span><span class="params">(sock)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"read_wait"</span>, sock  <span class="comment"># 为什么有个 read_wait？等下介绍</span></span><br></pre></td></tr></table></figure>

<p>下面来模拟实际调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">python -i async_yield.py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = read_wait(<span class="string">"somesocket"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;generator object read_wait at <span class="number">0x10200d5c8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.send(<span class="literal">None</span>)</span><br><span class="line">(<span class="string">'read_wait'</span>, <span class="string">'somesocket'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.send(<span class="literal">None</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>如果不了解 <code>send()</code> 与 <code>StopIteration</code> 作用的话，请参考 <code>PEP-0492</code> 中相关的描述。</p>
<p>接下来继续完善 <code>write</code> 方法，并且实现我们自己的 <code>Loop</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># async_yield.py</span></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector, EVENT_READ, EVENT_WRITE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_wait</span><span class="params">(sock)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"read_wait"</span>, sock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_wait</span><span class="params">(sock)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"write_wait"</span>, sock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loop</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ready = deque()</span><br><span class="line">        self.selector = DefaultSelector()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">sock_recv</span><span class="params">(self, sock, maxbytes)</span>:</span></span><br><span class="line">        <span class="keyword">await</span> read_wait(sock)</span><br><span class="line">        <span class="keyword">return</span> sock.recv(maxbytes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">sock_accept</span><span class="params">(self, sock)</span>:</span></span><br><span class="line">        <span class="keyword">await</span> read_wait(sock)</span><br><span class="line">        <span class="keyword">return</span> sock.accept()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">sock_sendall</span><span class="params">(self, sock, data)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> data:</span><br><span class="line">            <span class="keyword">await</span> write_wait(sock)</span><br><span class="line">            n = sock.send(data)</span><br><span class="line">            data = data[n:]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_task</span><span class="params">(self, coro)</span>:</span></span><br><span class="line">        self.ready.append(coro)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_forever</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.ready:</span><br><span class="line">                events = self.selector.select()</span><br><span class="line">                <span class="keyword">for</span> key, _ <span class="keyword">in</span> events:</span><br><span class="line">                    self.ready.append(key.data)</span><br><span class="line">                    self.selector.unregister(key.fileobj)</span><br><span class="line">            <span class="keyword">while</span> self.ready:</span><br><span class="line">                self.current_task = self.ready.popleft()</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    op, *args = self.current_task.send(<span class="literal">None</span>)</span><br><span class="line">                    getattr(self, op)(*args)</span><br><span class="line">                <span class="keyword">except</span> StopIteration:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_wait</span><span class="params">(self, sock)</span>:</span></span><br><span class="line">        self.selector.register(sock, EVENT_READ, self.current_task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_wait</span><span class="params">(self, sock)</span>:</span></span><br><span class="line">        self.selector.register(sock, EVENT_WRITE, self.current_task)</span><br></pre></td></tr></table></figure>

<p>对于之前一节中的 <code>aecho.py</code> 文件，我们只需要修改一下导入模块与 loop 的获取方法即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pecho.py</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> async_yield</span><br><span class="line"></span><br><span class="line">loop = async_yield.Loop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">echo_server</span><span class="params">(address)</span>:</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    sock.setblocking(<span class="literal">False</span>)  <span class="comment"># 设置非阻塞模式</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = <span class="keyword">await</span> loop.sock_accept(sock)</span><br><span class="line">        print(<span class="string">"connect from"</span>, addr)</span><br><span class="line">        loop.create_task(echo_handler(client))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">echo_handler</span><span class="params">(client)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> client:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = <span class="keyword">await</span> loop.sock_recv(client, <span class="number">10000</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">await</span> loop.sock_sendall(client, str.encode(<span class="string">"Got: "</span>) + data)</span><br><span class="line">    print(<span class="string">"connection closed"</span>)</span><br><span class="line"></span><br><span class="line">loop.create_task(echo_server((<span class="string">''</span>, <span class="number">25000</span>)))</span><br><span class="line">loop.run_forever()</span><br></pre></td></tr></table></figure>

<h2 id="async-yield-发生了什么？"><a href="#async-yield-发生了什么？" class="headerlink" title="async_yield 发生了什么？"></a>async_yield 发生了什么？</h2><p>首先，我们定义了两个协程函数 <code>read_wait</code> 和 <code>write_wait</code>，分别用于相应处理读取操作与写入操作。其中返回了一个 tuple 类型数据，用于在 <code>op, *args = self.current_task.send(None)</code> 中填充方法名和参数，之后在 <code>getattr(self, op)(*args)</code> 中进行分别调用。</p>
<p>下面 <code>Loop</code> 类实现了在 pecho 中用到的所有异步函数。初始化时的 <code>self.ready</code> 用于存储协程的调用序列。该序列通过 <code>create_task</code> 添加协程到队列中。</p>
<p>在 <code>run_forever</code> 中，如果目前队列为空，则通过 <code>self.selector.select()</code> 提取一个事件放入队列处理，若队列存在通过 <code>self.current_task.send(None)</code> 通知事件发送，从而调用对应的事件功能。你也可以在 <code>op, *args = self.current_task.send(None)</code> 后添加 <code>print(op)</code> 获取实时的调用情况。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>事实上这篇文章的思路是基于 <a href="https://twitter.com/dabeaz" target="_blank" rel="noopener">@dabeaz</a> 在 <code>Python Brasil</code> 上的 <a href="https://www.youtube.com/watch?v=ZzfHjytDceU" target="_blank" rel="noopener">keynote</a> 整理而来。dabeaz 还有另外一个非常不错的基于 select 的异步库，名字叫做<a href="https://github.com/dabeaz/curio" target="_blank" rel="noopener">curio</a>，是一个了解实现异步库的很好教程。</p>
<p>最后讲个段子，之前有人开玩笑，蟒爹开发一个功能，之后大家都不会正确使用，直到 dabeaz 站出来告诉大家如何正确使用新功能。在写这篇文章的时候虽然很想找出来出处，但是似乎找不到了…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ipfans"
      src="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
  <p class="site-author-name" itemprop="name">ipfans</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ipfans" title="GitHub → https://github.com/ipfans" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/janxin" title="Twitter → https://twitter.com/janxin" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2013 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ipfans</span>
</div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://s1mbily.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

  <script>
  var link = "" ;
  // 遍历所有的img标签
  $("img").each( (i,o) => {
    var o = $(o);
      // 判断图片的链接是否包含sinaimg关键字
    if( o.attr("src").indexOf("sinaimg") > 0 ){
          // 给这个标签加上referrerPlicy属性
      o.attr("referrerpolicy","no-referrer");
          // 备份图片的src
      link = o.attr("src");
          // 重新设置src，让页面重新加载一次图片
      o.attr("src",link);
    }
  });
  </script>
</body>
</html>
