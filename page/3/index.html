<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ipfans's Blog" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://www.4async.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ipfans&#39;s Blog">
<meta property="og:url" content="https://www.4async.com/page/3/index.html">
<meta property="og:site_name" content="ipfans&#39;s Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ipfans&#39;s Blog">

<link rel="canonical" href="https://www.4async.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ipfans's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b9862358b198078f40d7e1596b7c5968";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ipfans's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/08/2016-08-01-introduce-traefik-load-balance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/2016-08-01-introduce-traefik-load-balance/" class="post-title-link" itemprop="url">traefik 简介</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-08-01 11:00:00" itemprop="dateCreated datePublished" datetime="2016-08-01T11:00:00+08:00">2016-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/08/2016-08-01-introduce-traefik-load-balance/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/2016-08-01-introduce-traefik-load-balance/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>traefik(<a href="https://traefik.io/" target="_blank" rel="noopener">https://traefik.io/</a>) 是一款开源的反向代理与负载均衡工具。它最大的优点是能够与常见的微服务系统直接整合，可以实现自动化动态配置。目前支持 Docker, Swarm, Mesos/Marathon, Mesos, Kubernetes, Consul, Etcd, Zookeeper, BoltDB, Rest API 等等后端模型。</p>
<p>traefik 的具体模型如下：<br><img src="https://github.com/containous/traefik/raw/master/docs/img/architecture.png" alt="traefik"></p>
<h2 id="为什么选择-traefik？"><a href="#为什么选择-traefik？" class="headerlink" title="为什么选择 traefik？"></a>为什么选择 traefik？</h2><p>事实上在之前我对 LB 的选择一直更倾向于使用 <a href="http://www.haproxy.org" target="_blank" rel="noopener">HAProxy</a>。但是选择 traefik 主要是有以下特点让我们决定使用：</p>
<ul>
<li>Golang 编写，单文件部署，与系统无关，同时也提供小尺寸 Docker 镜像。</li>
<li>支持 Docker/Etcd 后端，天然连接我们的微服务集群。</li>
<li>内置 Web UI，管理相对方便。</li>
<li>自动配置 ACME(Let’s Encrypt) 证书功能。</li>
<li>性能尚可，我们也没有到压榨 LB 性能的阶段，易用性更重要。</li>
</ul>
<p>除了这些以外，traefik 还有以下特点：</p>
<ul>
<li>Restful API 支持。</li>
<li>支持后端健康状态检查，根据状态自动配置。</li>
<li>支持动态加载配置文件和 graceful 重启。</li>
<li>支持 WebSocket 和 HTTP/2。</li>
</ul>
<p>除了上面提到的微服务化集群支持，一些 AB 测试阶段也可以通过 frontend 的路由特性进行动态分配，当然这些对 HAProxy 等软件都是标准支持的。</p>
<h2 id="traefik-的配置"><a href="#traefik-的配置" class="headerlink" title="traefik 的配置"></a>traefik 的配置</h2><p>traefik 支持的配置方式支持文件方式进行配置，这个也是比较常见的配置方式，我们这里简单介绍一下。</p>
<p>traefik 支持的 toml 方式进行配置，官方提供了一个 <a href="https://docs.traefik.io/toml/" target="_blank" rel="noopener">示例的 traefik.toml 文件</a> 用于演示配置。除此之外，后端服务一般是采用单独文件进行存储，比如演示配置中指定的 rules.toml。</p>
<p>具体一个例子，如果我们有两个后端，127.0.0.1:7727，127.0.0.1:7728，我们希望所有的 Chrome 用户都可以访问 127.0.0.1:7727，其它人都访问 127.0.0.1:7728，这样这个 rules.toml 应该如何配置呢？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rules.toml</span></span><br><span class="line"><span class="section">[backends]</span></span><br><span class="line"><span class="section">  [backends.backend1]</span></span><br><span class="line"><span class="section">    [backends.backend1.servers.server1]</span></span><br><span class="line">    url = "http://127.0.0.1:7727"</span><br><span class="line"><span class="section">  [backends.backend2]</span></span><br><span class="line"><span class="section">    [backends.backend2.servers.server1]</span></span><br><span class="line">    url = "http://127.0.0.1:7728"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[frontends]</span></span><br><span class="line"><span class="section">  [frontends.frontend1]</span></span><br><span class="line">  entrypoints = ["http"]</span><br><span class="line">  backend = "backend1"</span><br><span class="line"><span class="section">    [frontends.frontend1.routes.test_1]</span></span><br><span class="line">    rule = "HeadersRegexp: User-Agent, Chrome"</span><br><span class="line"><span class="section">  [frontends.frontend2]</span></span><br><span class="line">  entrypoints = ["http"]</span><br><span class="line">  backend = "backend2"</span><br></pre></td></tr></table></figure>

<p>首先定义两个后端服务，每个后端服务可以支持多个服务单元，这里我们只有一个。前端 frontends 用于匹配请求落到哪个后端服务中。我们这里定义一个规则 test_1，设置规则为根据 HTTP 请求头部正则进行分配：如果 UserAgent 中包含 Chrome 字样，则访问到 127.0.0.1:7727。匹配的规则方式包含了以下几种方式:</p>
<ul>
<li><code>Headers</code>/<code>HeaderRegexp</code>: 头部匹配方式，分别对应按值和正则表达式两种方式。</li>
<li><code>Host</code>/<code>HostRegexp</code>: 按照请求主机名进行匹配，与头部信息相似。</li>
<li><code>Method</code>: 按照请求方式区分。</li>
<li><code>Path</code>/<code>PathStrip</code>/<code>PathPrefix</code>/<code>PathPrefixStrip</code>: 按照路径区分后端。</li>
</ul>
<h2 id="traefik-与微服务集群"><a href="#traefik-与微服务集群" class="headerlink" title="traefik 与微服务集群"></a>traefik 与微服务集群</h2><p>这个有人已经写过相关的文章了，我在这里简单推荐一下： <a href="http://blog.hypriot.com/post/microservices-bliss-with-docker-and-traefik/" target="_blank" rel="noopener">Microservices Bliss with Docker and Traefik</a>（<a href="http://dockone.io/article/1418" target="_blank" rel="noopener">中文译文</a>）。我就不做额外的描述了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/07/2016-07-13-type-hint-improve-python-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/2016-07-13-type-hint-improve-python-programming/" class="post-title-link" itemprop="url">利用 Type Hint 提升 Python 程序开发效率</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-13 20:00:00" itemprop="dateCreated datePublished" datetime="2016-07-13T20:00:00+08:00">2016-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/07/2016-07-13-type-hint-improve-python-programming/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/2016-07-13-type-hint-improve-python-programming/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Type Hint（或者叫做 PEP-484）提供了一种针对 Python 程序的类型标注标准。</p>
<p>为什么使用 Type Hint？对于动态语言而言，常常出现的情况是当你写了一段代码后，隔段时间你可能忘记这个方法的原型是什么样子的了，你也不清楚具体应该传入什么类型的参数，这样往往需要你去阅读代码才能定义每个类型具体是什么。或者当你使用一个文档并不是特别完全的第三方库，你不知道这个库应该如何使用，这都会很痛苦。</p>
<p>现在，借助 Type Hint，你可以实现：</p>
<ul>
<li>实现类型检查，防止运行时出现的类型不符合情况。</li>
<li>作为文档附加属性，方便开发者调用时传入传出的参数类型。</li>
<li>提升 IDE 的检查机制，在智能提示时更快给出提示和类型检查结果。</li>
</ul>
<p>实现这个过程中，你需要使用 <figure class="highlight python"><figcaption><span>3.5+``` 中提供的新模块 [```typing```](https://docs.python.org/3.5/library/typing.html)。值得注意的是，这个改动并不会影响程序运行，仅仅是为了方便类型检查器实现的。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## Type Hint 类型检查器</span></span><br><span class="line"></span><br><span class="line">目前，比如 ```JetBrains``` 家的 ```PyCharm``` 已经支持 Type Hint 语法检查功能，如果你使用了这个 IDE，可以通过 IDE 功能进行实现。如果你像我一样，使用了 SublimeText 编辑器，那么第三方工具 [```mypy```](https://github.com/python/mypy) 可以帮助到你。```AnacondaST3``` 最近要发布的 <span class="number">2.0</span> 版本也内置了 ```mypy``` 功能的支持，具体的进度可以看一下 [这个 issue](https://github.com/DamnWidget/anaconda/issues/<span class="number">439</span>)。一些其它的 Python 工具 (比如 [代码提示工具 jedi <span class="number">0.10</span>+](https://github.com/davidhalter/jedi/pull/<span class="number">661</span>)) 也支持了 Type Hint 功能。</span><br><span class="line"></span><br><span class="line"><span class="comment">## 从简单的例子开始</span></span><br><span class="line"></span><br><span class="line">从简单的例子开始，我们先从一个简单的程序开始，运行环境为 ```Python <span class="number">3.5</span><span class="number">.2</span>```，使用 ```mypy``` 工具进行检查。</span><br><span class="line"></span><br><span class="line">首先通过 ```pip install mypy-lang``` 命令安装 ```mypy``` 工具。注意是 ```mypy-lang```，之所以是这样，是因为在 ```pypi``` 里 ```mypy``` 这个名字已经被占用掉了。</span><br><span class="line"></span><br><span class="line">接下来，通过 ```mypy``` 检查下面这个文件</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="comment"># fib.py</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n: int)</span> -&gt; Iterator[int]:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line">i = fib(<span class="number">3.2</span>)</span><br><span class="line">print(next(i))</span><br><span class="line">print(next(i))</span><br></pre></td></tr></table></figure></p>
<p>在命令行中执行命令 <figure class="highlight plain"><figcaption><span>fib.py```，获取返回结果：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>➜ mypy fib.py<br>fib.py:11: error: Argument 1 to “fib” has incompatible type “float”; expected “int”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是在实际的应用过程中，这个功能在 Python 里是可以正常运行的：</span><br></pre></td></tr></table></figure>

<p>➜  mypy python fib.py<br>0<br>1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到，mypy 工具提示了我们的代码中存在一处类型不匹配的问题，但是如果不进行检查，代码有可能执行出不可预知的结果。</span><br><span class="line"></span><br><span class="line">在这个例子里面，我们使用了两种类型，一种是 Python 基础数据类型，比如 ```str```、```int``` 等等，这些类型数据是可以直接使用的；另外一种是来自于 ```typing``` 中引入的 ```Iterator```，用来表示迭代器类型。另外一个值得注意的是，```typing``` 中部分类型也会随时添加，一般我们以演示版本为准。</span><br><span class="line"></span><br><span class="line">从简单到复杂，类型组合怎么办？</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">实际上，在我们使用过程中还有可能传递一些更加复杂的参数类型，比如 list 类型，tuple 类型等等，这类型的数据如何声明呢？我们可以先看一个例子：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">def foo(strings, string_list, count, total):</span><br></pre></td></tr></table></figure>

<p>这个函数的参数我们从字面可以看出来分别是 <figure class="highlight plain"><figcaption><span>```str``` 的 ```list``` 类型和两个整数参数。我们假定一个返回值为 ```((int, int), str)```，那么这个类型检查可以这样定义：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">from typing import List, Tuple</span><br><span class="line"></span><br><span class="line">Result = Tuple[Tuple[int, int], str]</span><br><span class="line"></span><br><span class="line">def foo(strings: str, lines: List[str],  line_number: int, total_lines: int) -&gt; Result:</span><br></pre></td></tr></table></figure></p>
<p>其它的一些类型提示、协程等等的支持都可以在官方的 <a href="https://docs.python.org/3.5/library/typing.html" target="_blank" rel="noopener"><code>typing</code> 模块文档</a> 中进行查看。</p>
<h2 id="关于生产的一些闲扯"><a href="#关于生产的一些闲扯" class="headerlink" title="关于生产的一些闲扯"></a>关于生产的一些闲扯</h2><p>我们现在也在进行一些 <code>mypy</code> 工具在生产环境中的具体使用测试，但是我们也发现了一些存在的问题，比如 <code>Python</code> 本身的动态语言特性给类型标注就带来了一些麻烦。另外，变量复用导致的类型变换有可能会提示采用新的变量实现。这对于一个已经存在的线上项目来说相对成本较高，我们后续也会在一些新项目中采用这种方式。另外 <code>mypy</code> 还是一个比较新的项目，本身是拥有一些 bug。另外一个是在某些 <code>mypy</code> 的非类型错误提示其实非常的模糊，导致很多错误有时需要进行人工排查。</p>
<p>不管怎样，即便在 <code>mypy</code> 存在一些缺陷，但是仍旧是未来非常有潜力的工具，提前了解和应用也能有效的提升程序的强壮性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/05/2016-05-31-learning-coreos-part3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/05/2016-05-31-learning-coreos-part3/" class="post-title-link" itemprop="url">CoreOS 折腾笔记（三）了解 Etcd</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-05-31 09:13:00" itemprop="dateCreated datePublished" datetime="2016-05-31T09:13:00+08:00">2016-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/05/2016-05-31-learning-coreos-part3/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/05/2016-05-31-learning-coreos-part3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>服务发现是微服务化架构中重要的一环，服务的配置信息需要有一种可靠高效的发现机制，保证服务上线时可以及时被使用，服务失效中断时可以及时切走。服务发现工具 Etcd 就是为了这种需求开发的。</p>
<h2 id="什么是-Etcd？"><a href="#什么是-Etcd？" class="headerlink" title="什么是 Etcd？"></a>什么是 Etcd？</h2><p>Etcd 是一个分布式 KV 数据库，通过将数据分散存储在多台独立的设备上，从而提高数据的可靠性或读写性能。Etcd 是几个比较常见的服务发现应用之一，它支持 TTL 的支持和 HTTP Restful API，同时通过 Raft 一致性算法处理日志复制以保证强一致性。关于 Raft 算法，请参考 <a href="http://www.infoq.com/cn/articles/coreos-analyse-etcd" target="_blank" rel="noopener">这篇文章</a>，这里不多介绍。Etcd 本来就是 CoreOS 团队开发支持的，因此也是原生存在在 CoreOS 系统中。</p>
<p>Etcd 中提供了订阅通知机制，同时提供了一个线上服务 <figure class="highlight plain"><figcaption><span>Fleet 等等工具也是基于 Etcd 去发现网络中的节点服务器。在 CoreOS 机器部署之后，系统中一个叫做 ```cloud-init``` 的服务会根据之前的 ```user-data``` 文件去启动 Etcd。Etcd 会更新对应的自己的节点信息，并且获取其它的节点信息。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另外比较常见的服务发现还有 ZooKeeper（应用最广泛）、Consul 等等，如果有兴趣，可以自己在进行研究。</span><br><span class="line"></span><br><span class="line">## Etcdctl 使用</span><br><span class="line"></span><br><span class="line">工具 ```etcdctl``` 是 ```etcd``` 的控制程序，我们可以通过执行命令查看所有键值：</span><br></pre></td></tr></table></figure></p>
<p>core@core-01 ~ $ etcdctl ls / –recursive<br>/coreos.com<br>/coreos.com/network<br>/coreos.com/network/config<br>/coreos.com/network/subnets<br>/coreos.com/network/subnets/10.1.64.0-24<br>/coreos.com/network/subnets/10.1.48.0-24<br>/coreos.com/network/subnets/10.1.10.0-24<br>/coreos.com/updateengine<br>/coreos.com/updateengine/rebootlock<br>/coreos.com/updateengine/rebootlock/semaphore</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">还可以通过类似 Redis 的 ```get``` 等命令获取具体存储内容：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ etcdctl get /coreos.com/network/subnets/10.1.64.0-24<br>{“PublicIP”:”172.17.8.101”}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">区别是 Etcd 是支持目录的：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ etcdctl mkdir hello<br>core@core-01 ~ $ etcdctl get hello<br>/hello: is a directory<br>core@core-01 ~ $ etcdctl rmdir hello</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">刚刚我们介绍时也提到，Etcd 支持 HTTP 方式调用，比如：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ curl -L -X PUT <a href="http://127.0.0.1:2379/v2/keys/message" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/message</a> -d value=”Hello”<br>{“action”:”set”,”node”:{“key”:”/message”,”value”:”Hello”,”modifiedIndex”:10318,”createdIndex”:10318},”prevNode”:{“key”:”/message”,”value”:”Hello”,”modifiedIndex”:10300,”createdIndex”:10300}}<br>core@core-01 ~ $ etcdctl get /message<br>Hello<br>core@core-01 ~ $ curl -L -X DELETE <a href="http://127.0.0.1:2379/v2/keys/message" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/message</a><br>{“action”:”delete”,”node”:{“key”:”/message”,”modifiedIndex”:10462,”createdIndex”:10318},”prevNode”:{“key”:”/message”,”value”:”Hello”,”modifiedIndex”:10318,”createdIndex”:10318}}<br>core@core-01 ~ $ etcdctl get /message<br>Error:  100: Key not found (/message) [10467]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TTL 的特性可以在设置状态时进行设定：</span><br></pre></td></tr></table></figure>

<p>etcdctl set /foo “Expiring Soon” –ttl 20</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这个 KV 对就会在 20 秒内时效。</span><br><span class="line"></span><br><span class="line">## Etcd 集群管理</span><br><span class="line"></span><br><span class="line">除了本身的 KV 数据库特性外，作为集群服务发现工具时，也可以通过 restful api 方式发现当前集群信息：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ curl -L <a href="http://127.0.0.1:4001/v2/stats/leader" target="_blank" rel="noopener">http://127.0.0.1:4001/v2/stats/leader</a><br>{“leader”:”efb737dfdc9ee528”,”followers”:{“6219cfe16536320”:{“latency”:{“current”:0.003561,”average”:0.0031178274017212987,”standardDeviation”:0.018016615756979302,”minimum”:9e-06,”maximum”:1.338917},”counts”:{“fail”:0,”success”:51588}},”a8cc28a8e121c40d”:{“latency”:{“current”:0.002212,”average”:0.002837358092138387,”standardDeviation”:0.015615452604769925,”minimum”:1.7e-05,”maximum”:1.48721},”counts”:{“fail”:0,”success”:51618}},”e44ee28dd4e590ac”:{“latency”:{“current”:0.001838,”average”:0.006247004906804689,”standardDeviation”:0.4458222893241591,”minimum”:9e-06,”maximum”:105.637627},”counts”:{“fail”:32,”success”:58694}}}}<br>core@core-01 ~ $ curl -L <a href="http://127.0.0.1:4001/v2/stats/self" target="_blank" rel="noopener">http://127.0.0.1:4001/v2/stats/self</a><br>{“name”:”c99fef8aac9b4a3e9d3a44f58b0739a6”,”id”:”efb737dfdc9ee528”,”state”:”StateLeader”,”startTime”:”2016-05-28T09:44:01.416629553Z”,”leaderInfo”:{“leader”:”efb737dfdc9ee528”,”uptime”:”1h59m14.023315023s”,”startTime”:”2016-05-28T09:44:44.495996231Z”},”recvAppendRequestCnt”:0,”sendAppendRequestCnt”:162816,”sendPkgRate”:20.004570208101516,”sendBandwidthRate”:1953.7463493742348}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其它的系列集群接口，也可以在 [官方文档](https://coreos.com/etcd/docs/latest/) 中查看。</span><br><span class="line"></span><br><span class="line">## Etcd 配置</span><br><span class="line"></span><br><span class="line">如果你有印象在第一篇中，如果你打开 ```user-data``` 文件，你就会发现 Etcd 的踪影：</span><br><span class="line"></span><br><span class="line">```yaml</span><br><span class="line">➜  coreos-vagrant git:(master) cat user-data</span><br><span class="line">#cloud-config</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">coreos:</span><br><span class="line">  etcd2:</span><br><span class="line">    advertise-client-urls: http://$public_ipv4:2379</span><br><span class="line">    initial-advertise-peer-urls: http://$private_ipv4:2380</span><br><span class="line">    listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001</span><br><span class="line">    listen-peer-urls: http://$private_ipv4:2380,http://$private_ipv4:7001</span><br><span class="line">    discovery: https://discovery.etcd.io/xxxxxxxxxxxx</span><br><span class="line">  fleet:</span><br><span class="line">    public-ip: &quot;$public_ipv4&quot;</span><br><span class="line">  flannel:</span><br><span class="line">    interface: &quot;$public_ipv4&quot;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>我们这里使用了线上服务 <code>https://discovery.etcd.io/</code> 发现集群中的机器，这个服务同样也可以使用本地内系统。</p>
<h2 id="利用-Etcd-制作服务发现"><a href="#利用-Etcd-制作服务发现" class="headerlink" title="利用 Etcd 制作服务发现"></a>利用 Etcd 制作服务发现</h2><p>之前提到，Etcd 的特性非常方便用做服务发现，具体如何操作呢？在谈具体实现之前，我们来介绍一下两种服务注册方法：一种叫做 <a href="http://microservices.io/patterns/self-registration.html" target="_blank" rel="noopener">自注册方法</a>；另外一种叫 <a href="http://microservices.io/patterns/3rd-party-registration.html" target="_blank" rel="noopener">第三方注册方法</a>。区别是是否由自身来进行健康检查和提醒。另外，服务发现重要的是，在服务失效时可以及时去除无效服务，这个在 Etcd 的 TTL 功能上就会显得比较重要。我们可以设置一个键值的有效期为 3 秒，并且每秒钟都来刷新授权，如果程序异常退出或者刷新不及时，那么这个服务简直就会失效。通过这种方式就可以有效验证服务是否有效。</p>
<p>具体的代码就不再额外给出了，大家可以自己动手实现一下。另外，其实服务发现还有一个重要的是提供自身工作的地址端口信息，这些可以通过环境变量传递到容器的注册过程中去，这个也是能够让负载均衡或者 WebService 服务器可以识别服务的重要手段。比如 Nginx 可以在根据服务注册信息定期更新自己的配置文件，利用重载保证不间断的服务运行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/05/2016-05-28-learning-coreos-part2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/05/2016-05-28-learning-coreos-part2/" class="post-title-link" itemprop="url">CoreOS 折腾笔记（二）Fleet 进阶</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-05-28 18:00:00" itemprop="dateCreated datePublished" datetime="2016-05-28T18:00:00+08:00">2016-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/05/2016-05-28-learning-coreos-part2/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/05/2016-05-28-learning-coreos-part2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果要说什么样子的分布式集群对用户是最友好的，那无疑是对客户来说，像本地执行命令一样方便的执行集群命令肯定是最舒服的了。这个我们在上一节 <a href="http://ipfans.github.io/2016/05/learning-coreos-part1/" target="_blank" rel="noopener">集群部署</a> 里面就提到了一个叫做 “fleetctl” 的命令，这个命令是做什么用的呢？</p>
<h2 id="fleet-是什么"><a href="#fleet-是什么" class="headerlink" title="fleet 是什么"></a>fleet 是什么</h2><p>工具 <figure class="highlight plain"><figcaption><span>是一个在集群层面上的 ```systemd``` 管理工具。它的配置文件语法基于 ```systemd``` 的语法，另外添加了一些自有的属性。如果你希望在集群中运行你的服务，那么使用 ```fleet``` 管理 ```systemd``` 单元是再有必要不过的了。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在比较新的系统 (CentOS 7+、Ubuntu 16+、Debian 8+) 中均采用了 ```systemd``` 作为启动项管理工具。如果你对 ```systemd``` 有疑问的话，请到其 [官方网站](https://www.freedesktop.org/wiki/Software/systemd/) 查看具体的介绍，这里不做赘述。</span><br><span class="line"></span><br><span class="line">之前使用的 ```fleetctl``` 就是 ```fleet``` 的管理工具，默认是在集群中的某台机器上进行管理。当然，```fleetctl``` 同样也可以通过远程进行管理，可以通过如下命令连接远程集群。</span><br></pre></td></tr></table></figure></p>
<p>FLEETCTL_ENDPOINT=http://<a href="IP:[PORT]" target="_blank" rel="noopener">IP:[PORT]</a> fleetctl list-units</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## fleetctl 常见命令</span><br><span class="line"></span><br><span class="line">比较常见的 ```fleetctl``` 命令有：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ fleetctl -h<br>…<br>COMMANDS:<br>    cat                查看已经提交的单元文件内容<br>    destroy            销毁集群中的一个或多个单元<br>    fd-forward        将标准输入输出转向到一个 unix socket 中<br>    journal            将集群中的某个 unit 的日志输出到当前<br>    list-machines    查看集群中的已知机器<br>    list-unit-files    查看集群中存在的单元<br>    list-units        查看集群中的单元状态<br>    load            将一个或多个单元加载到集群中，必要时会先执行 submit 功能<br>    ssh                连接到集群中的某台机器<br>    start            启动集群中一个或多个单元，必要时会先执行 submit 和 load 功能<br>    status            输出集群中一个或多个单元的状态<br>    stop            停止集群中一个或多个单元<br>    submit            上传一个或多个单元到集群中，并不会加载执行<br>    unload            卸载集群中的一个或多个单元</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## fleet 单元文件</span><br><span class="line"></span><br><span class="line">以一个 ```Hello World``` 程序作为演示来讲解：</span><br><span class="line"></span><br><span class="line">```ini</span><br><span class="line">[Unit]</span><br><span class="line">Description=Echo Hello World</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStartPre=-/usr/bin/docker kill busybox</span><br><span class="line">ExecStartPre=-/usr/bin/docker rm busybox</span><br><span class="line">ExecStartPre=/usr/bin/docker pull busybox</span><br><span class="line">ExecStart=/usr/bin/docker run --name busybox busybox /bin/sh -c &quot;trap&apos;exit 0&apos;INT TERM; while true; do echo Hello World; sleep 1; done&quot;</span><br><span class="line">ExecStop=/usr/bin/docker stop busybox</span><br></pre></td></tr></table></figure>

<p>看起来基本与 <figure class="highlight plain"><figcaption><span>语法一致。保存成 ```helloworld.service```，然后执行命令：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>core@core-01 ~ $ fleetctl start helloworld.service<br>Unit helloworld.service inactive<br>Unit helloworld.service launched on 6e1b9fae…/172.17.8.104</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以通过 ```fleetctl``` 查看状态：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ fleetctl list-units<br>UNIT            MACHINE                ACTIVE    SUB<br>helloworld.service    6e1b9fae…/172.17.8.104    active    running<br>core@core-01 ~ $ fleetctl list-unit-files<br>UNIT            HASH    DSTATE        STATE        TARGET<br>helloworld.service    ce68bd4    launched    launched    6e1b9fae…/172.17.8.104</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">同时，可以通过 ```fleetctl journal``` 查看程序是否正常运行了。</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ fleetctl journal helloworld<br>The authenticity of host ‘172.17.8.104’ can’t be established.<br>ECDSA key fingerprint is 11:63:ee:93:e4:b9:5e:06:e9:c6:cd:63:e2:df:ef:9e.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘172.17.8.104’ (ECDSA) to the list of known hosts.<br>– Logs begin at Sat 2016-05-28 08:45:39 UTC, end at Sat 2016-05-28 10:09:13 UTC. –<br>May 28 10:09:04 core-04 docker[1163]: Hello World<br>May 28 10:09:05 core-04 docker[1163]: Hello World<br>May 28 10:09:06 core-04 docker[1163]: Hello World<br>May 28 10:09:07 core-04 docker[1163]: Hello World<br>May 28 10:09:08 core-04 docker[1163]: Hello World<br>May 28 10:09:09 core-04 docker[1163]: Hello World<br>May 28 10:09:10 core-04 docker[1163]: Hello World<br>May 28 10:09:11 core-04 docker[1163]: Hello World<br>May 28 10:09:12 core-04 docker[1163]: Hello World<br>May 28 10:09:13 core-04 docker[1163]: Hello World</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 通过 fleet 单元文件实现高可用服务</span><br><span class="line"></span><br><span class="line">实现高可用服务需要多个服务实例：当其中一个服务实例出现问题时，不会干扰其它服务实例的运行。这里我们还是使用上一节中提到的单元文件，但是需要做额外的修改让其支持多实例运行：</span><br><span class="line"></span><br><span class="line">```ini</span><br><span class="line">[Unit]</span><br><span class="line">Description=Echo Hello World</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStartPre=-/usr/bin/docker kill busybox</span><br><span class="line">ExecStartPre=-/usr/bin/docker rm busybox</span><br><span class="line">ExecStartPre=/usr/bin/docker pull busybox</span><br><span class="line">ExecStart=/usr/bin/docker run --name busybox busybox /bin/sh -c &quot;trap&apos;exit 0&apos;INT TERM; while true; do echo Hello World; sleep 1; done&quot;</span><br><span class="line">ExecStop=/usr/bin/docker stop busybox</span><br><span class="line"></span><br><span class="line">[X-Fleet]</span><br><span class="line">Conflicts=helloworld@*.service</span><br></pre></td></tr></table></figure>

<p>最后新增的内容是 fleet 的专属语法，使用 <figure class="highlight plain"><figcaption><span>可以限定每台机器上仅允许一个 ```helloworld``` 服务运行。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>core@core-01 ~ $ fleetctl stop helloworld<br>Unit helloworld.service loaded on 6e1b9fae…/172.17.8.104<br>core@core-01 ~ $ fleetctl unload helloworld<br>Unit helloworld.service inactive<br>core@core-01 ~ $ mv helloworld.service helloworld@.service<br>core@core-01 ~ $ fleetctl start helloworld@1<br>Unit <a href="mailto:helloworld@1.service" target="_blank" rel="noopener">helloworld@1.service</a> inactive<br>Unit <a href="mailto:helloworld@1.service" target="_blank" rel="noopener">helloworld@1.service</a> launched on 6e1b9fae…/172.17.8.104<br>core@core-01 ~ $ fleetctl start helloworld@2<br>Unit <a href="mailto:helloworld@2.service" target="_blank" rel="noopener">helloworld@2.service</a> inactive<br>Unit <a href="mailto:helloworld@2.service" target="_blank" rel="noopener">helloworld@2.service</a> launched on 91060182…/172.17.8.103<br>core@core-01 ~ $ fleetctl start helloworld@3<br>Unit <a href="mailto:helloworld@3.service" target="_blank" rel="noopener">helloworld@3.service</a> inactive<br>Unit <a href="mailto:helloworld@3.service" target="_blank" rel="noopener">helloworld@3.service</a> launched on af1494a6…/172.17.8.102<br>core@core-01 ~ $ fleetctl start helloworld@4<br>Unit <a href="mailto:helloworld@4.service" target="_blank" rel="noopener">helloworld@4.service</a> inactive<br>Unit <a href="mailto:helloworld@4.service" target="_blank" rel="noopener">helloworld@4.service</a> launched on c99fef8a…/172.17.8.101<br>core@core-01 ~ $ fleetctl list-unit-files<br>UNIT            HASH    DSTATE        STATE        TARGET<br>helloworld.service    ce68bd4    inactive    inactive    -<br><a href="mailto:helloworld@1.service" target="_blank" rel="noopener">helloworld@1.service</a>    ce68bd4    launched    launched    6e1b9fae…/172.17.8.104<br><a href="mailto:helloworld@2.service" target="_blank" rel="noopener">helloworld@2.service</a>    ce68bd4    launched    launched    91060182…/172.17.8.103<br><a href="mailto:helloworld@3.service" target="_blank" rel="noopener">helloworld@3.service</a>    ce68bd4    launched    launched    af1494a6…/172.17.8.102<br><a href="mailto:helloworld@4.service" target="_blank" rel="noopener">helloworld@4.service</a>    ce68bd4    launched    launched    c99fef8a…/172.17.8.101<br>```</p>
<p>卸载之前的 <code>helloworld</code>，执行了新的 4 个实例，通过观察可以看到目前实例都是运行在了 4 台不同机器上。</p>
<h1 id="fleet-的一些疑问"><a href="#fleet-的一些疑问" class="headerlink" title="fleet 的一些疑问"></a>fleet 的一些疑问</h1><p>事实上，通过 fleet，可以将服务进行多副本部署，同时通过 fleet 守护程序的正常运行。但是在实际使用中你会发现有一个实际问题，在微服务化场景中，每个服务部署的机器是无法控制的，那么我们怎么知道服务究竟在哪呢？</p>
<p>如何控制流量流向，或者说服务发现问题，这个我会在下一个 <code>Etcd</code> 的介绍中说一下，敬请期待。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/05/2016-05-28-learning-coreos-part1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/05/2016-05-28-learning-coreos-part1/" class="post-title-link" itemprop="url">CoreOS 折腾笔记（一）集群部署</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-05-28 17:00:00" itemprop="dateCreated datePublished" datetime="2016-05-28T17:00:00+08:00">2016-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/05/2016-05-28-learning-coreos-part1/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/05/2016-05-28-learning-coreos-part1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近在技改完成之后打算进行大量的微服务化改造，而方便进行微服务化的步骤之一，就是将现有的系统移植进入 Docker 环境之中。在标准容器系统的选择上，我把目光放在了 CoreOS 上。实际上，我在 CoreOS 版本还是 2 开头的时候就有简单研究过，但是当时主要作为研究 Docker 的途径，现在则是作为集群化部署的基准系统。从本文开始的一系列折腾则是我在研究 CoreOS 集群化使用的一些纪录，而本文就是介绍一个本地实现容器化机群的步骤。</p>
<h2 id="安装-Vagrant"><a href="#安装-Vagrant" class="headerlink" title="安装 Vagrant"></a>安装 Vagrant</h2><p>略，因为太简单了。另外还需要 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 配置 CoreOS-vagrant</span><br><span class="line"></span><br><span class="line">执行以下命令：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">git clone https://github.com/coreos/coreos-vagrant.git</span><br><span class="line">cd coreos-vagrant</span><br></pre></td></tr></table></figure></p>
<p>下载 CoreOS 的 vagrant 配置。值得在进入正式配置之前一提的是，CoreOS 本身是没有默认密码或者安装密码机制的，也就是说，现有的所有认证登录需要通过 SSH 进行。如果是通过 vagrant 安装，会自动生成登录需要的 SSH 密钥，这个是需要额外注意的内容。</p>
<p>首先，将仓库中提供的两个模版配置文件复制成正式，接下来需要修改对应的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp config.rb.sample config.rb</span><br><span class="line">cp user-data.sample user-data</span><br></pre></td></tr></table></figure>

<p>首先修改 <figure class="highlight plain"><figcaption><span>文件。这里重点是两个参数，一个是启动的实例数量，另外一个是升级的版本，我修改成了</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```ruby</span><br><span class="line">$num_instances=4</span><br><span class="line">$update_channel=&apos;stable&apos;</span><br></pre></td></tr></table></figure></p>
<p>启动 4 个实例，升级选择的版本则是月度升级版。另外一个 <figure class="highlight plain"><figcaption><span>暂时不作修改。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接下来执行：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">vagrant up</span><br></pre></td></tr></table></figure></p>
<p>在一堆输出之后，生成的 4 个实例就已经在运行了。也可以通过命令 <figure class="highlight plain"><figcaption><span>status``` 查看运行状态。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>➜  coreos-vagrant git:(master) vagrant status<br>Current machine states:</p>
<p>core-01                   running (virtualbox)<br>core-02                   running (virtualbox)<br>core-03                   running (virtualbox)<br>core-04                   running (virtualbox)</p>
<p>This environment represents multiple VMs. The VMs are all listed<br>above with their current state. For more information about a specific<br>VM, run <code>vagrant status NAME</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接下来需要把 SSH 密钥添加到 SSH 可以识别的路径中，当然，也可以使用 ```ssh -i``` 每次指定 key。</span><br></pre></td></tr></table></figure>

<p>➜  coreos-vagrant git:(master) ssh-add ~/.vagrant.d/insecure_private_key<br>Identity added: /Users/user/.vagrant.d/insecure_private_key (/Users/user/.vagrant.d/insecure_private_key)<br>➜  coreos-vagrant git:(master) vagrant ssh core-01 – -A<br>CoreOS stable (1010.5.0)<br>core@core-01 ~ $</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里的 ```-- -A``` 前两的个横杆表示 ssh 参数的起始。之后的 ```-A``` 是标准的 SSH 命令参数，表示将主机的 SSH 秘钥传递到虚拟机里面，这样做是为了之后的涉及 SSH 操作更加方便，否则会在某些命令时报错。</span><br><span class="line"></span><br><span class="line">进入 CoreOS 之后，就可以查看现在集群中的机器，可以通过如下命令：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ fleetctl list-machines<br>MACHINE        IP        METADATA<br>6e1b9fae…    172.17.8.104    -<br>91060182…    172.17.8.103    -<br>af1494a6…    172.17.8.102    -<br>c99fef8a…    172.17.8.101    -</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查看设备是否正常加入。当然，也可以很方便的登录其它系统：</span><br></pre></td></tr></table></figure>

<p>core@core-01 ~ $ fleetctl ssh -machine af1494a6<br>The authenticity of host ‘172.17.8.102’ can’t be established.<br>ECDSA key fingerprint is 24:34:be:4e:b7:43:be:94:34:33:b2:81:e0:0c:08:9d.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘172.17.8.102’ (ECDSA) to the list of known hosts.<br>CoreOS stable (1010.5.0)<br>core@core-02 ~ $ exit<br>logout<br>```</p>
<p>这样我们的第一步，使用 CoreOS 部署本地集群就已经实现了。</p>
<p>最后，如果需要关闭这些 CoreOS 实例，可以通过 <code>vagrant halt</code> 停止所有，下次可以通过 <code>vagrant up</code> 就可以重新启动了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/04/2016-04-26-docker-for-mac-beta/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/04/2016-04-26-docker-for-mac-beta/" class="post-title-link" itemprop="url">Docker for Mac 尝鲜</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-04-26 18:00:00" itemprop="dateCreated datePublished" datetime="2016-04-26T18:00:00+08:00">2016-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/04/2016-04-26-docker-for-mac-beta/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/04/2016-04-26-docker-for-mac-beta/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前作为 <figure class="highlight docker"><figcaption><span>beta``` 的第一批用户获得了 beta 的授权，但是因为邮件进了垃圾邮件，所以一直没有发现。今天给 Docker 发邮件申请 beta 测试才知道已经通过了，赶紧尝鲜起来。如果你没有权限，可以尝试到 [Docker Beta](https://beta.docker.com) 申请测试资格。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__测试版本可能存在风险，请自行判断。__</span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装之前</span></span><br><span class="line"></span><br><span class="line">Docker for Mac 需要一些前置要求，官方文档提供的数据如下：</span><br><span class="line"></span><br><span class="line">* <span class="number">2010</span> 年之后的 Intel Mac 机型，支持 ```MMU(Memory Management Unit)``` 虚拟化、```EPT(Extended Page Table)``` 等特性</span><br><span class="line">* ```OSX <span class="number">10.10</span>.<span class="number">3</span>``` 以上系统</span><br><span class="line">* 至少 ```<span class="number">4</span>GB``` 内存</span><br><span class="line">* ```VirtualBox <span class="number">4</span>.x``` 与 ```Docker for Mac``` 冲突，因此如果你安装这个系列的 ```Virtualbox``` 需要卸载。</span><br><span class="line"></span><br><span class="line">如果之前装过 ```Docker Toolbox``` 的话，需要一些额外的操作去与 ```Docker Toolbox``` 兼容。（我选择了直接卸载现有的 ```Docker Toolbox```。XD ）</span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装 Docker for Mac</span></span><br><span class="line"></span><br><span class="line">```Docker for Mac``` 是一个 <span class="number">98.3</span>M(Mac 显示为 <span class="number">103.1</span>MB) 的 DMG 文件，下载下来之后双击文件，将鲸鱼拖拽到 ```Applications``` 文件夹中即可。</span><br><span class="line"></span><br><span class="line">![Docker drag](http://ww1.sinaimg.cn/mw690/<span class="number">69</span>e37fdbgw1f3a9ba0ex5j20n40ck75x.jpg)</span><br><span class="line"></span><br><span class="line">第一次打开 ```Docker for Mac``` 需要提供邀请码，同时需要特殊权限写入 ```Docker bin``` 文件。</span><br><span class="line"></span><br><span class="line">![](http://ww3.sinaimg.cn/mw690/<span class="number">69</span>e37fdbgw1f3a9afjankj20g809s0uj.jpg)</span><br><span class="line"></span><br><span class="line">```Docker for Mac``` 包含了 ```Docker``` 引擎，```Docker``` 命令行客户端，```Docker Compose``` 和 ```Docker Machine```。之后双击应用程序中的 ```Docker``` 就可以启用引擎，这时，右上角会有一个鲸鱼的标志。</span><br><span class="line"></span><br><span class="line">![](http://ww2.sinaimg.cn/mw690/<span class="number">69</span>e37fdbgw1f3a9bckt09j20aj020q2x.jpg)</span><br><span class="line"></span><br><span class="line">点击标记可以获得菜单，进行设置，查看日志等等信息。</span><br><span class="line"></span><br><span class="line">![](http://ww3.sinaimg.cn/mw690/<span class="number">69</span>e37fdbgw1f3a9bb23nlj206906e74i.jpg)</span><br><span class="line"></span><br><span class="line">点击检查更新可以验证当前是否为最新版本的 ```Docker for Mac```。</span><br><span class="line"></span><br><span class="line">![](http://ww2.sinaimg.cn/mw690/<span class="number">69</span>e37fdbgw1f3a9feab6kj20hf07tdhe.jpg)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Docker for mac 尝鲜</span></span><br><span class="line"></span><br><span class="line">先看一下 ```Docker``` 的设置，可以设置使用的内存启用方式，是否启用 ```VPN``` 兼容模式 (现在我看论坛有人提到会不兼容 ```Cisco AnyConnect```)，禁用 VM 的时光机备份功能。另外可以在这里提供了直接卸载按钮，不想用的时候也比较方便。</span><br><span class="line"></span><br><span class="line">![](http://ww3.sinaimg.cn/mw690/<span class="number">69</span>e37fdbgw1f3aazp4etzj20e40erq4d.jpg)</span><br><span class="line"></span><br><span class="line">附带的软件版本也是新的 Docker 软件：</span><br><span class="line"></span><br><span class="line">```batch</span><br><span class="line">➜  ~ docker -v</span><br><span class="line">Docker version <span class="number">1.11</span>.<span class="number">0</span>, build <span class="number">4</span>dc5990</span><br><span class="line">➜  ~ docker-compose --version</span><br><span class="line">docker-compose version <span class="number">1.7</span>.<span class="number">0</span>, build <span class="number">0</span>d7bf73</span><br><span class="line">➜  ~ docker-machine --version</span><br><span class="line">docker-machine version <span class="number">0.7</span>.<span class="number">0</span>, build a650a40</span><br></pre></td></tr></table></figure></p>
<p>跑一个 Ubuntu 测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker run -i -t --name ubuntu ubuntu:16.04 /bin/bash</span><br><span class="line">root@d5ceb77516bf:/# uname -a</span><br><span class="line">Linux d5ceb77516bf 4.4.6 #1 SMP Mon Apr 18 19:18:15 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line">root@d5ceb77516bf:/#</span><br></pre></td></tr></table></figure>

<p>我发现一直不怎么会写结尾／结论，那么最后扯个蛋：我们在进行 <code>Docker</code> 在 <code>CI/CD</code>、线上环境中的应用摸索，如果你有兴趣交流，欢迎联系 <code>kevin &lt;at&gt; yeeuu &lt;dot&gt; com</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/04/2016-04-18-writing-testable-golang-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/04/2016-04-18-writing-testable-golang-code/" class="post-title-link" itemprop="url">编写测试友好的 Golang 代码</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-04-18 18:40:00" itemprop="dateCreated datePublished" datetime="2016-04-18T18:40:00+08:00">2016-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/04/2016-04-18-writing-testable-golang-code/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/04/2016-04-18-writing-testable-golang-code/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目前我们有大量的应用采用了 Golang 程序进行构建，但是在执行研发流程里我们会发现一些来自于静态编译程序的不便：相对于我们之前使用的 Python 语言程序而言，我们无法在程序功能的单元测试里大量的使用 Mock 方式来进行高效测试。</p>
<p>而这些东西往往可以在开发人员编写单元测试用例时有效的节省时间和一些额外的环境准备成本。因此，这也给我们的程序的单元覆盖率带来了很多麻烦的地方：一些依赖于额外验证和表现的情况或者小几率出现的情况需要复杂的模拟步骤，对开发进度和效率带来了一些额外的影响。如何编写一个测试友好的 Golang 程序成为一个无法绕开的问题。</p>
<h2 id="从动态语言到静态语言"><a href="#从动态语言到静态语言" class="headerlink" title="从动态语言到静态语言"></a>从动态语言到静态语言</h2><p>动态语言有良好的运行时修改属性，在运行时的动态修改函数，可以进行有效的 Mock。比如在 <figure class="highlight plain"><figcaption><span>3 为例，内置了 unittest.mock 标准库）程序中:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">with patch.object(ProductionClass,&apos;method&apos;, return_value=None) as mock_method:</span><br><span class="line">    thing = ProductionClass()</span><br><span class="line">    thing.method(1, 2, 3)</span><br></pre></td></tr></table></figure></p>
<p>自然而然的，我们想到了这样的用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imp = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFunc</span><span class="params">(t *testing.T)</span></span> &#123;<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(org <span class="keyword">func</span>()</span> <span class="title">bool</span>)</span> &#123;imp = org&#125;(imp)</span><br><span class="line">	</span><br><span class="line">	img = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line">	<span class="comment">// testing or something else...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样实现 Mock 是完全可以的，但是实际上会带来一些额外的问题，比如说在 MVC 框架中，我们正常采用的方式一般是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (<span class="string">"models"</span></span><br><span class="line">	...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(ctx Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	data := models.Data()</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式则是无法在运行中进行动态 Mock 的，除非将其转换为参数方式进行调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFunc</span><span class="params">(t *testing.T)</span></span> &#123;Convey(<span class="string">"test"</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(org <span class="keyword">func</span>()</span> <span class="title">string</span>)</span> &#123;models.Data = org  <span class="comment">// Error: cannot assign to models.Data&#125;(models.Data)</span></span><br><span class="line"></span><br><span class="line">		models.Data = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;<span class="keyword">return</span><span class="string">"mocked!"</span>&#125;</span><br><span class="line">		</span><br><span class="line">		....</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var data = models.Data</span></span><br><span class="line"><span class="comment">// in A: data := data()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFunc</span><span class="params">(t *testing.T)</span></span> &#123;Convey(<span class="string">"test"</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(org <span class="keyword">func</span>()</span> <span class="title">string</span>)</span> &#123;data = org&#125;(data)</span><br><span class="line"></span><br><span class="line">		data = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;<span class="keyword">return</span><span class="string">"mocked!"</span>&#125;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写法略微会多处大量的临时函数指针变量，如果是使用这种方式则需要额外的变量值的对应关系，测试完成后变量值需要恢复成原有指针（如果需要测试正常功能）。</p>
<h2 id="从变量到接口"><a href="#从变量到接口" class="headerlink" title="从变量到接口"></a>从变量到接口</h2><p>除了上面介绍的方法以外，是不是还有看起来稍微优雅一点的测试方法呢？我们尝试将上面的函数形式换成下面的接口形式，将 interface 对应的变量作为全局变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">var</span> fetcher DataFetcherInterface</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DataFetcherInterface <span class="keyword">interface</span> &#123;Data() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DataFetcher <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d DataFetcher)</span> <span class="title">Data</span><span class="params">()</span> <span class="title">string</span></span> &#123;<span class="keyword">return</span><span class="string">"hello world!"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;fmt.Fprintf(w,<span class="string">"%s"</span>, fetcher.Data())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;fetcher = DataFetcher&#123;&#125;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, Func)</span><br><span class="line">	http.ListenAndServe(<span class="string">"127.0.0.1:12821"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话我们就可以在测试文件里面定义一个 FakeDataFetcher，实现相关的功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main_test.go</span></span><br><span class="line"><span class="keyword">type</span> FakeDataFetcher <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FakeDataFetcher)</span> <span class="title">Data</span><span class="params">()</span> <span class="title">string</span></span> &#123;<span class="keyword">return</span><span class="string">"mocked!"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFunc</span><span class="params">(t *testing.T)</span></span> &#123;Convey(<span class="string">"test"</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(org DataFetcherInterface)</span></span> &#123;fetcher = org&#125;(fetcher)</span><br><span class="line"></span><br><span class="line">		fetcher = FakeDataFetcher&#123;&#125;</span><br><span class="line"></span><br><span class="line">		req, _ := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://example.com/"</span>, <span class="literal">nil</span>)</span><br><span class="line">		w := httptest.NewRecorder()</span><br><span class="line">		Func(w, req)</span><br><span class="line">		So(w.Body.String(), ShouldEqual, <span class="string">"mocked!"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以减少变量的生成个数，同时，也可以通过 <figure class="highlight plain"><figcaption><span>传入不同的参数，实现不同的 Faker 测试。值得注意的是，在这个 interface 方法中需要特别注意变量共享的线程安全问题。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 依赖注入</span><br><span class="line"></span><br><span class="line">上面两种方法似乎思路类似，除了这些方案之外，还有没有其他的方案呢？最后介绍一下依赖注入的方式，这种方式也可以与上面提到的接口方式搭配使用。这种方式实现起来比较简单方便，也非常适合利用在一些面向过程场景中。</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">// main.go</span><br><span class="line">type EchoInterface interface &#123;Echo() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Echoer struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e Echoer) Echo() string &#123;return&quot;hello world!&quot;&#125;</span><br><span class="line"></span><br><span class="line">func Echo(e EchoInterface) string &#123;return e.Echo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;provider := Echoer&#123;&#125;</span><br><span class="line">	fmt.Println(Echo(provider))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试文件:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main_test.go</span></span><br><span class="line"><span class="keyword">type</span> FakeEchoer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FakeEchoer)</span> <span class="title">Echo</span><span class="params">()</span> <span class="title">string</span></span> &#123;<span class="keyword">return</span><span class="string">"mocked!"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFunc</span><span class="params">(t *testing.T)</span></span> &#123;Convey(<span class="string">"test"</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;provider := FakeEchoer&#123;&#125;</span><br><span class="line">		So(Echo(provider), ShouldEqual, <span class="string">"mocked!"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的几种测试方法基本上是通过固定的原型将代码转为测试友好的 Golang 代码。这样可以通过 Mock，减少来自于其他数据和前置条件的影响，尽可能的降低代码开发的附加成本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/02/2016-02-03-simple-implement-asyncio-to-understand-how-async-works/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/02/2016-02-03-simple-implement-asyncio-to-understand-how-async-works/" class="post-title-link" itemprop="url">从 asyncio 简单实现看异步是如何工作的</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-02-03 15:40:00" itemprop="dateCreated datePublished" datetime="2016-02-03T15:40:00+08:00">2016-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/02/2016-02-03-simple-implement-asyncio-to-understand-how-async-works/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/02/2016-02-03-simple-implement-asyncio-to-understand-how-async-works/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从 asyncio 简单实现看异步是如何工作的</p>
<p>by ipfans</p>
<p>注：请使用 <code>Python 3.5+</code> 版本运行以下代码。</p>
<h2 id="先从例子看起"><a href="#先从例子看起" class="headerlink" title="先从例子看起"></a>先从例子看起</h2><p>首先我们来看一个 socket 通讯的例子，这个例子我们可以在官方 <code>socket</code> 模块的文档中找到部分原型代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo.py</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *  <span class="comment"># 是的，这是一个不好的写法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_server</span><span class="params">(address)</span>:</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = sock.accept()</span><br><span class="line">        print(<span class="string">"connect from"</span>, addr)</span><br><span class="line">        echo_handler(client)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_handler</span><span class="params">(client)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = client.recv(<span class="number">10000</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        client.send(str.encode(<span class="string">"Got: "</span>) + data)</span><br><span class="line">    print(<span class="string">"connection closed."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    echo_server((<span class="string">''</span>, <span class="number">25000</span>))</span><br></pre></td></tr></table></figure>

<p>但是同步模式会有一个问题，当进行通讯是阻塞的，当一个连接占用时就会阻碍其他连接的继续，这个时候应该怎么更快的运行呢？</p>
<h2 id="回顾历史"><a href="#回顾历史" class="headerlink" title="回顾历史"></a>回顾历史</h2><p>在 asyncio 出现之前，我们都是怎么提高效率的呢？首先想到的方法就是多线程处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo_thread.py</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_server</span><span class="params">(address)</span>:</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = sock.accept()</span><br><span class="line">        print(<span class="string">"connect from"</span>, addr)</span><br><span class="line">        _thread.start_new_thread(echo_handler, (client,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_handler</span><span class="params">(client)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = client.recv(<span class="number">10000</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        client.send(str.encode(<span class="string">"Got: "</span>) + data)</span><br><span class="line">    print(<span class="string">"connection closed."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    echo_server((<span class="string">''</span>, <span class="number">25000</span>))</span><br></pre></td></tr></table></figure>

<p>当然了，我们都知道多线程之下总是会有一些问题的。那么还有更好的方案吗？如果你了解过<a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">C10k 问题</a>，你一定听过 `epoll<figure class="highlight plain"><figcaption><span>之类的大名。那么，能在 Python 中使用这些功能吗？答案是肯定的。那就是[```select```](https://docs.python.org/3.5/library/select.html)。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line"># echo_select.py</span><br><span class="line">from socket import *</span><br><span class="line">import select</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def echo_server(address):</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    sock.listen(5)</span><br><span class="line">    input = [sock,]</span><br><span class="line">    while True:</span><br><span class="line">        r, _, _ = select.select(input, [], [])</span><br><span class="line">        for s in r:</span><br><span class="line">            if s == sock:</span><br><span class="line">                client, addr = sock.accept()</span><br><span class="line">                print(&quot;connect from&quot;, addr)</span><br><span class="line">                echo_handler(client)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def echo_handler(client):</span><br><span class="line">    while True:</span><br><span class="line">        data = client.recv(10000)</span><br><span class="line">        if not data:</span><br><span class="line">            break</span><br><span class="line">        client.send(str.encode(&quot;Got: &quot;) + data)</span><br><span class="line">    print(&quot;connection closed.&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    echo_server((&apos;&apos;, 25000))</span><br></pre></td></tr></table></figure></p>
<p>相比 <code>_thread</code> 来说，<code>select</code> 更加底层，提供了最基础的等待 IO 完成功能。但是缺点是这个功能太单一了，这也就是为什么后面语言提供了 `asyncio<figure class="highlight plain"><figcaption><span>`python-dev` 中 [提出了](https://mail.python.org/pipermail/python-ideas/2012-May/015223.html) 要在标准库中添加基于 `select` 的异步 IO 功能。之后 Python 在 3.4 版本之中就加入了 [```selectors `](https://docs.python.org/3.5/library/selectors.html) 与 [```asyncio```](https://docs.python.org/3.5/library/asyncio.html) 库用于异步 IO。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其他的方法还有 `gevent`、`Twisted`、`Tornado` 等等的方案，这里就不多赘述了。(在 3.4 的时候我一直觉得 `yield form` 太丑陋了，相对我宁愿继续用 `Tornado` 的 `yield` 方式。当然这个更加主观的原因吧，不过现在 `async/await` 方式明显让我又让我爱上了。）</span><br><span class="line"></span><br><span class="line">## 从同步到 asyncio</span><br><span class="line"></span><br><span class="line">那么如何在 asyncio 框架下如何实现异步 socket 通讯的例子呢？事实上官方文档中提供了两个比较高层封装过的 asyncio 库例子 [TCP echo server protocol](https://docs.python.org/3.5/library/asyncio-protocol.html#tcp-echo-server-protocol) 和[TCP echo server using streams](https://docs.python.org/3.5/library/asyncio-stream.html#tcp-echo-server-using-streams)。这两个例子采用的是 `asyncio` 的 `socket` 通讯高级别封装，似乎与我们同步代码相差有点远。这里我们实际例子中使用了更加底层的[Low-level socket operations](https://docs.python.org/3.5/library/asyncio-eventloop.html#low-level-socket-operations)。这个更接近于我们在同步状态下使用 `socket` 的代码。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"># aecho.py</span><br><span class="line">from socket import *</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def echo_server(address):</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    sock.listen(5)</span><br><span class="line">    sock.setblocking(False) # 设置非阻塞</span><br><span class="line">    while True:</span><br><span class="line">        client, addr = await loop.sock_accept(sock)</span><br><span class="line">        print(&quot;connect from&quot;, addr)</span><br><span class="line">        loop.create_task(echo_handler(client))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def echo_handler(client):</span><br><span class="line">    with client:</span><br><span class="line">        while True:</span><br><span class="line">            data = await loop.sock_recv(client, 10000)</span><br><span class="line">            if not data:</span><br><span class="line">                break</span><br><span class="line">            await loop.sock_sendall(client, str.encode(&quot;Got: &quot;) + data)</span><br><span class="line">    print(&quot;connection closed&quot;)</span><br><span class="line"></span><br><span class="line">loop.create_task(echo_server((&apos;&apos;, 25000)))</span><br><span class="line">loop.run_forever()</span><br></pre></td></tr></table></figure></p>
<p>其中遇到的 <code>create_task</code> 会相对同步状态下无法对应，这个方法用于安排一个异步任务的执行，将一个异步方法封装为 <code>future</code> 对象。其他的 <code>Event Loop</code> 中的功能基本与传统的程序相同。</p>
<h2 id="从-asyncio-到自己的实现"><a href="#从-asyncio-到自己的实现" class="headerlink" title="从 asyncio 到自己的实现"></a>从 asyncio 到自己的实现</h2><p>那么在 <code>asyncio.event_loop</code> 中到底发生了什么呢？我们可以尝试用自己的程序实现一下。</p>
<p>如果你阅读过<a href="https://www.python.org/dev/peps/pep-0492/" target="_blank" rel="noopener">PEP-0492</a>，你就知道，实际上 Python 的协程是通过生成器实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># async_yield.py</span></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_wait</span><span class="params">(sock)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"read_wait"</span>, sock  <span class="comment"># 为什么有个 read_wait？等下介绍</span></span><br></pre></td></tr></table></figure>

<p>下面来模拟实际调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">python -i async_yield.py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = read_wait(<span class="string">"somesocket"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;generator object read_wait at <span class="number">0x10200d5c8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.send(<span class="literal">None</span>)</span><br><span class="line">(<span class="string">'read_wait'</span>, <span class="string">'somesocket'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.send(<span class="literal">None</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>如果不了解 <code>send()</code> 与 <code>StopIteration</code> 作用的话，请参考 <code>PEP-0492</code> 中相关的描述。</p>
<p>接下来继续完善 <code>write</code> 方法，并且实现我们自己的 <code>Loop</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># async_yield.py</span></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector, EVENT_READ, EVENT_WRITE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_wait</span><span class="params">(sock)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"read_wait"</span>, sock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_wait</span><span class="params">(sock)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"write_wait"</span>, sock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loop</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ready = deque()</span><br><span class="line">        self.selector = DefaultSelector()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">sock_recv</span><span class="params">(self, sock, maxbytes)</span>:</span></span><br><span class="line">        <span class="keyword">await</span> read_wait(sock)</span><br><span class="line">        <span class="keyword">return</span> sock.recv(maxbytes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">sock_accept</span><span class="params">(self, sock)</span>:</span></span><br><span class="line">        <span class="keyword">await</span> read_wait(sock)</span><br><span class="line">        <span class="keyword">return</span> sock.accept()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">sock_sendall</span><span class="params">(self, sock, data)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> data:</span><br><span class="line">            <span class="keyword">await</span> write_wait(sock)</span><br><span class="line">            n = sock.send(data)</span><br><span class="line">            data = data[n:]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_task</span><span class="params">(self, coro)</span>:</span></span><br><span class="line">        self.ready.append(coro)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_forever</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.ready:</span><br><span class="line">                events = self.selector.select()</span><br><span class="line">                <span class="keyword">for</span> key, _ <span class="keyword">in</span> events:</span><br><span class="line">                    self.ready.append(key.data)</span><br><span class="line">                    self.selector.unregister(key.fileobj)</span><br><span class="line">            <span class="keyword">while</span> self.ready:</span><br><span class="line">                self.current_task = self.ready.popleft()</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    op, *args = self.current_task.send(<span class="literal">None</span>)</span><br><span class="line">                    getattr(self, op)(*args)</span><br><span class="line">                <span class="keyword">except</span> StopIteration:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_wait</span><span class="params">(self, sock)</span>:</span></span><br><span class="line">        self.selector.register(sock, EVENT_READ, self.current_task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_wait</span><span class="params">(self, sock)</span>:</span></span><br><span class="line">        self.selector.register(sock, EVENT_WRITE, self.current_task)</span><br></pre></td></tr></table></figure>

<p>对于之前一节中的 <code>aecho.py</code> 文件，我们只需要修改一下导入模块与 loop 的获取方法即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pecho.py</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> async_yield</span><br><span class="line"></span><br><span class="line">loop = async_yield.Loop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">echo_server</span><span class="params">(address)</span>:</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    sock.setblocking(<span class="literal">False</span>)  <span class="comment"># 设置非阻塞模式</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = <span class="keyword">await</span> loop.sock_accept(sock)</span><br><span class="line">        print(<span class="string">"connect from"</span>, addr)</span><br><span class="line">        loop.create_task(echo_handler(client))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">echo_handler</span><span class="params">(client)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> client:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = <span class="keyword">await</span> loop.sock_recv(client, <span class="number">10000</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">await</span> loop.sock_sendall(client, str.encode(<span class="string">"Got: "</span>) + data)</span><br><span class="line">    print(<span class="string">"connection closed"</span>)</span><br><span class="line"></span><br><span class="line">loop.create_task(echo_server((<span class="string">''</span>, <span class="number">25000</span>)))</span><br><span class="line">loop.run_forever()</span><br></pre></td></tr></table></figure>

<h2 id="async-yield-发生了什么？"><a href="#async-yield-发生了什么？" class="headerlink" title="async_yield 发生了什么？"></a>async_yield 发生了什么？</h2><p>首先，我们定义了两个协程函数 <code>read_wait</code> 和 <code>write_wait</code>，分别用于相应处理读取操作与写入操作。其中返回了一个 tuple 类型数据，用于在 <code>op, *args = self.current_task.send(None)</code> 中填充方法名和参数，之后在 <code>getattr(self, op)(*args)</code> 中进行分别调用。</p>
<p>下面 <code>Loop</code> 类实现了在 pecho 中用到的所有异步函数。初始化时的 <code>self.ready</code> 用于存储协程的调用序列。该序列通过 <code>create_task</code> 添加协程到队列中。</p>
<p>在 <code>run_forever</code> 中，如果目前队列为空，则通过 <code>self.selector.select()</code> 提取一个事件放入队列处理，若队列存在通过 <code>self.current_task.send(None)</code> 通知事件发送，从而调用对应的事件功能。你也可以在 <code>op, *args = self.current_task.send(None)</code> 后添加 <code>print(op)</code> 获取实时的调用情况。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>事实上这篇文章的思路是基于 <a href="https://twitter.com/dabeaz" target="_blank" rel="noopener">@dabeaz</a> 在 <code>Python Brasil</code> 上的 <a href="https://www.youtube.com/watch?v=ZzfHjytDceU" target="_blank" rel="noopener">keynote</a> 整理而来。dabeaz 还有另外一个非常不错的基于 select 的异步库，名字叫做<a href="https://github.com/dabeaz/curio" target="_blank" rel="noopener">curio</a>，是一个了解实现异步库的很好教程。</p>
<p>最后讲个段子，之前有人开玩笑，蟒爹开发一个功能，之后大家都不会正确使用，直到 dabeaz 站出来告诉大家如何正确使用新功能。在写这篇文章的时候虽然很想找出来出处，但是似乎找不到了…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/01/2016-01-27-startup-architecture-language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/01/2016-01-27-startup-architecture-language/" class="post-title-link" itemprop="url">聊聊初创公司的后端语言选型 (小众语言)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-01-27 09:48:00" itemprop="dateCreated datePublished" datetime="2016-01-27T09:48:00+08:00">2016-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/01/2016-01-27-startup-architecture-language/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/01/2016-01-27-startup-architecture-language/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在创业公司初创伊始，如何选择合适的语言决定了产品后续的技术栈和如何进行合理的业务支撑方向。如果你在读这篇文章之前，更倾向于选择 Java/C#/PHP 常见语言技术栈，我觉得对于你而言，这篇文章帮助不大。因为对你而言，这些技术栈意味着更加方便招人，更方便的故障处理资料等等。但是如果一个初创公司想要选择合理的小众语言技术栈，我想这篇文章对你也许有一些帮助。</p>
<p>在文章开始之前，我觉得有必要描述一下所谓的小众语言，这里我在最初进行技术选型时，考察了包括：</p>
<ul>
<li>Python: 你可能在接触爬虫、大数据分析等等方面听过 Python 的大名，大家都知道 Pythonista 都习惯说的一句话就是：人生苦短，我用 Python。</li>
<li>Ruby: 你如果做过 Web 框架，你遇到最多的是很多人都会提到 RoR 框架。用过之后只有一个惊叹了。</li>
<li>JavaScript（Nodejs）: 有没有听过 JavaScript 全栈工程师？有没有听过 JavaScript 全栈工程师？有没有听过 JavaScript 全栈工程师？</li>
<li>Golang: 简单粗暴的语言，也许你见过很多人跟你吹嘘，Golang 是下一代的云计算开发语言。</li>
</ul>
<p>其他语言太过于小众，考虑语言的应用很多需要得到更多的社区支持，目前不在考虑的范畴内。</p>
<h2 id="小众语言的劣势"><a href="#小众语言的劣势" class="headerlink" title="小众语言的劣势"></a>小众语言的劣势</h2><p>正所谓知己知彼百战不殆，在了解一个技术选型之前，最好是研究这些语言的缺点。因为你最后感觉这个技术选型不适合你的时候，根本的原因是这些劣势影响了你。</p>
<p>在上面提到的几个语言中，Python、Ruby、JavaScript 是属于动态语言。关于动态语言的争议最大的地方是：动态语言到底是否合适进行大型项目。事实上，在某些阶段，多人合作，并且大家水平语言不同时，这个时候通常会有这样的问题：团队需要花更多的时间在确保动态语言的准确性上。对于一个项目有高可用、低错误率的要求时，由于语言的动态特性，就需要对程序开发时的单元测试和后期集成测试的要求更高。因为变量在运行时才会赋予类型含义，所以很难在静态检测过程中发现足够多的问题。这样对测试人员的压力也会更大，当你没有合适的测试人员时，这个时候通常会变成，你只覆盖测试了理想情况下的成功失败情况，而对特别异常情况缺少评估。</p>
<p>Python、Ruby 语法对程序员而言最大的成本在于需要重新学习一门新的语言。这个学习成本、时间成本通常对初创公司而言通常是支付不起的，哪怕像这些比较容易学习的动态语言而言。另外一个值得一提的是，无论是 Python 还是 Ruby，从长远看，如果你后续有较大的用户增长又需要保证用户体验时，Python、Ruby 的执行效率和吞吐量会有较大的影响。</p>
<p>Python 和程序员入门的语言差距较大：用 4 个空格表述程序缩进。这意味着，程序员直接从网上寻找解决方案（拷贝代码）时成本更高，因为很有可能他需要手工进行代码格式化，这样有可能造成程序逻辑的改变。另外一个不得不提的是一些 Python 库看似好用，实际上或多或少有有一些坑，这对新手而言，往往是致命的。对应的，Ruby 语言本身时不存在这些问题的。然而 Ruby 作为开发主语言时最大的问题是，如果选择 RoR 框架作为初始的 Web 框架时，如果没有一个熟悉 RoR 框架的人，那么学习修改 RoR 框架的成本是特别高的：对于一个通用型框架而言，你可能需要更多的特殊场景定制，这可能需要做大量的猴子补丁，如果不对框架有一个清晰了解时，这样的成本会更高。</p>
<p>JavaScript（后面统一用 Nodejs 代称）则借助 Nodejs 实现了高性能和较大吞吐量。而且从语言层面上，JavaScript 对很多程序员并不陌生。然而，在过去的很长时间，真正熟练掌握 JavaScript 的都是前端工程师，这是一个非常尴尬的问题。对后端工程师而言，Nodejs 需要与前端不同的技术栈，而且大概没有公司希望一个完全没有任何后端经验的前端工程师去接手后端项目的开发的。Nodejs 是一个年轻的语言，年轻必然会伴随一些问题，比如，库比较少（当然现在也是井喷期）。一些必要的库需要慢慢寻找。事实上，我也不得不吐槽，可能是开发者水平问题，导致很多 npm 提供的包，往往或多或少存在一些比较恼人的 BUG，这些 BUG 可能会在你开发过程中，正常运行中出现，而你却不得不干掉它。对于这种 BUG，很多时候更快的处理方式是你自己动手进行快速修复。然而当你的程序员不具备这种能力的时候，就需要提一个 issue 到开发者，由开发者进行修复，并且需要等待版本更新到 npm 源中。很多时候这个过程都是比较尴尬的，尤其是你选择了一个开发者并不是特别活跃的包。</p>
<p>Golang 是一个编译型语言，语法简单，似乎一切看起来都是那么的美好。事实上 Golang 本身还是处于在 Google 开发维护的阶段，本质上虽然语言完全开源了，但是却不是一个完全社区维护的语言。换句话说，Google 会决定 Golang 未来的走向。不过好在第三方包都是由社区来驱动的，这样还是提供了更多的可定制性。另外一个比较烦恼的是 Golang 本身的包管理机制，事实上，这是完全是一个伪命题。别告诉我你觉得 go get 完全足够了，那只是因为你还没有遇到依赖导致 break 的问题而已（Godep 也可以解决一部分问题，然而第三方包 API 的变更你是没办法控制的）。不过从现在看起码 Google 意识到自己的问题，也正在努力改变吧。Golang 同时也是一个年轻的语言，库比较少的问题也会出现。虽然你可以利用 cgo 去桥接一些现有的 C/C++ 库到 Golang 程序中，但是这部分的代码维护，涉及到 GC 的优化处理等各个方面，对开发者的要求不低。另外一个大家都会抓住讲的就是 GC 问题，在高并发环境下 GC 的影响从 1.5 开始下降了很多，但是 GC 并不像 Java 一样更加可控，很多时候 GC 还是需要进行代码层面进行控制。</p>
<p>上面所有的小众语言还面临一个共同的问题，招人。没错，找到一个适合的小众语言工程师是一个痛苦的事情。虽然你可以通过语言的高开发效率去节省人力，但是当你面临人手紧缺的困境时，去找一个合适的替补人就变成了一件非常昂贵的事情。通常你需要从现有的人员中培养则更加靠谱。（庆幸的是，经过培养后，哪怕我们的移动开发工程师也可以 hold 住我们现在的后端部分需求。当然，这只是感兴趣的前提下。）</p>
<h2 id="如何选择合适的技术栈"><a href="#如何选择合适的技术栈" class="headerlink" title="如何选择合适的技术栈"></a>如何选择合适的技术栈</h2><p>这是一个复杂的问题。选择合适的技术栈，你需要覆盖上面我提到的所有的劣势问题。比如说，你选择了 Nodejs，你就要考虑，你可以 hold 住所有的难点，你可以修正开源包的问题，甚至你可以解决现在没有包的难题，OK，那么你选择这个语言本身是没有任何问题的。</p>
<p>而我在综合考虑之后，选择的技术栈比较简单：Python 和 Golang。其实选择的原因很简单，<strong>这两种语言我更熟悉</strong>。没错，这个是第一个理由。为什么会有 2 个技术栈，这个其实与我们现有的业务状态和未来发展的思考有关，这个会在后面进行一下介绍。厚脸皮的说一下，<strong>Python 和 Golang 语言中的绝大部分问题目前都可以自己解决</strong>，这也是另外一个理由。</p>
<p>接下来，人员培养方面，上面提到的小众语言大多培训容易，以现在产品发展节奏和产品演进速度，<strong>我们的人员培养成本目前是可以承受的</strong>。</p>
<p>使用 Python 的原因，是<strong>开发更快，从而可以快速试错</strong>。利用现有的 Web 框架，搭配合适的数据库，我们可以在 1-2 周内实现一个完整产品的上线，进行快速试错。我们针对 Python 制订了一系列的标准，用于规范代码的格式，保证代码的强壮度。这个可以参考下我之前关于 <a href="http://ipfans.github.io/2016/01/how-we-follow-python-style-guide/" target="_blank" rel="noopener">代码风格要求的文章</a>。</p>
<p>使用 Golang 的原因，<strong>在于需要制作大型长期稳定运行项目的考量</strong>。事实上，我在前面也提到了，在目前的开发过程中，Python 在多人协作过程中个人编码风格、工程性上要更弱、长期运行无法控制的内存泄漏等等问题，如果需要长期稳定运行，我更倾向于选择可以进行编译的编译型语言，<strong>通过静态检查＋动态测试方式，更好的保证程序的强壮型</strong>。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>上面啰里八嗦说了那么多，只是想告诫大家，对小众语言而言，选择的机会成本是特别高的。如果你只是验证试错，或者你只是想卷一笔钱就跑，小众语言的高开发效率是绝对可以满足你的。但是从一个大型工程的角度，你需要通盘考虑小众语言的劣势，选择一个合适的语言作为你的技术栈是十分必要的。</p>
<p>另，杭州云柚科技长期招聘有潜力的 Python/Golang 开发者，有兴趣的请发送简历至 kevin |at| yeeuu |dot| com</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/01/2016-01-26-something-about-mgo-driver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/01/2016-01-26-something-about-mgo-driver/" class="post-title-link" itemprop="url">Mgo 库的常见坑总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-01-26 21:30:00" itemprop="dateCreated datePublished" datetime="2016-01-26T21:30:00+08:00">2016-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/01/2016-01-26-something-about-mgo-driver/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/01/2016-01-26-something-about-mgo-driver/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://gopkg.in/mgo.v2" target="_blank" rel="noopener">mgo 库</a> 是一个很好用的 <figure class="highlight plain"><figcaption><span>驱动。对我们来说，主力数据库是 ```MongoDB```，因此这个驱动对我们来说也是非常重要的。但是，mgo 库有些问题算是一些坑，这里我做了一些简单的整理。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 一些关于 bson.ObjectId 的问题</span><br><span class="line"></span><br><span class="line">### ObjectId 为空的判断</span><br><span class="line">如果你看 ```bson.ObjectId``` 定义的话，它是一个 ```string``` 类型的数据。但是如果你直接定义一个结构，并且生成对象时，这个对象并不是这样的。</span><br><span class="line"></span><br><span class="line">我们首先定义一个结构体：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">type Home struct &#123;ID   bson.ObjectId `bson:&quot;_id,omitempty&quot;`</span><br><span class="line">	Name string        `bson:&quot;name&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后看看一个生成的内容</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h := Home&#123;Name:<span class="string">"123"</span>&#125;</span><br><span class="line">fmt.Println(h.ID)</span><br></pre></td></tr></table></figure>

<p>结果是 <figure class="highlight plain"><figcaption><span>```ObjectId``` 是否为空，使用 ```h.ID </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```go</span><br><span class="line">h := Home&#123;Name:&quot;123&quot;&#125;</span><br><span class="line">fmt.Println(h.ID)</span><br><span class="line">fmt.Println(h.ID.Hex() == &quot;&quot;)</span><br></pre></td></tr></table></figure></p>
<h3 id="正确的生成-ObjectId"><a href="#正确的生成-ObjectId" class="headerlink" title="正确的生成 ObjectId"></a>正确的生成 ObjectId</h3><p>首先值得注意的是 <figure class="highlight plain"><figcaption><span>time.Time)``` 这个方法生成的 ```ObjectId``` 并不是唯一的，结果可能导致的是插入失败。最有效的方式是设定 ```ObjectId``` 对象支持 ```omitempty``` 属性，就像我上面生成的结构体一样，由数据库统一调配生成 ObjectId。如果真的确实需要，可以选择 ```NewObjctId()```。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 时间问题</span><br><span class="line"></span><br><span class="line">之前看到有人问，为什么保存的时间进入到数据库中慢了 8 个小时呢？原因是在保存进入 ```MongoDB``` 时，数据是按照 ```UTC``` 时间（不懂什么是 UTC？[看这里](https://zh.wikipedia.org/zh/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6)）进行的保存，但是取出是按照当前时区来取出。那么问题来了，我的客户如果不都是国人，我怎么保存时间呢？目前我们采用了两种方式来确定数据库的保存时间。一种是 ```Unix 时间戳 ```，这个是不受到时区的影响的，由前端格式化为对应的时区时间；另外一种则是需要在额外的对从 ```MongoDB``` 数据库中取出的数据进行额外的时区校准，简单来说可以这样：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">type Home struct &#123;ID         bson.ObjectId `bson:&quot;_id,omitempty&quot;`</span><br><span class="line">	Name       string        `bson:&quot;name&quot;`</span><br><span class="line">	InsertTime time.Time     `bson:&quot;insert_time&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;sess, _ := mgo.Dial(&quot;127.0.0.1&quot;)</span><br><span class="line">	c := sess.DB(&quot;test&quot;).C(&quot;home&quot;)</span><br><span class="line">	h := Home&#123;Name:&quot;123&quot;, InsertTime: time.Now()&#125;</span><br><span class="line">	c.Upsert(bson.M&#123;&quot;name&quot;:&quot;123&quot;&#125;, h)</span><br><span class="line">	c.Find(bson.M&#123;&quot;name&quot;:&quot;123&quot;&#125;).One(&amp;h)</span><br><span class="line">	fmt.Println(h.InsertTime.Format(&quot;2006-01-02 15:04:05&quot;))</span><br><span class="line">	tz, _ := time.LoadLocation(&quot;America/New_York&quot;)</span><br><span class="line">	fmt.Println(h.InsertTime.In(tz).Format(&quot;2006-01-02 15:04:05&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="更高效的使用-Session"><a href="#更高效的使用-Session" class="headerlink" title="更高效的使用 Session"></a>更高效的使用 Session</h2><p>在 <figure class="highlight plain"><figcaption><span>中合理使用 ```Session``` 可以更高效的操作数据库，做法是在之前进行一次 ```Copy``` 操作：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```go</span><br><span class="line">sessionCopy := mongoSession.Copy()</span><br><span class="line">defer sessionCopy.Close()</span><br><span class="line">collection := sessionCopy.DB(TestDatabase).C(&quot;buoy_stations&quot;)</span><br><span class="line"></span><br><span class="line">log.Printf(&quot;RunQuery : %d : Executing\n&quot;, query)</span><br><span class="line"></span><br><span class="line">// Retrieve the list of stations.</span><br><span class="line">var buoyStations []BuoyStation</span><br><span class="line">err := collection.Find(nil).All(&amp;buoyStations)</span><br><span class="line">if err != nil &#123;log.Printf(&quot;RunQuery : ERROR : %s\n&quot;, err)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(&quot;RunQuery : %d : Count[%d]\n&quot;, query, len(buoyStations))</span><br></pre></td></tr></table></figure></p>
<p>另外值得一提的是 MongoDB 本身，目前我们已经提升到了 <code>MongoDB 3.0+</code> 版本，优势是相对之前版本的 <code>WiredTiger</code> 引擎比较令人印象深刻（如果有条件可以选择最新的 3.2 版本）。大家对之前 <code>MongoDB</code> 中索引建立的痛苦有印象，这个现象在 <code>WiredTiger</code> 引擎中也有所改进。更多的改进可以在 <code>WiredTiger</code> 的 <a href="http://www.wiredtiger.com/" target="_blank" rel="noopener">官网</a> 和 MongoDB 的 <a href="https://s3.amazonaws.com/info-mongodb-com/MongoDB-Performance-Best-Practices.pdf" target="_blank" rel="noopener">性能白皮书</a> 中了解更多。最后，当然，我仍然不建议在非严重必要情况下创建多余索引，这对 <code>MongoDB</code> 的性能和资源消耗都有较大影响。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ipfans"
      src="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
  <p class="site-author-name" itemprop="name">ipfans</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ipfans" title="GitHub → https://github.com/ipfans" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/janxin" title="Twitter → https://twitter.com/janxin" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2013 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ipfans</span>
</div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://s1mbily.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

  <script>
  var link = "" ;
  // 遍历所有的img标签
  $("img").each( (i,o) => {
    var o = $(o);
      // 判断图片的链接是否包含sinaimg关键字
    if( o.attr("src").indexOf("sinaimg") > 0 ){
          // 给这个标签加上referrerPlicy属性
      o.attr("referrerpolicy","no-referrer");
          // 备份图片的src
      link = o.attr("src");
          // 重新设置src，让页面重新加载一次图片
      o.attr("src",link);
    }
  });
  </script>
</body>
</html>
