<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ipfans's Blog" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://www.4async.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ipfans&#39;s Blog">
<meta property="og:url" content="https://www.4async.com/page/4/index.html">
<meta property="og:site_name" content="ipfans&#39;s Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ipfans&#39;s Blog">

<link rel="canonical" href="https://www.4async.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ipfans's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b9862358b198078f40d7e1596b7c5968";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ipfans's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/01/2016-01-27-startup-architecture-language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/01/2016-01-27-startup-architecture-language/" class="post-title-link" itemprop="url">聊聊初创公司的后端语言选型 (小众语言)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-01-27 09:48:00" itemprop="dateCreated datePublished" datetime="2016-01-27T09:48:00+08:00">2016-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/01/2016-01-27-startup-architecture-language/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/01/2016-01-27-startup-architecture-language/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在创业公司初创伊始，如何选择合适的语言决定了产品后续的技术栈和如何进行合理的业务支撑方向。如果你在读这篇文章之前，更倾向于选择 Java/C#/PHP 常见语言技术栈，我觉得对于你而言，这篇文章帮助不大。因为对你而言，这些技术栈意味着更加方便招人，更方便的故障处理资料等等。但是如果一个初创公司想要选择合理的小众语言技术栈，我想这篇文章对你也许有一些帮助。</p>
<p>在文章开始之前，我觉得有必要描述一下所谓的小众语言，这里我在最初进行技术选型时，考察了包括：</p>
<ul>
<li>Python: 你可能在接触爬虫、大数据分析等等方面听过 Python 的大名，大家都知道 Pythonista 都习惯说的一句话就是：人生苦短，我用 Python。</li>
<li>Ruby: 你如果做过 Web 框架，你遇到最多的是很多人都会提到 RoR 框架。用过之后只有一个惊叹了。</li>
<li>JavaScript（Nodejs）: 有没有听过 JavaScript 全栈工程师？有没有听过 JavaScript 全栈工程师？有没有听过 JavaScript 全栈工程师？</li>
<li>Golang: 简单粗暴的语言，也许你见过很多人跟你吹嘘，Golang 是下一代的云计算开发语言。</li>
</ul>
<p>其他语言太过于小众，考虑语言的应用很多需要得到更多的社区支持，目前不在考虑的范畴内。</p>
<h2 id="小众语言的劣势"><a href="#小众语言的劣势" class="headerlink" title="小众语言的劣势"></a>小众语言的劣势</h2><p>正所谓知己知彼百战不殆，在了解一个技术选型之前，最好是研究这些语言的缺点。因为你最后感觉这个技术选型不适合你的时候，根本的原因是这些劣势影响了你。</p>
<p>在上面提到的几个语言中，Python、Ruby、JavaScript 是属于动态语言。关于动态语言的争议最大的地方是：动态语言到底是否合适进行大型项目。事实上，在某些阶段，多人合作，并且大家水平语言不同时，这个时候通常会有这样的问题：团队需要花更多的时间在确保动态语言的准确性上。对于一个项目有高可用、低错误率的要求时，由于语言的动态特性，就需要对程序开发时的单元测试和后期集成测试的要求更高。因为变量在运行时才会赋予类型含义，所以很难在静态检测过程中发现足够多的问题。这样对测试人员的压力也会更大，当你没有合适的测试人员时，这个时候通常会变成，你只覆盖测试了理想情况下的成功失败情况，而对特别异常情况缺少评估。</p>
<p>Python、Ruby 语法对程序员而言最大的成本在于需要重新学习一门新的语言。这个学习成本、时间成本通常对初创公司而言通常是支付不起的，哪怕像这些比较容易学习的动态语言而言。另外一个值得一提的是，无论是 Python 还是 Ruby，从长远看，如果你后续有较大的用户增长又需要保证用户体验时，Python、Ruby 的执行效率和吞吐量会有较大的影响。</p>
<p>Python 和程序员入门的语言差距较大：用 4 个空格表述程序缩进。这意味着，程序员直接从网上寻找解决方案（拷贝代码）时成本更高，因为很有可能他需要手工进行代码格式化，这样有可能造成程序逻辑的改变。另外一个不得不提的是一些 Python 库看似好用，实际上或多或少有有一些坑，这对新手而言，往往是致命的。对应的，Ruby 语言本身时不存在这些问题的。然而 Ruby 作为开发主语言时最大的问题是，如果选择 RoR 框架作为初始的 Web 框架时，如果没有一个熟悉 RoR 框架的人，那么学习修改 RoR 框架的成本是特别高的：对于一个通用型框架而言，你可能需要更多的特殊场景定制，这可能需要做大量的猴子补丁，如果不对框架有一个清晰了解时，这样的成本会更高。</p>
<p>JavaScript（后面统一用 Nodejs 代称）则借助 Nodejs 实现了高性能和较大吞吐量。而且从语言层面上，JavaScript 对很多程序员并不陌生。然而，在过去的很长时间，真正熟练掌握 JavaScript 的都是前端工程师，这是一个非常尴尬的问题。对后端工程师而言，Nodejs 需要与前端不同的技术栈，而且大概没有公司希望一个完全没有任何后端经验的前端工程师去接手后端项目的开发的。Nodejs 是一个年轻的语言，年轻必然会伴随一些问题，比如，库比较少（当然现在也是井喷期）。一些必要的库需要慢慢寻找。事实上，我也不得不吐槽，可能是开发者水平问题，导致很多 npm 提供的包，往往或多或少存在一些比较恼人的 BUG，这些 BUG 可能会在你开发过程中，正常运行中出现，而你却不得不干掉它。对于这种 BUG，很多时候更快的处理方式是你自己动手进行快速修复。然而当你的程序员不具备这种能力的时候，就需要提一个 issue 到开发者，由开发者进行修复，并且需要等待版本更新到 npm 源中。很多时候这个过程都是比较尴尬的，尤其是你选择了一个开发者并不是特别活跃的包。</p>
<p>Golang 是一个编译型语言，语法简单，似乎一切看起来都是那么的美好。事实上 Golang 本身还是处于在 Google 开发维护的阶段，本质上虽然语言完全开源了，但是却不是一个完全社区维护的语言。换句话说，Google 会决定 Golang 未来的走向。不过好在第三方包都是由社区来驱动的，这样还是提供了更多的可定制性。另外一个比较烦恼的是 Golang 本身的包管理机制，事实上，这是完全是一个伪命题。别告诉我你觉得 go get 完全足够了，那只是因为你还没有遇到依赖导致 break 的问题而已（Godep 也可以解决一部分问题，然而第三方包 API 的变更你是没办法控制的）。不过从现在看起码 Google 意识到自己的问题，也正在努力改变吧。Golang 同时也是一个年轻的语言，库比较少的问题也会出现。虽然你可以利用 cgo 去桥接一些现有的 C/C++ 库到 Golang 程序中，但是这部分的代码维护，涉及到 GC 的优化处理等各个方面，对开发者的要求不低。另外一个大家都会抓住讲的就是 GC 问题，在高并发环境下 GC 的影响从 1.5 开始下降了很多，但是 GC 并不像 Java 一样更加可控，很多时候 GC 还是需要进行代码层面进行控制。</p>
<p>上面所有的小众语言还面临一个共同的问题，招人。没错，找到一个适合的小众语言工程师是一个痛苦的事情。虽然你可以通过语言的高开发效率去节省人力，但是当你面临人手紧缺的困境时，去找一个合适的替补人就变成了一件非常昂贵的事情。通常你需要从现有的人员中培养则更加靠谱。（庆幸的是，经过培养后，哪怕我们的移动开发工程师也可以 hold 住我们现在的后端部分需求。当然，这只是感兴趣的前提下。）</p>
<h2 id="如何选择合适的技术栈"><a href="#如何选择合适的技术栈" class="headerlink" title="如何选择合适的技术栈"></a>如何选择合适的技术栈</h2><p>这是一个复杂的问题。选择合适的技术栈，你需要覆盖上面我提到的所有的劣势问题。比如说，你选择了 Nodejs，你就要考虑，你可以 hold 住所有的难点，你可以修正开源包的问题，甚至你可以解决现在没有包的难题，OK，那么你选择这个语言本身是没有任何问题的。</p>
<p>而我在综合考虑之后，选择的技术栈比较简单：Python 和 Golang。其实选择的原因很简单，<strong>这两种语言我更熟悉</strong>。没错，这个是第一个理由。为什么会有 2 个技术栈，这个其实与我们现有的业务状态和未来发展的思考有关，这个会在后面进行一下介绍。厚脸皮的说一下，<strong>Python 和 Golang 语言中的绝大部分问题目前都可以自己解决</strong>，这也是另外一个理由。</p>
<p>接下来，人员培养方面，上面提到的小众语言大多培训容易，以现在产品发展节奏和产品演进速度，<strong>我们的人员培养成本目前是可以承受的</strong>。</p>
<p>使用 Python 的原因，是<strong>开发更快，从而可以快速试错</strong>。利用现有的 Web 框架，搭配合适的数据库，我们可以在 1-2 周内实现一个完整产品的上线，进行快速试错。我们针对 Python 制订了一系列的标准，用于规范代码的格式，保证代码的强壮度。这个可以参考下我之前关于 <a href="http://ipfans.github.io/2016/01/how-we-follow-python-style-guide/" target="_blank" rel="noopener">代码风格要求的文章</a>。</p>
<p>使用 Golang 的原因，<strong>在于需要制作大型长期稳定运行项目的考量</strong>。事实上，我在前面也提到了，在目前的开发过程中，Python 在多人协作过程中个人编码风格、工程性上要更弱、长期运行无法控制的内存泄漏等等问题，如果需要长期稳定运行，我更倾向于选择可以进行编译的编译型语言，<strong>通过静态检查＋动态测试方式，更好的保证程序的强壮型</strong>。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>上面啰里八嗦说了那么多，只是想告诫大家，对小众语言而言，选择的机会成本是特别高的。如果你只是验证试错，或者你只是想卷一笔钱就跑，小众语言的高开发效率是绝对可以满足你的。但是从一个大型工程的角度，你需要通盘考虑小众语言的劣势，选择一个合适的语言作为你的技术栈是十分必要的。</p>
<p>另，杭州云柚科技长期招聘有潜力的 Python/Golang 开发者，有兴趣的请发送简历至 kevin |at| yeeuu |dot| com</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/01/2016-01-26-something-about-mgo-driver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/01/2016-01-26-something-about-mgo-driver/" class="post-title-link" itemprop="url">Mgo 库的常见坑总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-01-26 21:30:00" itemprop="dateCreated datePublished" datetime="2016-01-26T21:30:00+08:00">2016-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/01/2016-01-26-something-about-mgo-driver/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/01/2016-01-26-something-about-mgo-driver/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://gopkg.in/mgo.v2" target="_blank" rel="noopener">mgo 库</a> 是一个很好用的 <figure class="highlight plain"><figcaption><span>驱动。对我们来说，主力数据库是 ```MongoDB```，因此这个驱动对我们来说也是非常重要的。但是，mgo 库有些问题算是一些坑，这里我做了一些简单的整理。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 一些关于 bson.ObjectId 的问题</span><br><span class="line"></span><br><span class="line">### ObjectId 为空的判断</span><br><span class="line">如果你看 ```bson.ObjectId``` 定义的话，它是一个 ```string``` 类型的数据。但是如果你直接定义一个结构，并且生成对象时，这个对象并不是这样的。</span><br><span class="line"></span><br><span class="line">我们首先定义一个结构体：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">type Home struct &#123;ID   bson.ObjectId `bson:&quot;_id,omitempty&quot;`</span><br><span class="line">	Name string        `bson:&quot;name&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后看看一个生成的内容</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h := Home&#123;Name:<span class="string">"123"</span>&#125;</span><br><span class="line">fmt.Println(h.ID)</span><br></pre></td></tr></table></figure>

<p>结果是 <figure class="highlight plain"><figcaption><span>```ObjectId``` 是否为空，使用 ```h.ID </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```go</span><br><span class="line">h := Home&#123;Name:&quot;123&quot;&#125;</span><br><span class="line">fmt.Println(h.ID)</span><br><span class="line">fmt.Println(h.ID.Hex() == &quot;&quot;)</span><br></pre></td></tr></table></figure></p>
<h3 id="正确的生成-ObjectId"><a href="#正确的生成-ObjectId" class="headerlink" title="正确的生成 ObjectId"></a>正确的生成 ObjectId</h3><p>首先值得注意的是 <figure class="highlight plain"><figcaption><span>time.Time)``` 这个方法生成的 ```ObjectId``` 并不是唯一的，结果可能导致的是插入失败。最有效的方式是设定 ```ObjectId``` 对象支持 ```omitempty``` 属性，就像我上面生成的结构体一样，由数据库统一调配生成 ObjectId。如果真的确实需要，可以选择 ```NewObjctId()```。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 时间问题</span><br><span class="line"></span><br><span class="line">之前看到有人问，为什么保存的时间进入到数据库中慢了 8 个小时呢？原因是在保存进入 ```MongoDB``` 时，数据是按照 ```UTC``` 时间（不懂什么是 UTC？[看这里](https://zh.wikipedia.org/zh/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6)）进行的保存，但是取出是按照当前时区来取出。那么问题来了，我的客户如果不都是国人，我怎么保存时间呢？目前我们采用了两种方式来确定数据库的保存时间。一种是 ```Unix 时间戳 ```，这个是不受到时区的影响的，由前端格式化为对应的时区时间；另外一种则是需要在额外的对从 ```MongoDB``` 数据库中取出的数据进行额外的时区校准，简单来说可以这样：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">type Home struct &#123;ID         bson.ObjectId `bson:&quot;_id,omitempty&quot;`</span><br><span class="line">	Name       string        `bson:&quot;name&quot;`</span><br><span class="line">	InsertTime time.Time     `bson:&quot;insert_time&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;sess, _ := mgo.Dial(&quot;127.0.0.1&quot;)</span><br><span class="line">	c := sess.DB(&quot;test&quot;).C(&quot;home&quot;)</span><br><span class="line">	h := Home&#123;Name:&quot;123&quot;, InsertTime: time.Now()&#125;</span><br><span class="line">	c.Upsert(bson.M&#123;&quot;name&quot;:&quot;123&quot;&#125;, h)</span><br><span class="line">	c.Find(bson.M&#123;&quot;name&quot;:&quot;123&quot;&#125;).One(&amp;h)</span><br><span class="line">	fmt.Println(h.InsertTime.Format(&quot;2006-01-02 15:04:05&quot;))</span><br><span class="line">	tz, _ := time.LoadLocation(&quot;America/New_York&quot;)</span><br><span class="line">	fmt.Println(h.InsertTime.In(tz).Format(&quot;2006-01-02 15:04:05&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="更高效的使用-Session"><a href="#更高效的使用-Session" class="headerlink" title="更高效的使用 Session"></a>更高效的使用 Session</h2><p>在 <figure class="highlight plain"><figcaption><span>中合理使用 ```Session``` 可以更高效的操作数据库，做法是在之前进行一次 ```Copy``` 操作：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```go</span><br><span class="line">sessionCopy := mongoSession.Copy()</span><br><span class="line">defer sessionCopy.Close()</span><br><span class="line">collection := sessionCopy.DB(TestDatabase).C(&quot;buoy_stations&quot;)</span><br><span class="line"></span><br><span class="line">log.Printf(&quot;RunQuery : %d : Executing\n&quot;, query)</span><br><span class="line"></span><br><span class="line">// Retrieve the list of stations.</span><br><span class="line">var buoyStations []BuoyStation</span><br><span class="line">err := collection.Find(nil).All(&amp;buoyStations)</span><br><span class="line">if err != nil &#123;log.Printf(&quot;RunQuery : ERROR : %s\n&quot;, err)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(&quot;RunQuery : %d : Count[%d]\n&quot;, query, len(buoyStations))</span><br></pre></td></tr></table></figure></p>
<p>另外值得一提的是 MongoDB 本身，目前我们已经提升到了 <code>MongoDB 3.0+</code> 版本，优势是相对之前版本的 <code>WiredTiger</code> 引擎比较令人印象深刻（如果有条件可以选择最新的 3.2 版本）。大家对之前 <code>MongoDB</code> 中索引建立的痛苦有印象，这个现象在 <code>WiredTiger</code> 引擎中也有所改进。更多的改进可以在 <code>WiredTiger</code> 的 <a href="http://www.wiredtiger.com/" target="_blank" rel="noopener">官网</a> 和 MongoDB 的 <a href="https://s3.amazonaws.com/info-mongodb-com/MongoDB-Performance-Best-Practices.pdf" target="_blank" rel="noopener">性能白皮书</a> 中了解更多。最后，当然，我仍然不建议在非严重必要情况下创建多余索引，这对 <code>MongoDB</code> 的性能和资源消耗都有较大影响。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/01/2016-01-15-how-we-follow-python-style-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/01/2016-01-15-how-we-follow-python-style-guide/" class="post-title-link" itemprop="url">我们是如何落实 Code Style Guide 的（Python 篇）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-01-15 17:30:00" itemprop="dateCreated datePublished" datetime="2016-01-15T17:30:00+08:00">2016-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/01/2016-01-15-how-we-follow-python-style-guide/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/01/2016-01-15-how-we-follow-python-style-guide/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们是如何落实 Code Style Guide 的（Python 篇）</p>
<p>最近年终，总是想谈谈过去一年的感悟和积累。接下来大概有几篇关于项目管理等等一些小方面的介绍，这篇文章主要介绍一下我们如何将 Python 编码规范真正落实到程序的实际开发过程中的。</p>
<h2 id="编码规范选择"><a href="#编码规范选择" class="headerlink" title="编码规范选择"></a>编码规范选择</h2><p>Python 作为灵活的脚本语言，在格式方面并不存在太多的限制（相对编译语言）。这样会导致一个比较蛋疼的问题：在项目开发过程中，由于个人的习惯和编码风格，导致程序缺少一个统一的标准，每个人的代码表现形式也不同。因此，在实际项目由于新人加入、老人退出过程中会产生比较高的模块维护成本。因此，在实际的项目开发中，选择一个编码标准也是比较重要的。</p>
<p>面对编码风格选择，比较常见的包括 <a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP-8</a> 和 <a href="http://zh-google-styleguide.readthedocs.org/en/latest/google-python-styleguide/" target="_blank" rel="noopener">Google Python Style Guide</a>。在最后，我选择了 <code>PEP-8</code> 作为项目中的实际应用标准，要求程序需要在满足编码要求规范的前提下进行编码。</p>
<p>除了对代码编码更个的要求以外，我们还对 import 等具体的细节进行了标准化。</p>
<h2 id="尽量规范注释"><a href="#尽量规范注释" class="headerlink" title="尽量规范注释"></a>尽量规范注释</h2><p>在降低模块维护成本过程中，另外一个比较好的方式是尽量提供良好的代码注释。尽管这个算是一个和语言无关的老生常谈的问题，我只是想在这里提一下另外一个 PEP：<a href="https://www.python.org/dev/peps/pep-0257/" target="_blank" rel="noopener">PEP-0257</a>，这里介绍了一种约定的 docstring 编写方法，对于编辑器而言，可以通过插件快速实现注释。</p>
<p>不过我考虑到对个人习惯的影响较大，这个 PEP 实际项目开发中并未作为实际开发规范，只是鼓励大家在项目中进行执行。</p>
<h2 id="从规范到执行"><a href="#从规范到执行" class="headerlink" title="从规范到执行"></a>从规范到执行</h2><p>从代码开发最初的规范约定是一回事，当回到开发过程中，开发者难免会因为个人的习惯或者疏忽等各种原因导致程序开发过程中程序编码风格不统一问题。因此在实际开发过程中，我们又需要通过工具保证程序在实际过程中能够帮助规范化或者检查格式错误。</p>
<p>借助社区的力量，我们最终选择了工具 <code>flake8</code>、<code>yapf</code> 和 <code>isort</code>。其中，<code>flake8</code> 用于检查我们的代码是否正确的执行了标准；<code>yapf</code> 工具用于快速进行 <code>PEP-8</code> 标准化，减少了人工修改的成本；<code>isort</code> 工具则是执行我们之前提到的 import 标准化工作。</p>
<p><a href="https://github.com/google/yapf" target="_blank" rel="noopener"><code>yapf</code></a> 是 Google 员工开发的一个 Python 格式化工具，它支持 PEP8 与 Google 编码标准，一些具体的使用方式可以查看项目的主页。在实际的项目落地过程中，你应该会遇到的一个问题是关于 <code>flake8</code> 与 <code>yapf</code> 标准不一致导致一个通过另一个无法正常通过的问题。这一个方面，我们选择的方式是统一妥协成 <code>flake8</code> 的标准。对于 <code>yapf</code> 不支持的部分，我们建议活用 <code># yapf: disable</code> 标记。</p>
<p>还有另一个问题是关于一些 <code>flake8</code> 本身的标准（或者说 PEP－8 标准）问题，比如 <code>flake8</code> 常见问题：<code>E501</code> 程序代码长度超过 79 个字符问题，我们实际编码过程中对这一标准做了适当妥协，允许最大单行字符串长度为 200。但是我们仍然建议缩小至 79 个字符内表示完。</p>
<h2 id="从执行到检查"><a href="#从执行到检查" class="headerlink" title="从执行到检查"></a>从执行到检查</h2><p>在最后一关，是我们的上线前检查。我们设置了代码质量检查关卡和系统集成测试。</p>
<p>在代码质量检查过程中，我们会对程序的实际代码质量进行评估。我们对代码质量进行打分，对于分值较低的代码不允许提交进入 <code>master</code> 分支。代码质量的检查，我们同样的采用了 <code>flake8</code> 工具作为统一标准。最后个人的代码质量，通过 Webhook 也会直接反馈在具体的项目管理工具中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/01/2016-01-06-rust-http-client/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/01/2016-01-06-rust-http-client/" class="post-title-link" itemprop="url">一个 Rust HttpClient 例子</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-01-06 17:13:00" itemprop="dateCreated datePublished" datetime="2016-01-06T17:13:00+08:00">2016-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/01/2016-01-06-rust-http-client/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/01/2016-01-06-rust-http-client/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 cargo.toml 文件中添加</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">hyper</span> = <span class="string">"0.7.2"</span></span><br></pre></td></tr></table></figure>

<p>src 中创建 main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> hyper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> hyper::Client;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;<span class="built_in">println!</span>(<span class="string">"welcome to rust http"</span>);</span><br><span class="line">    <span class="keyword">let</span> client = Client::new();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> res = client.get(<span class="string">"https://httpbin.org/get"</span>).send().unwrap();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(res.status, hyper::<span class="literal">Ok</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"headers:\n &#123;&#125;"</span>, res.headers);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> body = <span class="built_in">String</span>::new();</span><br><span class="line">    res.read_to_string(&amp;<span class="keyword">mut</span> body).unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"body:\n &#123;&#125;"</span>, body);</span><br><span class="line">    res = client.post(<span class="string">"https://httpbin.org/post"</span>).body(<span class="string">"&#123;\"a\":1&#125;"</span>).send().unwrap();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(res.status, hyper::<span class="literal">Ok</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"headers:\n &#123;&#125;"</span>, res.headers);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> body = <span class="built_in">String</span>::new();</span><br><span class="line">    res.read_to_string(&amp;<span class="keyword">mut</span> body).unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"body:\n &#123;&#125;"</span>, body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>cargo build</code> 后执行 <code>./target/debug / 项目名</code> 即可看到效果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2016/01/2016-01-05-golang-vendor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/01/2016-01-05-golang-vendor/" class="post-title-link" itemprop="url">使用 vendor 管理 Golang 项目依赖</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-01-05 23:13:00" itemprop="dateCreated datePublished" datetime="2016-01-05T23:13:00+08:00">2016-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/01/2016-01-05-golang-vendor/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/01/2016-01-05-golang-vendor/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们在项目中除了 <a href="http://ipfans.github.io/2015/12/using-vagrant-development-env/" target="_blank" rel="noopener">大量的使用 Python</a> 外，也大量的使用了 Golang 构建高效基础运行服务。在使用 Golang 过程中，我们发现 Golang 程序缺少依赖库版本功能是一个非常令人头大的问题：某些依赖在某个 commit 之后发生了 API 变更之后，如果不修改代码很难兼容，然而开发者之间很有可能因为参与的时间不同，导致执行 <figure class="highlight go"><figcaption><span>get``` 命令获取的版本不同，而导致在不同电脑上出现编译不通过问题。同时，在多个程序中，如果使用的 commit 版本不同，也可能会导致程序编译过程中出现不同的问题。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在之前，我们解决这个问题有两个方案，一种是拆解 <span class="string">``</span><span class="string">`go get`</span><span class="string">``</span> 命令的执行，首先创建对应依赖目录，利用 git 命令切换至指定的 commit，然后执行 <span class="string">``</span><span class="string">`go install`</span><span class="string">``</span> 命令。另外一种比较省事的方法是使用 [godep](https:<span class="comment">//github.com/tools/godep) 工具，这里就不做过多介绍了，具体可以参考文档或者搜索中文教程。</span></span><br><span class="line"></span><br><span class="line">在 Golang1<span class="number">.5</span> 之后，Go 提供了 <span class="string">``</span><span class="string">`GO15VENDOREXPERIMENT`</span><span class="string">``</span> 环境变量，用于将 <span class="keyword">go</span> build 时的应用路径搜索调整成为 <span class="string">``</span><span class="string">` 当前项目目录 / vendor`</span><span class="string">``</span> 目录方式。通过这种形式，我们可以实现类似于 <span class="string">``</span><span class="string">`godep`</span><span class="string">``</span> 方式的项目依赖管理。不过起码在程序编译过程中，再也无需在其他端部署一个 <span class="string">``</span><span class="string">`godep`</span><span class="string">``</span> 工具。</span><br><span class="line"></span><br><span class="line">在使用之前，需要安装一个辅助工具（如果 Golang 自改一个就好了）：<span class="string">``</span><span class="string">`go get -u -v github.com/kardianos/govendor`</span><span class="string">``</span>。</span><br><span class="line"></span><br><span class="line">下面，我们用一个例子来说明。首先有一个名为 <span class="string">``</span><span class="string">`vendorproj`</span><span class="string">``</span> 的项目。假如只有一个文件：</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string">package main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">import ("github.com/yeeuu/echoic")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func main() &#123;e := echoic.New()</span></span><br><span class="line"><span class="string">	e.SetDebug(true)</span></span><br><span class="line"><span class="string">	e.Run("127.0.0.1:4321")</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>执行一下命令就可以生成 vendor 文件夹：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ govendor init</span><br><span class="line">$ ls</span><br><span class="line">main.go    vendor</span><br><span class="line">$ <span class="built_in">cd</span> vendor/</span><br><span class="line">$ ls</span><br><span class="line">vendor.json</span><br></pre></td></tr></table></figure>

<p>这个 <figure class="highlight plain"><figcaption><span>会类似 ```godep``` 工具中的描述文件版本的功能。接下来，需要执行命令将当前应用必须的文件包含进来</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>$ govendor add +external</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果需要更新或移除，可以参考一下工具的具体文档使用 ```update``` 或者 ```remove``` 命令即可。这样会在 vendor 目录下将必须的编译文件移入进来（注意：测试所需依赖并不包含，依赖项目的测试文件也不会包含）。</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">$ ls</span><br><span class="line">github.com  golang.org  vendor.json</span><br><span class="line">$ cat vendor.json</span><br><span class="line">&#123;&quot;comment&quot;: &quot;&quot;,&quot;ignore&quot;:&quot;test&quot;,&quot;package&quot;: [&#123;&quot;path&quot;:&quot;github.com/yeeuu/echoic&quot;,&quot;revision&quot;:&quot;a7d6994f92e2dc60cff071ae38b204fbd4bd2a3f&quot;,&quot;revisionTime&quot;:&quot;2015-12-18T11:14:29+08:00&quot;&#125;,</span><br><span class="line">		&#123;&quot;path&quot;: &quot;golang.org/x/net/context&quot;,</span><br><span class="line">			&quot;revision&quot;: &quot;1d9fd3b8333e891c0e7353e1adcfe8a612573033&quot;,</span><br><span class="line">			&quot;revisionTime&quot;: &quot;2015-11-13T15:40:13-08:00&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">$ cd github.com/yeeuu/echoic</span><br><span class="line">$ ls</span><br><span class="line">LICENSE     context.go  group.go    router.go</span><br><span class="line">README.md   echoic.go   response.go</span><br></pre></td></tr></table></figure>

<p>通过设置环境变量 <code>GO15VENDOREXPERIMENT=1</code> 使用 vendor 文件夹构建文件。可以选择 <code>export GO15VENDOREXPERIMENT=1</code> 或者干脆 <code>GO15VENDOREXPERIMENT=1 go build</code> 执行编译。</p>
<p>通过这种方式就可以保证程序能够实现类似 Python 中 Virtualenv 的模式，实现不同程序使用不同版本依赖的目的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2015/12/2015-12-28-using-vagrant-development-env/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/12/2015-12-28-using-vagrant-development-env/" class="post-title-link" itemprop="url">使用 Vagrant 统一开发环境实践</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-12-28 15:43:12" itemprop="dateCreated datePublished" datetime="2015-12-28T15:43:12+08:00">2015-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2015/12/2015-12-28-using-vagrant-development-env/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/2015-12-28-using-vagrant-development-env/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在服务器端开发过程中，比较痛苦的是在多个人员进行开发时，容易因为环境不统一等等的情况，容易出现传说中的 “我这儿能跑，换个环境就出问题” 的情况。我们在项目开发过程中大量的使用了 Python 语言构建 Web 类型服务。Python 对于某些需要编译的扩展模块，可能在不同的场景下带来不同的影响（如编译不过等等、二进制版本不同等等问题）。</p>
<p>在处理这种多人协作的环境统一问题时，我们选择 Vagrant＋VirtualBox＋CentOS 虚拟环境方案统一开发环境，避免出现切换开发者，切换开发环境带来的不统一的麻烦。</p>
<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>vagrant 可以在 <a href="https://www.vagrantup.com/" target="_blank" rel="noopener">https://www.vagrantup.com/</a> 下载安装，对应的系统镜像可以在 <a href="http://www.vagrantbox.es/" target="_blank" rel="noopener">http://www.vagrantbox.es/</a> 找到下载安装。根据国内实际的下载情况，我们建议先行下载镜像方式初始化项目。在选择镜像时，建议选择与线上服务器版本相同的镜像。下面我们仅演示本地加载镜像方式。</p>
<p>下载 vagrant 和镜像后，安装 vagrant 软件。这样就可以在命令行中执行相关指令。还有，记得安装 VirtualBox。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add centos /path/to/centos-6.6-x86_64.box</span><br></pre></td></tr></table></figure>

<p>比如我们线上服务器使用了 centos 环境，我们在开发时，也是选择相同版本的 CentOS box。</p>
<p>接下来进入对应的项目目录，使用如下命令创建 Vagrantfile（centos 是刚刚添加的 box）。当然，如果项目已经存在 Vagrantfile，则可以进行省略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant init centos</span><br></pre></td></tr></table></figure>

<p>项目文件夹下会生成 Vagrantfile 文件。</p>
<h2 id="Vagrantfile-编辑"><a href="#Vagrantfile-编辑" class="headerlink" title="Vagrantfile 编辑"></a>Vagrantfile 编辑</h2><p>Vagrant 在执行环境初始化时会根据 Vagrantfile 文件的描述进行。比较常见的编辑内容一般包含以下几种。</p>
<p>如果想要使用 IP 访问该虚拟服务器，可以通过删除 <figure class="highlight plain"><figcaption><span>:private_network, ip: "192.168.33.10"``` 前的 “#”，将该设置生效。注意需要确认 ip 不要被占用。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果需要同步文件夹到虚拟机中（比如项目文件夹），可以注释掉 ```config.vm.synced_folder &quot;../data&quot;, &quot;/vagrant_data&quot;``` 前的 “#”，将设置生效。该命令可以切换更复杂的设置：```config.vm.synced_folder &quot;./&quot;, &quot;/var/www&quot;, create: true, group: &quot;nginx&quot;, owner: &quot;nginx&quot;``` 命令表示将本地的当前目录映射到 ```/var/www``` 目录，若不存在时创建，同意 user 和 group 设置为 nginx。</span><br><span class="line"></span><br><span class="line">## 服务器初始化</span><br><span class="line"></span><br><span class="line">服务器初始化功能也算是在 Vagrantfile 编辑之中的，之所以单独介绍，是因为服务器的环境是初始化时一个更加独立的过程，应用也最多。在 vagrant 环境初始化时，可以通过 Vagrantfile 的 ```config.vm.provision &quot;shell&quot;``` 功能，初始化服务器配置和一些基础运行环境。比如说我们现在正在使用的配置如下（Vagrantfile 中对应内容）：</span><br><span class="line"></span><br><span class="line">```ruby</span><br><span class="line">  config.vm.provision &quot;shell&quot;, inline: &lt;&lt;-SHELL</span><br><span class="line">    mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">    wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class="line">    sudo yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel</span><br><span class="line">    sudo yum install -y mysql-server mysql-client mysql-devel</span><br><span class="line">    sudo yum install -y make gcc gcc-c++</span><br><span class="line">    cd /tmp</span><br><span class="line">    wget https://www.python.org/ftp/python/2.7.11/Python-2.7.11.tgz</span><br><span class="line">    tar zxvf Python-2.7.11.tgz</span><br><span class="line">    cd /tmp/Python-2.7.11</span><br><span class="line">    ./configure --prefix=/usr/local --with-ensurepip=upgrade</span><br><span class="line">    make</span><br><span class="line">    sudo make install</span><br><span class="line">    sudo /usr/local/bin/pip install virtualenv</span><br><span class="line">    virtualenv /mnt/pyenv</span><br><span class="line">    sudo /usr/local/bin/virtualenv /mnt/pyenv</span><br><span class="line">    source /mnt/pyenv/bin/activate</span><br><span class="line">    sudo /mnt/pyenv/bin/pip install -r /vagrant/requirements.txt</span><br><span class="line">  SHELL</span><br></pre></td></tr></table></figure></p>
<p>该项配置使用了阿里云的 CentOS 源，编译 Python 2.7.11 并且安装应用必须的一些依赖。项目默认路径会安装在 / vagrant / 目录下，可以通过其他形式，安装至与线上环境相同的位置。</p>
<p>Vagrant 也支持使用 <figure class="highlight plain"><figcaption><span>形式部署服务，如果你了解具体的使用方法，可以使用下面的形式指定 playbook。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```ruby</span><br><span class="line">Vagrant.configure(2) do |config|</span><br><span class="line"></span><br><span class="line">  #</span><br><span class="line">  # Run Ansible from the Vagrant Host</span><br><span class="line">  #</span><br><span class="line">  config.vm.provision &quot;ansible&quot; do |ansible|</span><br><span class="line">    ansible.playbook = &quot;playbook.yml&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<p>当然，利用 Vagrant 也可以很方便的学习和测试 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 运行测试</span><br><span class="line"></span><br><span class="line">在编辑 Vagrantfile 完成后，可以通过 ```vagrant up``` 命令，启动虚拟环境。此时如果设置了服务器初始化，会在最开始过程中执行大量的初始化操作。待操作完成后，则可以验证。</span><br><span class="line"></span><br><span class="line">## 打包分发</span><br><span class="line"></span><br><span class="line">在编辑完成后，则可以根据当前版本生成 Box 文件。对其他开发者而言，可以通过 Box 文件直接快速生成开发环境，也避免了还需要进行服务器初始化阶段。</span><br></pre></td></tr></table></figure></p>
<p>vagrant package</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出会提示保存文件地址：</span><br></pre></td></tr></table></figure>

<p>==&gt; default: Attempting graceful shutdown of VM…<br>==&gt; default: Clearing any previously set forwarded ports…<br>==&gt; default: Exporting VM…<br>==&gt; default: Compressing package to: /path/to/package.box</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果进行了初始化环境的变更，我们建议同时更新 Vagrantfile 文件，通过重新打包的方式进行同步更新。</span><br><span class="line"></span><br><span class="line">## Vagrant 其他命令</span><br><span class="line"></span><br><span class="line">在刚刚提到的几个命令中，```vagrant up``` 可以用于开启环境，对应的还有一些其他命令：</span><br></pre></td></tr></table></figure>

<p>vagrant ssh                // ssh<br>vagrant halt            // 关机<br>vagrant status            // 查看状态<br>vagrant destory            // 删除虚拟机，如果你需要重新开始<br>…</p>
<pre><code></code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2015/11/2015-11-11-async-python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/11/2015-11-11-async-python/" class="post-title-link" itemprop="url">Python 异步与性能迷思</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-11-11 18:18:18" itemprop="dateCreated datePublished" datetime="2015-11-11T18:18:18+08:00">2015-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2015/11/2015-11-11-async-python/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/11/2015-11-11-async-python/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天在讨论 Python 的异步编程的时候提到的问题：到底为什么现在 Python 的异步数据库那么少呢？到底针对 Python 而言，什么是影响 Python 性能最大的门槛呢？</p>
<p>为了搞清楚这个问题，我对线上环境应用使用了性能探针系统。性能出人意料 (CPython 2.7.10)：</p>
<p><img src="http://ww3.sinaimg.cn/bmiddle/69e37fdbgw1exx27zl4eij211q0nw0vk.jpg" alt="线上性能"></p>
<p>似乎真实来说，Python 本身的性能问题才是影响 Python 性能的真凶。</p>
<p>在此以前，我们谈这个之前，还是先复习一下什么是 GIL 吧。无论是 CPython(普通的 Python 2.7.x 和 Python 3.5.x) 还是 pypy，都是有一个名曰『Global Interpreter Lock』的东西限制了它的性能，用一张图可以生动的表现带 GIL 的 Python 在多核下的 CPU 压力：</p>
<p><img src="http://ww4.sinaimg.cn/bmiddle/d90975f6gw1ev933py5p9g208w050kjm.gif" alt="CPU 性能演示"></p>
<p>GIL 限制了 Python 的 bytecode 只能在一个线程中运行，使用这种 GIL 避免多线程编程时隐含并发访问对象可能带来的潜在问题，但是也让 Python 在多核下性能表现感人。这种实现方式一直备受诟病，这也导致 Python 在某些高并发场景时会出现较严重的性能下滑问题。</p>
<p>在 Python 性能提升上，比较常见的性能提升的方式，是将多线程转化为多进程方式，以充分利用 CPU 多核心。但是这样带来直接的问题是进程间通讯会严重影响整体程序的吞吐量。一个简单的 CPU 密集 Python socket 的通讯程序，非 Block 状态下，吞吐量能有大概 10 倍以上的差距。(参考 <a href="http://pyvideo.org/video/3432/python-concurrency-from-the-ground-up-live" target="_blank" rel="noopener">Python Concurrency From the Ground Up</a> )</p>
<p>不过相对来说，这样虽然影响了最大吞吐量，但是在利用多核效率上提升明显，即便是 CPU 密集的情况，也能保证程序的整体吞吐量不会出现线程模式的成百上千倍的性能差距。</p>
<p>那么，这些与异步又有什么关系呢？</p>
<p>对异步情况而言，对 Python 的代码执行并没有影响，我们所提到的异步，能够提升的性能，也仅仅限于针对针对于较长 IO 等待的问题，比如常见的就是请求远程 API 接口 (http query) 等等情况。对这种情况而言，当进入 Blocking 的 socket 等待时间时，将 CPU 时间释放，用于去做更有意义的其他操作是完全合理的。对于数据库操作而言，则也需要根据不同的情况进行对待。比如连接远程网络数据库，那么使用异步则根据实际的性能消耗时间而定，如果是本地的数据库，那么我想回到第一张图，相信根本无需使用异步库就可以解决这个问题。</p>
<p>从一个 <a href="http://ipfans.github.io/2014/05/speed-python-code-with-cython/" target="_blank" rel="noopener">CPU 密集的例子</a>，我们也能看出，其实，使用 JIT 带来的性能提升比较明显。然而，对异步库的异步队列仍是按顺序单个处理的，当队列较长时，同样会带来更严重的性能损耗：因为对那些快速的网络连接而言，Python GIL 则更加限制了 Python 的执行性能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2015/10/2015-10-31-coroutines-with-async-and-await-syntax-chinese/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/10/2015-10-31-coroutines-with-async-and-await-syntax-chinese/" class="post-title-link" itemprop="url">PEP 0492 Coroutines with async and await syntax 中文翻译</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-31 12:48:15" itemprop="dateCreated datePublished" datetime="2015-10-31T12:48:15+08:00">2015-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2015/10/2015-10-31-coroutines-with-async-and-await-syntax-chinese/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/10/2015-10-31-coroutines-with-async-and-await-syntax-chinese/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文地址: <a href="https://www.python.org/dev/peps/pep-0492/" target="_blank" rel="noopener">PEP-0492</a></p>
<table>
<thead>
<tr>
<th align="left">PEP</th>
<th align="left">492</th>
</tr>
</thead>
<tbody><tr>
<td align="left">标题</td>
<td align="left">协程与 async/await 语法</td>
</tr>
<tr>
<td align="left">作者</td>
<td align="left">Yury Selivanov <figure class="highlight plain"><figcaption><span>at magic.io>```|</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">| 翻译 | ipfans ```&lt;ipfanscn at gmail.com&gt;```|</span><br><span class="line">| 状态 | 最终稿 |</span><br><span class="line">|Python 版本 | 3.5|</span><br><span class="line">| 翻译最后更新 | 2015-11-03|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">[摘要](#Abstract)    </span><br><span class="line">[API 设计和实现的备注](#API-Design-and-Implementation-Note)    </span><br><span class="line">[基本原理和目标](#Rationale-and-Goals)   </span><br><span class="line">[语法规范](#Specification)</span><br><span class="line"></span><br><span class="line">   * [新协程声明语法](#New-Coroutine-Declaration-Syntax)</span><br><span class="line">   * [types.coroutine()](#Type-Coroutine)</span><br><span class="line">   * [Await 表达式](#Await-Expression)</span><br><span class="line">     * [新的操作符优先级列表](#Updated-operator-precedence-table)</span><br><span class="line">     * [await 表达式示例](#Examples-of-await-expressions)</span><br><span class="line">   * [异步上下文管理与 ```async with```](#Asynchronous-Context-Managers)</span><br><span class="line">      * [新语法](#Async-With-New-Syntax)</span><br><span class="line">      * [例子](#Async-With-Example)</span><br><span class="line">   * [异步迭代器与 ```async for```](#Asynchronous-Iterators)</span><br><span class="line">      * [新语法](#Async-For-New-Syntax)</span><br><span class="line">      * [例子 1](#Async-For-Example-1)</span><br><span class="line">      * [例子 2](#Async-For-Example-2)</span><br><span class="line">      * [为什么使用 ```StopAsyncIteration```](#Why-StopAsyncIteration)</span><br><span class="line">   * [协程对象](#Coroutine-objects)</span><br><span class="line">     * [与生成器的不同之处](#Differences-from-generators)</span><br><span class="line">     * [协程对象方法](#Coroutine-object-methods)</span><br><span class="line">   * [调试特性](#Debugging-Features)</span><br><span class="line">   * [新的标准库函数](#New-Standard-Library-Functions)</span><br><span class="line">   * [新的抽象基类](#New-Abstract-Base-Classes)</span><br><span class="line"></span><br><span class="line">[专用术语表](#Glossary)   </span><br><span class="line">[函数与方法列表](#List-of-functions-and-methods)   </span><br><span class="line">[移植计划](#Transition-Plan)</span><br><span class="line"></span><br><span class="line">   * [向后兼容性](#Backwards-Compatibility)</span><br><span class="line">     * [asyncio](#asyncio)</span><br><span class="line">     * [asyncio 移植策略](#asyncio-migration-strategy)</span><br><span class="line">     * [CPython 代码中的 ```async/await```](#async-await-in-CPython-code-base)</span><br><span class="line">   * [语法更新](#Grammar-Updates)</span><br><span class="line">   * [失效计划](#Deprecation-Plans)</span><br><span class="line"></span><br><span class="line">设计思路 (暂时不考虑翻译)   </span><br><span class="line">[性能](#Performance)</span><br><span class="line"></span><br><span class="line">   * [总体影响](#Overall-Impact)</span><br><span class="line">   * [编译器修改](#Tokenizer-modifications)</span><br><span class="line">   * [```async/await```](#async-await)</span><br><span class="line"></span><br><span class="line">[实现参考](#Reference-Implementation)</span><br><span class="line"></span><br><span class="line">   * [上层修改和新协议列表](#List-of-high-level-changes-and-new-protocols)</span><br><span class="line">   * [可以工作的实例](#working-example)</span><br><span class="line"></span><br><span class="line">参考</span><br><span class="line"></span><br><span class="line">致谢</span><br><span class="line"></span><br><span class="line">版权信息</span><br><span class="line"></span><br><span class="line">## &lt;a name=&quot;Abstract&quot;&gt;&lt;/a&gt; 摘要</span><br><span class="line"></span><br><span class="line">不断增长的网络连通性需求带动了对响应性、伸缩性代码的需求。这个 PEP 的目标在于回答如何更简单的、Pythinic 的实现显式的异步 / 并发的 Python 代码。</span><br><span class="line"></span><br><span class="line">我们把协程概念独立出来，并为其使用新的语法。最终目标是建立一个通用、易学的 Python 异步编程模型，并尽量与同步编程的风格保持一致。</span><br><span class="line"></span><br><span class="line">这个 PEP 假设异步任务被一个事件循环器（类似于标准库里的 asyncio.events.AbstractEventLoop）管理和调度。不过，我们并不会依赖某个事件循环器的具体实现方法，从本质上说只与此相关：使用 yield 作为给调度器的信号，表示协程将会挂起直到一个异步事件（如 IO）完成。</span><br><span class="line"></span><br><span class="line">我们相信这些改变将会使 Python 在这个异步编程快速增长的领域能够保持一定的竞争性，就像许多其它编程语言已经、将要进行的改变那样。</span><br><span class="line"></span><br><span class="line">## &lt;a name=&quot;API-Design-and-Implementation-Note&quot;&gt;&lt;/a&gt;API 设计和实现的备注</span><br><span class="line"></span><br><span class="line">根据 Python 3.5 Beta 期间的反馈，我们进行了重新设计：明确的把协程从生成器里独立出来 --- 原生协程现在拥有了自己完整的独立类型，而不再是一种新的生成器类型。</span><br><span class="line"></span><br><span class="line">这个改变主要是为了解决在 Tornado Web 服务中里集成协程时出现的一些问题。</span><br><span class="line"></span><br><span class="line">## &lt;a name=&quot;Rationale-and-Goals&quot;&gt;&lt;/a&gt; 基本原理和目标</span><br><span class="line"></span><br><span class="line">现在版本的 Python 支持使用生成器实现协程功能 ([PEP-342](https://www.python.org/dev/peps/pep-0342))，后面通过 [PEP-380](https://www.python.org/dev/peps/pep-0380) 引入了 ```yield from``` 语法进行了增强。但是这样仍有一些缺点：</span><br><span class="line"></span><br><span class="line">   * 协程与常规的生成器在相同语法时用以混淆，尤其是对心开发者而言。</span><br><span class="line">   * 一个函数是否是协程需要通过是否主体代码中使用了 ```yield``` 或者 ```yield from``` 语句进行检测，这样在重构代码中添加、去除过程中容易出现不明显的错误</span><br><span class="line">   * 异步调用的支持被 ```yield``` 支持的语法先定了，导致我们无法使用更多的语法特性，比如 ```with``` 和 ```for``` 语句。</span><br><span class="line"></span><br><span class="line">这个提议的目的是将协程作为原生 Python 语言特性，并且将他们与生成器明确的区分开。它避免了生成器 / 协程中间的混淆请困高，方便编写出不依赖于特定库的协程代码。这个也方便 linter 和 IDE 能够实现更好的进行静态代码分析和重构。</span><br><span class="line"></span><br><span class="line">原生协程和相关的新语法特性使得可以在异步框架下可以定义一个上下文管理器和迭代协议。在这个提议后续中，新的 ```async with``` 语法让 Python 程序在进入和离开运行上下文时实现异步调用，新的 ```async for``` 语法可以在迭代器中实现异步调用。</span><br><span class="line"></span><br><span class="line">## &lt;a name=&quot;Specification&quot;&gt;&lt;/a&gt; 语法规范</span><br><span class="line"></span><br><span class="line">这个提议介绍了新的语法用于增强 Python 中的协程支持。</span><br><span class="line"></span><br><span class="line">这个语法规范假设你已经了解 Python 现有协程实现方法 ([PEP-342](https://www.python.org/dev/peps/pep-0342) 和 [PEP-380](https://www.python.org/dev/peps/pep-0380))。这次语法改变的动机来自于 asyncio 框架 ([PEP-3156](https://www.python.org/dev/peps/pep-3156)) 和 ```Cofunctions``` 提议 ([PEP-3152](https://www.python.org/dev/peps/pep-3152)，现在此提议已被废弃)。</span><br><span class="line"></span><br><span class="line">从本文档中，我们使用 ``` 原生协程 ``` 代指新语法生命的函数，``` 基于生成器的协程 ``` 用于表示那些基于生成器语法实现的协程。``` 协程 ``` 则表示两个地方都可以使用的内容。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### &lt;a name=&quot;New-Coroutine-Declaration-Syntax&quot;&gt;&lt;/a&gt; 新协程声明语法</span><br><span class="line"></span><br><span class="line">下面的新语法用于声明原生协程：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">async def read_data(db):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></td>
</tr>
</tbody></table>
<p>协程的主要属性包括：</p>
<ul>
<li><figure class="highlight plain"><figcaption><span>def``` 函数始终为协程，即使它不包含 ```await``` 表达式。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   * 如果在 ```async``` 函数中使用 ```yield``` 或者 ```yield from``` 表达式会产生 ```SyntaxError``` 错误。</span><br><span class="line">   * 在内部，引入了两个新的代码对象标记：</span><br><span class="line">      * ```CO_COROUTINE``` 用于标记原生协程（和新语法一起定义）</span><br><span class="line">      * ```CO_ITERABLE_COROUTINE``` 用于标记基于生成器的协程，兼容原生协程。(通过 ```types.coroutine()``` 函数设置)</span><br><span class="line">   * 常规生成器在调用时会返回一个 ```genertor``` 对象，同理，协程在调用时会返回一个 ```coroutine``` 对象。</span><br><span class="line">   * 协程不再抛出 ```StopIteration``` 异常，而是替代为 ```RuntimeError```。常规生成器实现类似的行为需要进行引入 ``` __future__```([PEP-3156](https://www.python.org/dev/peps/pep-3156))</span><br><span class="line">   * 当协程进行垃圾回收时，一个从未被 ```await``` 的协程会抛出 ```RuntimeWarning``` 异常。(参考 [调试特性](#Debugging-Features))</span><br><span class="line">   * 更多内容请参考 [协程对象](#Coroutine-objects) 一节。</span><br><span class="line"></span><br><span class="line">### &lt;a name=&quot;Type-Coroutine&quot;&gt;&lt;/a&gt;types.coroutine()</span><br><span class="line"></span><br><span class="line">在 ```types``` 模块中新添加了一个函数 ```coroutine(fn)``` 用于 ```asyncio``` 中基于生成器的协程与本 PEP 中引入的原生携协程互通。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">@types.coroutine</span><br><span class="line">def process_data(db):</span><br><span class="line">    data = yield from read_data(db)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这个函数将生成器函数对象设置 <figure class="highlight plain"><figcaption><span>标记，将返回对象变为 ```coroutine``` 对象。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果 ```fn``` 不是一个生成器函数，那么它会对其进行封装。如果它返回一个生成器，那么它会封装一个 ```awaitable``` 代理对象 (参考下面 ```awaitable``` 对象的定义)。</span><br><span class="line"></span><br><span class="line">注意：```CO_COROUTINE``` 标记不能通过 ```types.coroutine()``` 进行设置，这就可以将新语法定义的原生协程与基于生成器的协程进行区分。</span><br><span class="line"></span><br><span class="line">types 模块添加了一个新函数 coroutine(fn)，使用它，“生成器实现的协程” 和 “原生协程” 之间可以进行互操作。</span><br><span class="line"></span><br><span class="line">### &lt;a name=&quot;Await-Expression&quot;&gt;&lt;/a&gt;Await 表达式</span><br><span class="line"></span><br><span class="line">下面新的 ```await``` 表达式用于获取协程执行结果：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">async def read_data(db):</span><br><span class="line">    data = await db.fetch(&apos;SELECT ...&apos;)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>与 ```yield from``` 相似，挂起 ```read_data``` 协程的执行直到 ```db.fetch``` 这个 ```awaitable``` 对象完成并返回结果数据。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">它复用了 ```yield from``` 的实现，并且添加了额外的验证参数。```await``` 只接受以下之一的 ```awaitable``` 对象：</span><br><span class="line"></span><br><span class="line">* 一个原生协程函数返回的原生协程对象。</span><br><span class="line">* 一个使用 ```types.coroutine()``` 修饰器的函数返回的基于生成器的协程对象。</span><br><span class="line">* 一个包含返回迭代器的 ```__await__``` 方法的对象。   </span><br><span class="line">   任意一个 ```yield from``` 链都会以一个 ```yield``` 结束，这是 ```Future``` 实现的基本机制。因此，协程在内部中是一种特殊的生成器。每个 ```await``` 最终会被 ```await``` 调用链条上的某个 ```yield``` 语句挂起（参考 [PEP-3156](https://www.python.org/dev/peps/pep-3156) 中的进一步解释）。   </span><br><span class="line">   为了启用协程的这一特点，一个新的魔术方法 ```__await__``` 被添加进来。在 ```asyncio``` 中，对于对象在 await 语句启用 ```Future``` 对象只需要添加 ```__await__ = __iter__``` 这行到 ```asyncio.Future``` 类中。   </span><br><span class="line">   在本 PEP 中，带有 ```__await__``` 方法的对象也叫做 ```Future-like``` 对象。</span><br><span class="line">   同样的，请注意到 ```__aiter__``` 方法（下面会定义）不能用于这种目的。它是不同的协议，有点类似于用 ```__iter__``` 替代普通调用方法的 ```__call___```。   </span><br><span class="line">   如果 ```__await__``` 返回非迭代器类型数据，会产生一个 ```TypeError```.</span><br><span class="line">* CPython C API 中使用 ``` tp_as_async.am_await``` 定义的函数，并且返回一个迭代器（类似 ```__await__``` 方法）。</span><br><span class="line"></span><br><span class="line">#### &lt;a name=&quot;Updated-operator-precedence-table&quot;&gt;&lt;/a&gt; 新的操作符优先级列表</span><br><span class="line"></span><br><span class="line">关键词 ```await``` 与 ```yield``` 和 ```yield form``` 操作符的区别是 ```await``` 表达式大部分情况下不需要括号包裹。</span><br><span class="line"></span><br><span class="line">同样的，```yield from``` 允许允许任意表达式做其参数，包含表达式如 ```yield a()+b()```，这样通常处理作为 ```yield from (a()+b())```，这个通常会造成 Bug。通常情况下任意算数操作的结果都不会是 ```awaitable``` 对象。为了避免这种情况，我们将 await 的优先级调整为低于 ```[], () 和.```，但是高于 ``` ** ``` 操作符。</span><br><span class="line"></span><br><span class="line">| 操作符 | 描述 |</span><br><span class="line">|:---|:----|</span><br><span class="line">|yield x , yield from x |Yield 表达式 |</span><br><span class="line">|lambda|Lambda 表达式 |</span><br><span class="line">|if -- else | 条件表达式 |</span><br><span class="line">|or | 布尔或 |</span><br><span class="line">|and | 布尔与 |</span><br><span class="line">|not x | 布尔非 |</span><br><span class="line">|in , not in , is , is not , &lt;, &lt;= ,&gt; , &gt;= , != , ==| 比较，包含成员测试和类型测试 |</span><br><span class="line">|\|| 字节或 |</span><br><span class="line">|^| 字节异或 |</span><br><span class="line">|&amp;| 字节与 |</span><br><span class="line">|&lt;&lt;,&gt;&gt;| 移位 |</span><br><span class="line">|+ , -  | 加和减 |</span><br><span class="line">|* , @ , / , // , %| 乘，矩阵乘法，除，取余 |</span><br><span class="line">|+x , -x , ~x | 正数, 复数, 取反 |</span><br><span class="line">|** | 平方 |</span><br><span class="line">|await x    |Await 表达式 |</span><br><span class="line">|x[index] , x[index:index] , x(arguments...) , x.attribute | 子集，切片，调用，属性 |</span><br><span class="line">|(expressions...) , [expressions...] , &#123;key: value...&#125; , &#123;expressions...&#125;| 类型显示 |</span><br><span class="line"></span><br><span class="line">#### &lt;a name=&quot;Examples-of-await-expressions&quot;&gt;&lt;/a&gt;await 表达式示例</span><br><span class="line"></span><br><span class="line">有效的语法例子:</span><br><span class="line"></span><br><span class="line">| 表达式 | 会被处理为 |</span><br><span class="line">|:---|:---|</span><br><span class="line">|if await fut: pass |if (await fut): pass|</span><br><span class="line">|if await fut + 1: pass |if (await fut) + 1: pass|</span><br><span class="line">|pair = await fut, &apos;spam&apos;|  pair = (await fut), &apos;spam&apos;|</span><br><span class="line">|with await fut, open(): pass|with (await fut), open(): pass|</span><br><span class="line">|await foo()[&apos;spam&apos;].baz()()    |await (foo()[&apos;spam&apos;].baz()() )|</span><br><span class="line">|return await coro()|   return ( await coro() )|</span><br><span class="line">|res = await coro() ** 2    |res = (await coro()) ** 2|</span><br><span class="line">|func(a1=await coro(), a2=0)|   func(a1=(await coro()), a2=0)|</span><br><span class="line">|await foo() + await bar()  |(await foo()) + (await bar())|</span><br><span class="line">|-await foo()|  -(await foo())|</span><br><span class="line"></span><br><span class="line">错误的语法例子:</span><br><span class="line"></span><br><span class="line">| 表达式 | 应写作 |</span><br><span class="line">|:---|:---|</span><br><span class="line">|await await coro()|    await (await coro())|</span><br><span class="line">|await -coro()| await (-coro())|</span><br><span class="line"></span><br><span class="line">### &lt;a name=&quot;Asynchronous-Context-Managers&quot;&gt;&lt;/a&gt; 异步上下文管理与 ```async with</span><br></pre></td></tr></table></figure>

<p>一个异步上下文管理器是用于在 <figure class="highlight plain"><figcaption><span>和 ```exit``` 方法中管理暂停执行的上下文管理器。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">为此，我们设置了新的异步上下文管理器。添加了两个魔术方法： ```__aenter__``` 和 ```__aexit__```。这两个方法都返回 ```awaitable``` 对象。</span><br><span class="line"></span><br><span class="line">异步上下文管理器例子如下：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">class AsyncContextManager:</span><br><span class="line">    async def __aenter__(self):</span><br><span class="line">        await log(&apos;entering context&apos;)</span><br><span class="line"></span><br><span class="line">    async def __aexit__(self, exc_type, exc, tb):</span><br><span class="line">        await log(&apos;exiting context&apos;)</span><br></pre></td></tr></table></figure></p>
<h4 id="新语法"><a href="#新语法" class="headerlink" title=" 新语法"></a><a name="Async-With-New-Syntax"></a> 新语法</h4><p>一个新的异步上下文管理语法被接受：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> EXPR <span class="keyword">as</span> VAR:</span><br><span class="line">    BLOCK</span><br></pre></td></tr></table></figure>

<p>语义上等同于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mgr = (EXPR)</span><br><span class="line">aexit = type(mgr).__aexit__</span><br><span class="line">aenter = type(mgr).__aenter__(mgr)</span><br><span class="line">exc = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">VAR = <span class="keyword">await</span> aenter</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    BLOCK</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">await</span> aexit(mgr, *sys.exc_info()):</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">await</span> aexit(mgr, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>和普通的 <figure class="highlight plain"><figcaption><span>语句一样，可以在单个 ```async with``` 语句里指定多个上下文管理器。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在使用 ```async with``` 时，如果上下文管理器没有 ```__aenter__``` 和 ```__aexit__``` 方法，则会引发错误。在 ```async def``` 函数之外使用 ```async with``` 则会引发 ```SyntaxError``` 异常。</span><br><span class="line"></span><br><span class="line">#### &lt;a name=&quot;Async-With-Example&quot;&gt;&lt;/a&gt; 例子</span><br><span class="line"></span><br><span class="line">通过异步上下文管理器更容易实现协程对数据库事务的正确管理：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">async def commit(session, data):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    async with session.transaction():</span><br><span class="line">        ...</span><br><span class="line">        await session.update(data)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>代码看起来也更加简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> lock:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>而不是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (<span class="keyword">yield</span> <span class="keyword">from</span> lock):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h3 id="异步迭代器与"><a href="#异步迭代器与" class="headerlink" title=" 异步迭代器与 "></a><a name="Asynchronous-Iterators"></a> 异步迭代器与 <figure class="highlight plain"><figcaption><span>for```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一个异步迭代器能够在它的迭代实现里调用异步代码，也可以在它的 ```__next__``` 方法里调用异步代码。为了支持异步迭代，需要：</span><br><span class="line"></span><br><span class="line">1. 一个对象必须实现 ```__aiter__``` 方法（或者，使用 CPython C API 的 tp\_as\_async.am\_aiter 定义），返回一个异步迭代器对象中的 ```awaitable```` 结果。</span><br><span class="line">2. 一个异步迭代器必须实现 ```__anext__``` 方法（或者，使用 CPython C API 的 tp\_as\_async.am\_anext 定义）返回一个 ```awaitable```。</span><br><span class="line">3. 停止迭代器的 ```__anext__``` 必须抛出一个 ```StopAsyncIteration ``` 异常。</span><br><span class="line"></span><br><span class="line">一个异步迭代的例子：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">class AsyncIterable:</span><br><span class="line">    async def __aiter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    async def __anext__(self):</span><br><span class="line">        data = await self.fetch_data()</span><br><span class="line">        if data:</span><br><span class="line">            return data</span><br><span class="line">        else:</span><br><span class="line">            raise StopAsyncIteration</span><br><span class="line"></span><br><span class="line">    async def fetch_data(self):</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></h3><h4 id="新语法-1"><a href="#新语法-1" class="headerlink" title=" 新语法"></a><a name="Async-For-New-Syntax"></a> 新语法</h4><p>一种新的异步迭代方案被采纳：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">for</span> TARGET <span class="keyword">in</span> ITER:</span><br><span class="line">    BLOCK</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    BLOCK2</span><br></pre></td></tr></table></figure>

<p>语义上等同于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">iter = (ITER)</span><br><span class="line">iter = <span class="keyword">await</span> type(iter).__aiter__(iter)</span><br><span class="line">running = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> running:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        TARGET = <span class="keyword">await</span> type(iter).__anext__(iter)</span><br><span class="line">    <span class="keyword">except</span> StopAsyncIteration:</span><br><span class="line">        running = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        BLOCK</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    BLOCK2</span><br></pre></td></tr></table></figure>

<p>如果对一个普通的不含有 <figure class="highlight plain"><figcaption><span>方法的迭代器使用 ```async for```，会引发 ```TypeError``` 异常。如果在 ```async def``` 函数外使用 ```async for``` 会已发 ```SyntaxError``` 异常。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">和普通的 ```for``` 语法一样，```async for``` 有可选的 ```else``` 分支。</span><br><span class="line"></span><br><span class="line">#### &lt;a name=&quot;Async-For-Example-1&quot;&gt;&lt;/a&gt; 例子 1</span><br><span class="line"></span><br><span class="line">通过异步迭代器，就可以实现通过迭代实现异步缓冲数据：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">async for data in cursor:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>当 <figure class="highlight plain"><figcaption><span>是一个异步迭代器时，就可以在 N 次迭代后从数据库中预取 N 行数据。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下面的代码演示了新的异步迭代协议：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">class Cursor:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.buffer = collections.deque()</span><br><span class="line"></span><br><span class="line">    async def _prefetch(self):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    async def __aiter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    async def __anext__(self):</span><br><span class="line">        if not self.buffer:</span><br><span class="line">            self.buffer = await self._prefetch()</span><br><span class="line">            if not self.buffer:</span><br><span class="line">                raise StopAsyncIteration</span><br><span class="line">        return self.buffer.popleft()</span><br></pre></td></tr></table></figure></p>
<p>那么这个 <figure class="highlight plain"><figcaption><span>类可以按照下面的方式使用：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">async for row in Cursor():</span><br><span class="line">    print(row)</span><br></pre></td></tr></table></figure></p>
<p>这个等同于下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="keyword">await</span> Cursor().__aiter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        row = <span class="keyword">await</span> i.__anext__()</span><br><span class="line">    <span class="keyword">except</span> StopAsyncIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(row)</span><br></pre></td></tr></table></figure>

<h4 id="例子-2"><a href="#例子-2" class="headerlink" title=" 例子 2"></a><a name="Async-For-Example-2"></a> 例子 2</h4><p>下面的工具类用于将普通的迭代转换为异步。这个并没有什么实际的作用，这个代码只是用于演示普通迭代与异步迭代之间的关系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncIteratorWrapper</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        self._it = iter(obj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__aiter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__anext__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value = next(self._it)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">for</span> letter <span class="keyword">in</span> AsyncIteratorWrapper(<span class="string">"abc"</span>):</span><br><span class="line">    print(letter)</span><br></pre></td></tr></table></figure>

<h4 id="为什么使用"><a href="#为什么使用" class="headerlink" title=" 为什么使用 "></a><a name="Why-StopAsyncIteration"></a> 为什么使用 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">协程在内部实现中依旧是依赖于迭代器的。因此，在 [PEP-479](https://www.python.org/dev/peps/pep-0479) 生效之前，下面两者并没有区别：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">def g1():</span><br><span class="line">    yield from fut</span><br><span class="line">    return &apos;spam&apos;</span><br><span class="line">and</span><br><span class="line"></span><br><span class="line">def g2():</span><br><span class="line">    yield from fut</span><br><span class="line">    raise StopIteration(&apos;spam&apos;)</span><br></pre></td></tr></table></figure></h4><p>但是在 PEP 479 接受并且默认对协程开启时，下面的例子中的 <figure class="highlight plain"><figcaption><span>会被封装成 ```RuntimeError```。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">async def a1():</span><br><span class="line">    await fut</span><br><span class="line">    raise StopIteration(&apos;spam&apos;)</span><br></pre></td></tr></table></figure></p>
<p>所以，想通知外部代码迭代已经结束，抛出一个 <figure class="highlight plain"><figcaption><span>异常的是不行的。因此，一个新的内置异常类 ```StopAsyncIteration ``` 被引入进来了。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另外，根据 PEP 479，所有协程中抛出的 ```StopIteration``` 异常都会被封装成 ```RuntimeError```。</span><br><span class="line"></span><br><span class="line">### &lt;a name=&quot;Coroutine-objects&quot;&gt;&lt;/a&gt; 协程对象</span><br><span class="line">#### &lt;a name=&quot;Differences-from-generators&quot;&gt;&lt;/a&gt; 与生成器的不同之处</span><br><span class="line"></span><br><span class="line">这节进适用于 ```CO_COROUTINE``` 标记的原生协程，即，使用 ```async def``` 语法定义的对象。</span><br><span class="line"></span><br><span class="line">__现有的 asyncio 库中的 * 基于生成器的协程 * 的行为未做变更。__</span><br><span class="line"></span><br><span class="line">为了将协程与生成器区别开来，定义了下面的概念：</span><br><span class="line"></span><br><span class="line">1. 原生协程对象不实现 ```__iter__``` 和 ```__next__``` 方法。因此，他们不能够通过 ```iter()，list()，tuple()``` 和其他一些内置函数进行迭代。他们也不能用于 ```for...in``` 循环。   </span><br><span class="line">   在原生协程中尝试使用 ```__iter__``` 或者 ```__next``` 会触发 ```TypeError``` 异常。</span><br><span class="line">2. 未被装饰的生成器不能够 ```yield from``` 一个原生协程：这样会引发 ```TypeError```。</span><br><span class="line">3. 基于生成器的协程 (asyncio 代码必须使用 ```@asyncio.coroutine```) 可以 ```yield from``` 一个原生协程。</span><br><span class="line">4. 对原生协程对象和原生协程函数调用 ```inspect.isgenerator()``` 和 ```inspect.isgeneratorfunction()``` 会返回 False。</span><br><span class="line"></span><br><span class="line">#### &lt;a name=&quot;Coroutine-object-methods&quot;&gt;&lt;/a&gt; 协程对象方法</span><br><span class="line"></span><br><span class="line">协程内部基于生成器，因此他们同享实现过程。类似于生成器对象，协程包含 ```throw()```，```send()``` 和 ```close()``` 方法。```StopIteration``` 和 ```GeneratorExit``` 在协程中扮演者同样的角色（尽管 PEP 479 默认对协程开启了）。参考 [PEP-342](https://www.python.org/dev/peps/pep-0342), [PEP-380](https://www.python.org/dev/peps/pep-0380) 和 Python 文档了解更多细节。</span><br><span class="line"></span><br><span class="line">协程的 ```throw()``` 和 ```send()``` 方法可以用于将返回值和抛出异常推送到类似于 ```Future``` 的对象中。</span><br><span class="line"></span><br><span class="line">### &lt;a name=&quot;Debugging-Features&quot;&gt;&lt;/a&gt; 调试特性</span><br><span class="line"></span><br><span class="line">一个初学者普遍会犯的错误是忘记在协程中使用 ```yield from```。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def useful():</span><br><span class="line">    asyncio.sleep(1) # this will do noting without &apos;yield from&apos;</span><br></pre></td></tr></table></figure></p>
<p>为了调试这类错误，asycio 提供了一种特殊的调试模式：装饰器 <figure class="highlight plain"><figcaption><span>封装所有的函数成一个特殊对象，这个对象的析构函数中记录警告。当封装的生成器垃圾回收时，会产生详细的记录信息，包括具体定义修饰函数、回收时的栈信息等等。封装对象同样提供一个 ```__repr__``` 函数用于输出关于生成器的详细信息。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">唯一的问题是如何启用这些调试功能。这些调试工具在生产模式中什么都不做，```@coroutine``` 修饰符在系统变量 ```PYTHONASYNCIODEBUG ``` 设置后才会提供调试功能。这种方式可以让 asyncio 程序使用 asyncio 自己的函数分析。```EventLoop.set_debug``` 是另外一个调试工具，他不会影响 ```@coroutine``` 修饰符行为。</span><br><span class="line"></span><br><span class="line">根据本提议，协程是原生的与生成器不同的概念。当抛出 ```RuntimeWarning``` 异常的协程是从来没有被 ```awaited``` 过的。因此添加了两条新的函数到 sys 模块：```set_coroutine_wrapper``` 和 ```get_coroutine_wrapper```。这个用于开启 asyncio 或者其他框架中的高级调试 (比如显示协程创建的位置和垃圾回收时的栈信息)。</span><br><span class="line"></span><br><span class="line">### &lt;a name=&quot;New-Standard-Library-Functions&quot;&gt;&lt;/a&gt; 新的标准库函数</span><br><span class="line"></span><br><span class="line">* ```types.coroutine(gen)```。参考 [types.coroutine()](#Type-Coroutine) 节中的内容。</span><br><span class="line">* ```inspect.iscoroutine(obj)``` 当 obj 是原生协程时返回 True。</span><br><span class="line">* ```inspect.iscoroutinefunction(obj)``` 当 obj 是原生协程函数时返回为 True。</span><br><span class="line">* ```inspect.isawaitable(obj)``` 当 obj 是 ```awaitable``` 时返回为 True。</span><br><span class="line">* ```inspect.getcoroutinestate(coro)``` 返回原生协程对象的当前状态（是 ```inspect.getfgeneratorstate(gen)``` 的镜像）。</span><br><span class="line">* ```inspect.getcoroutinelocals(coro)``` 返回原生协程对象的局部变量的映射（是 ```inspect.getgeneratorlocals(gen)``` 的镜像）。</span><br><span class="line">* ```sys.set_coroutine_wrapper(wrapper)``` 允许拦截原生协程对象的创建。```wrapper``` 必须是一个接受一个参数 ```callable```（一个协程对象），或者是 ```None```。```None``` 会重置 ```wrapper```。当调用第二次时，新的 ```wrapper``` 会替代之前的封装。这个函数是线程专有的。参考 [调度调试](#Debugging-Features) 了解更多细节。</span><br><span class="line">* ```sys.get_coroutine_wrapper()``` 返回当前的封装对象。如果封装未设置会返回 None。这个函数是线程专有的。参考 [调度调试](#Debugging-Features) 了解更多细节。</span><br><span class="line"></span><br><span class="line">### &lt;a name=&quot;New-Abstract-Base-Classes&quot;&gt;&lt;/a&gt; 新的抽象基类</span><br><span class="line"></span><br><span class="line">为了允许更好的与现有的框架（比如 Tornado）和编译器（比如 Cython）整合，我们添加了两个新的抽象基类 (ABC)：   </span><br><span class="line">```collections.abc.Awaitable``` 是 ```Future-like``` 类的抽象基类，它实现了 ```__await__``` 方法。   </span><br><span class="line">```collections.abc.Coroutine``` 是协程对象的抽象基类，它实现了 ```send(value)```，```throw(type, exc, tb)```，```close()``` 和 ```__await__()``` 方法。</span><br><span class="line"></span><br><span class="line">值得注意的是，带有 ```CO_ITERABLE_COROUTINE``` 标记的基于生成器的协程并没有实现 ```__await__``` 方法，因此他不是 ```collections.abc.Coroutine``` 和 ```collections.abc.Awaitable``` 抽象类的实例：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">@types.coroutine</span><br><span class="line">def gencoro():</span><br><span class="line">    yield</span><br><span class="line"></span><br><span class="line">assert not isinstance(gencoro(), collections.abc.Coroutine)</span><br><span class="line"></span><br><span class="line"># 然而:</span><br><span class="line">assert inspect.isawaitable(gencoro())</span><br></pre></td></tr></table></figure></p>
<p>为了方便对异步迭代的调试，添加了另外两个抽象基类：</p>
<ul>
<li><figure class="highlight plain"><figcaption><span>-- 用于测试 ```__aiter__``` 方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* ```collections.abc.AsyncIterator``` -- 用于测试 ```__aiter__``` 和 ```__anext__``` 方法。</span><br><span class="line"></span><br><span class="line">## &lt;a name=&quot;Glossary&quot;&gt;&lt;/a&gt; 专用术语表   </span><br><span class="line">## &lt;a name=&quot;List-of-functions-and-methods&quot;&gt;&lt;/a&gt; 函数与方法列表   </span><br><span class="line">## &lt;a name=&quot;Transition-Plan&quot;&gt;&lt;/a&gt; 移植计划</span><br><span class="line">### &lt;a name=&quot;Backwards-Compatibility&quot;&gt;&lt;/a&gt; 向后兼容性</span><br><span class="line">#### &lt;a name=&quot;asyncio&quot;&gt;&lt;/a&gt;asyncio</span><br><span class="line">#### &lt;a name=&quot;asyncio-migration-strategy&quot;&gt;&lt;/a&gt;asyncio 移植策略</span><br><span class="line">#### &lt;a name=&quot;async-await-in-CPython-code-base&quot;&gt;&lt;/a&gt;CPython 代码中的 ```async/await</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="语法更新"><a href="#语法更新" class="headerlink" title=" 语法更新"></a><a name="Grammar-Updates"></a> 语法更新</h3><h3 id="失效计划"><a href="#失效计划" class="headerlink" title=" 失效计划"></a><a name="Deprecation-Plans"></a> 失效计划</h3><h2 id="性能"><a href="#性能" class="headerlink" title=" 性能"></a><a name="Performance"></a> 性能</h2><h3 id="总体影响"><a href="#总体影响" class="headerlink" title=" 总体影响"></a><a name="Overall-Impact"></a> 总体影响</h3><p>这个提议并不会造成性能影响。这是 Python 官方性能测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">python perf.py -r -b default ../cpython/python.exe ../cpython-aw/python.exe</span><br><span class="line"></span><br><span class="line">[skipped]</span><br><span class="line"></span><br><span class="line">Report on Darwin ysmac 14.3.0 Darwin Kernel Version 14.3.0:</span><br><span class="line">Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64</span><br><span class="line">x86_64 i386</span><br><span class="line"></span><br><span class="line">Total CPU cores: 8</span><br><span class="line"></span><br><span class="line">### etree_iterparse ###</span><br><span class="line">Min: 0.365359 -&gt; 0.349168: 1.05x faster</span><br><span class="line">Avg: 0.396924 -&gt; 0.379735: 1.05x faster</span><br><span class="line">Significant (t=9.71)</span><br><span class="line">Stddev: 0.01225 -&gt; 0.01277: 1.0423x larger</span><br><span class="line"></span><br><span class="line">The following not significant results are hidden, use -v to show them:</span><br><span class="line">django_v2, 2to3, etree_generate, etree_parse, etree_process, fastpickle,</span><br><span class="line">fastunpickle, json_dump_v2, json_load, nbody, regex_v8, tornado_http.</span><br></pre></td></tr></table></figure>

<h3 id="编译器修改"><a href="#编译器修改" class="headerlink" title=" 编译器修改"></a><a name="Tokenizer-modifications"></a> 编译器修改</h3><p>修改后的编译器处理 Python 文件没有明显的性能下降：处理 12MB 大小的文件（<figure class="highlight plain"><figcaption><span>重复 1000 次）消耗时间相同。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### &lt;a name=&quot;async-await&quot;&gt;&lt;/a&gt;```async/await</span><br></pre></td></tr></table></figure></p>
<p>下面的小测试用于检测『async』函数和生成器的性能差异：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    l = <span class="keyword">yield</span> <span class="keyword">from</span> binary(n - <span class="number">1</span>)</span><br><span class="line">    r = <span class="keyword">yield</span> <span class="keyword">from</span> binary(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> l + <span class="number">1</span> + r</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">abinary</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    l = <span class="keyword">await</span> abinary(n - <span class="number">1</span>)</span><br><span class="line">    r = <span class="keyword">await</span> abinary(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> l + <span class="number">1</span> + r</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span><span class="params">(func, depth, repeat)</span>:</span></span><br><span class="line">    t0 = time.time()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(repeat):</span><br><span class="line">        o = func(depth)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                o.send(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    t1 = time.time()</span><br><span class="line">    print(<span class="string">'&#123;&#125;(&#123;&#125;) * &#123;&#125;: total &#123;:.3f&#125;s'</span>.format(func.__name__, depth, repeat, t1-t0))</span><br></pre></td></tr></table></figure>

<p>结果显示并没有明显的性能差异：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">binary(19) * 30: total 53.321s</span><br><span class="line">abinary(19) * 30: total 55.073s</span><br><span class="line"></span><br><span class="line">binary(19) * 30: total 53.361s</span><br><span class="line">abinary(19) * 30: total 51.360s</span><br><span class="line"></span><br><span class="line">binary(19) * 30: total 49.438s</span><br><span class="line">abinary(19) * 30: total 51.047s</span><br></pre></td></tr></table></figure>

<p>注意：19 层意味着 1,048,575 调用。</p>
<h2 id="实现参考"><a href="#实现参考" class="headerlink" title=" 实现参考"></a><a name="Reference-Implementation"></a> 实现参考</h2><p>实现参考可以在 <a href="https://github.com/1st1/cpython/tree/await" target="_blank" rel="noopener">这里</a> 找到。</p>
<h3 id="上层修改和新协议列表"><a href="#上层修改和新协议列表" class="headerlink" title=" 上层修改和新协议列表"></a><a name="List-of-high-level-changes-and-new-protocols"></a> 上层修改和新协议列表</h3><ol>
<li>新的协程定义语法：<figure class="highlight plain"><figcaption><span>def``` 和新的 ```await``` 关键字。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">2. ```Future-like``` 对象提供新的 ```__await__``` 方法和新的 ```PyTypeObject ``` 的 ```tp_as_async.am_await```。</span><br><span class="line">3. 新的异步上下文管理器语法： ```async with```，协议提供了 ```__aenter__``` 和 ```__aexit__``` 方法。</span><br><span class="line">4. 新的异步迭代语法：```async for```，协议提供了 ```__aiter```、```__aexit``` 和新的内置异常 ```StopAsyncIteration```。```PyTypeObject``` 提供了新的 ```tp_as_async.am_aiter``` 和 ```tp_as_async.am_anext```。</span><br><span class="line">5. 新的 AST 节点：```AsyncFunctionDef```，```AsyncFor```，```AsyncWith``` 和 ```Await```。</span><br><span class="line">6. 新函数 ```sys.set_coroutine_wrapper(callback)```，```sys.get_coroutine_wrapper()```，```types.coroutine(gen)```，```inspect.iscoroutinefunction(func)```，```inspect.iscoroutine(obj)```，```inspect.isawaitable(obj)```，```inspect.getcoroutinestate(coro)``` 和 ```inspect.getcoroutinelocals(coro)```。</span><br><span class="line">7. 新的代码对象标记 ```CO_COROUTINE``` 和 ```CO_ITERABLE_COROUTINE```。</span><br><span class="line">8. 新的抽象基类 ```collections.abc.Awaitable```，```collections.abc.Coroutine```，```collections.abc.AsyncIterable``` 和 ```collections.abc.AsyncIterator```。</span><br><span class="line">9. C API 变更：新的 ```PyCoro_Type```（将 Python 作为 ```types.CoroutineType``` 输出）和 ```PyCoroObject```。```PyCoro_CheckExact(*o)``` 用于检测 o 是否为原生协程。</span><br><span class="line"></span><br><span class="line">虽然变化和新内容列表并不短，但是重要的是理解：大部分用户不会直接使用这些特性。他的目的是在于框架和库能够使用这些为用户提供便捷的使用和明确的 API 用于 ```async def```，```await```，```async for``` 和 ```async with``` 语法。</span><br><span class="line"></span><br><span class="line">### &lt;a name=&quot;working-example&quot;&gt;&lt;/a&gt; 可以工作的实例</span><br><span class="line"></span><br><span class="line">本 PEP 提出的所有概念都 [已经实现](https://github.com/1st1/cpython/tree/await)，并且可以被测试。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def echo_server():</span><br><span class="line">    print(&apos;Serving on localhost:8000&apos;)</span><br><span class="line">    await asyncio.start_server(handle_connection,&apos;localhost&apos;, 8000)</span><br><span class="line"></span><br><span class="line">async def handle_connection(reader, writer):</span><br><span class="line">    print(&apos;New connection...&apos;)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        data = await reader.read(8192)</span><br><span class="line"></span><br><span class="line">        if not data:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">        print(&apos;Sending &#123;:.10&#125;... back&apos;.format(repr(data)))</span><br><span class="line">        writer.write(data)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(echo_server())</span><br><span class="line">try:</span><br><span class="line">    loop.run_forever()</span><br><span class="line">finally:</span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2015/10/2015-10-30-write-aio-python-redis-client-as-dummy-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/10/2015-10-30-write-aio-python-redis-client-as-dummy-2/" class="post-title-link" itemprop="url">从零实现一个 Redis 客户端（二）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-30 23:11:15" itemprop="dateCreated datePublished" datetime="2015-10-30T23:11:15+08:00">2015-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2015/10/2015-10-30-write-aio-python-redis-client-as-dummy-2/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/10/2015-10-30-write-aio-python-redis-client-as-dummy-2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="从-Call-到命令端"><a href="#从-Call-到命令端" class="headerlink" title="从 Call 到命令端"></a>从 Call 到命令端</h2><p>在第一个文章中，我们介绍了实现一个 Call 的客户端基本模型，但只是 Call 怎么能满足需求呢？比如在 redis-py 中，一个完整的客户端应该是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client = redis.StrictRedis()</span><br><span class="line">client.setex(<span class="string">"key"</span>, <span class="number">10</span>, <span class="string">"value"</span>)</span><br></pre></td></tr></table></figure>

<p>接下来作为一个程序的客户端，需要去做的就是封装出一个 Redis Client。比如 setex 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setex</span><span class="params">(self, key, seconds, value)</span>:</span></span><br><span class="line">    <span class="string">"""Set the value and expiration of a key.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :raises TypeError: if seconds is neither int</span></span><br><span class="line"><span class="string">    """</span><span class="keyword">if</span> <span class="keyword">not</span> isinstance(seconds, int):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">"milliseconds argument must be int"</span>)</span><br><span class="line">    fut = self._conn.execute(<span class="string">b'SETEX'</span>, key, seconds, value)</span><br><span class="line">    <span class="keyword">return</span> wait_ok(fut)</span><br></pre></td></tr></table></figure>

<p>剩下的就是一个个方法逐个完善。</p>
<h2 id="什么是连接池"><a href="#什么是连接池" class="headerlink" title="什么是连接池"></a>什么是连接池</h2><p>我们会看到，无论那个数据库客户端，总是会有连接池机制。那么连接池是什么呢？我们为什么需要连接池呢？</p>
<p>首先，我们都知道，对连接而言，创建是必要重型的操作。比如说，TCP 连接，接下来之后是登录认证等等过程，最后才会执行命令。这也就是我们通常计算库性能时，很多时候会把建立连接的时候去掉。但是这就出现了一个问题，当一个连接被占用时，其他的操作仍旧是不能够完成操作了，只能等待前一个操作完成。但是假如我们一次性创建一堆连接呢？从一堆连接中找到空闲的连接，使用完成后释放成空闲的状态，这就是线程池的本质。因为减少了每次创建连接的过程，所以对性能提升也非常有帮助。</p>
<h2 id="从单连接到连接池"><a href="#从单连接到连接池" class="headerlink" title="从单连接到连接池"></a>从单连接到连接池</h2><p>首先，还是创建一个 RedisPool 类，用于管理 Redis 的连接池。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisPool</span>:</span></span><br><span class="line">    <span class="string">"""Redis connections pool."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, address, db=<span class="number">0</span>, password=None, encoding=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 *, minsize, maxsize, commands_factory, loop=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> loop <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            loop = asyncio.get_event_loop()</span><br><span class="line">        self._address = address</span><br><span class="line">        self._db = db</span><br><span class="line">        self._password = password</span><br><span class="line">        self._encoding = encoding</span><br><span class="line">        self._minsize = minsize</span><br><span class="line">        self._factory = commands_factory</span><br><span class="line">        self._loop = loop  <span class="comment"># 连接池数组</span></span><br><span class="line">        self._pool = collections.deque(maxlen=maxsize)</span><br><span class="line">        self._used = set()</span><br><span class="line">        self._acquiring = <span class="number">0</span></span><br><span class="line">        self._cond = asyncio.Condition(loop=loop)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_create_new_connection</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> create_redis(self._address,</span><br><span class="line">                            db=self._db,</span><br><span class="line">                            password=self._password,</span><br><span class="line">                            encoding=self._encoding,</span><br><span class="line">                            commands_factory=self._factory,</span><br><span class="line">                            loop=self._loop)</span><br></pre></td></tr></table></figure>

<p>接下来，就需要创建大量的连接了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_pool</span><span class="params">(self, *, override_min)</span>:</span></span><br><span class="line">    <span class="comment"># todo: drop closed connections first</span></span><br><span class="line">    <span class="comment"># 判断是否达到了连接池数量限制</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> self._pool <span class="keyword">and</span> self.size &lt; self.maxsize:</span><br><span class="line">        self._acquiring += <span class="number">1</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            conn = <span class="keyword">await</span> self._create_new_connection()</span><br><span class="line">            self._pool.append(conn)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._acquiring -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># connection may be closed at yeild point</span></span><br><span class="line">            self._drop_closed()</span><br></pre></td></tr></table></figure>

<p>那么怎么从这些连接中抽取连接并且进行连接呢:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self)</span>:</span></span><br><span class="line">	<span class="string">"""Acquires a connection from free pool.</span></span><br><span class="line"><span class="string">	Creates new connection if needed.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="keyword">with</span> <span class="keyword">await</span> self._cond:</span><br><span class="line">	    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	        <span class="keyword">await</span> self._fill_free(override_min=<span class="literal">True</span>)</span><br><span class="line">	        <span class="keyword">if</span> self.freesize:</span><br><span class="line">	            conn = self._pool.popleft()</span><br><span class="line">	            <span class="keyword">assert</span> <span class="keyword">not</span> conn.closed, conn</span><br><span class="line">	            <span class="keyword">assert</span> conn <span class="keyword">not</span> <span class="keyword">in</span> self._used, (conn, self._used)</span><br><span class="line">	            self._used.add(conn)</span><br><span class="line">	            <span class="keyword">return</span> conn</span><br><span class="line">	        <span class="keyword">else</span>:</span><br><span class="line">	            <span class="keyword">await</span> self._cond.wait()</span><br></pre></td></tr></table></figure>

<p>接下来就是使用完成后进行释放即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">release</span><span class="params">(self, conn)</span>:</span></span><br><span class="line">     <span class="string">"""Returns used connection back into pool.</span></span><br><span class="line"><span class="string">     When returned connection has db index that differs from one in pool</span></span><br><span class="line"><span class="string">     the connection will be closed and dropped.</span></span><br><span class="line"><span class="string">     When queue of free connections is full the connection will be dropped.</span></span><br><span class="line"><span class="string">     """</span><span class="keyword">assert</span> conn <span class="keyword">in</span> self._used,<span class="string">"Invalid connection, maybe from other pool"</span>self._used.remove(conn)</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> conn.closed:</span><br><span class="line">         <span class="keyword">if</span> conn.in_transaction:</span><br><span class="line">             logger.warning(<span class="string">"Connection %r in transaction, closing it."</span>,</span><br><span class="line">                            conn)</span><br><span class="line">             conn.close()</span><br><span class="line">         <span class="keyword">elif</span> conn.db == self.db:</span><br><span class="line">             <span class="keyword">if</span> self.maxsize <span class="keyword">and</span> self.freesize &lt; self.maxsize:</span><br><span class="line">                 self._pool.append(conn)</span><br><span class="line">             <span class="keyword">else</span>:</span><br><span class="line">                 <span class="comment"># consider this connection as old and close it.</span></span><br><span class="line">                 conn.close()</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             conn.close()</span><br><span class="line">     <span class="comment"># <span class="doctag">FIXME:</span> check event loop is not closed</span></span><br><span class="line">     asyncio.<span class="keyword">async</span>(self._wakeup(), loop=self._loop)</span><br></pre></td></tr></table></figure>

<p>至此，你已经可以实现一个基本的 Redis 客户端了，还在犹豫什么？快自己动手吧！</p>
<p><strong>注: 文中 Redis 库参考了 aio-lib/aioredis 库。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.4async.com/2015/10/2015-10-10-write-aio-python-redis-client-as-dummy-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
      <meta itemprop="name" content="ipfans">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ipfans's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/10/2015-10-10-write-aio-python-redis-client-as-dummy-1/" class="post-title-link" itemprop="url">零基础编写 Python Redis Client（一）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-10 18:11:15" itemprop="dateCreated datePublished" datetime="2015-10-10T18:11:15+08:00">2015-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 11:20:39" itemprop="dateModified" datetime="2019-07-04T11:20:39+08:00">2019-07-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2015/10/2015-10-10-write-aio-python-redis-client-as-dummy-1/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/10/2015-10-10-write-aio-python-redis-client-as-dummy-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是-AIO"><a href="#什么是-AIO" class="headerlink" title="什么是 AIO"></a>什么是 AIO</h2><p>AIO 是 Asynchronous Input/Output 的简写，也就是异步 IO。不过在谈什么是 AIO 之前，我们可能要先介绍一下 BIO。那么什么是 BIO 呢？简单的说，BIO 是 Blocking Input/Output，也就是阻塞 IO，他实现的通常是在线程池中找出一个线程处理 IO，在 IO 过程中，其他线程都需要等待 IO 完成后才可以从中选取一个线程占用 IO。这样最大的问题是，当线程数量较多，并且需要大量的 IO 操作时，就会造成一个大量的阻塞，因为实际上每次只有一个线程在处理 IO。</p>
<p>那么如何解决这个时候的问题呢？这时候就提出了 AIO 的概念。通常在 IO 处理过程中也会伴有一些其他的处理操作，假如把所有的操作都浪费在了等待 IO 释放上，线程池中的线程利用率也太低了，因此我们需要一种方式，在申请 IO 处理之后，就去继续做其他的事情，等 IO 操作完成了，然后通知我们已经 OK，我们可以继续处理了。这也就是我们常说的 AIO 的原型。</p>
<p>AIO 的情况也说明了它适用的场景：长连接场景，或者重度的 IO 操作等等的情况。</p>
<p>如果找软件来做案例，我们可以找一个可能大家熟知的：NGINX。正如我们所知，NGINX 采用了 <a href="http://nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/" target="_blank" rel="noopener">异步、事件驱动的方法来处理连接</a>。这种处理方式无需（像使用传统架构的服务器一样）为每个请求创建额外的专用进程或者线程，而是在一个工作进程中处理多个连接和请求。为此，NGINX 工作在非阻塞的 socket 模式下，并使用了 epoll 和 kqueue 这样有效的方法。</p>
<p>这部分的内容，在 <a href="http://www.infoq.com/cn/articles/thread-pools-boost-performance-9x" target="_blank" rel="noopener">NGINX 引入线程池 性能提升 9 倍</a> 中进行了详细的介绍，包含了 NGINX 的异步应用经验，同时介绍了 NGINX 中引入了阻塞的线程池用于解决某些特定场景问题下的效率。</p>
<h2 id="如何实现-Python-的异步-IO"><a href="#如何实现-Python-的异步-IO" class="headerlink" title="如何实现 Python 的异步 IO"></a>如何实现 Python 的异步 IO</h2><p>这篇文章会以最新的 Python 3.5 为基础来介绍实现一个异步的 Python Redis Client。不过在此之前，我们先来看一下，怎么实现 Python 的 aio。</p>
<p>Python 的 aio 官方封装了一个比较合适的基础库 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从一个例子开始简单认识一下如何实现一个异步的 aio client。这里以官方文档中的例子为例：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def tcp_echo_client(message, loop):</span><br><span class="line">    reader, writer = await asyncio.open_connection(&apos;127.0.0.1&apos;, 8888,</span><br><span class="line">                                                   loop=loop)</span><br><span class="line"></span><br><span class="line">    print(&apos;Send: %r&apos; % message)</span><br><span class="line">    writer.write(message.encode())</span><br><span class="line"></span><br><span class="line">    data = await reader.read(100)</span><br><span class="line">    print(&apos;Received: %r&apos; % data.decode())</span><br><span class="line"></span><br><span class="line">    print(&apos;Close the socket&apos;)</span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line">message = &apos;Hello World!&apos;</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(tcp_echo_client(message, loop))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure></p>
<p>这里面用到的 Python 3.5 中引入的 <figure class="highlight plain"><figcaption><span>关键字，还有 ```asyncio``` 库。这里面 ```asyncio.open_connection``` 会返回一个 coroutine，这个可以使用 await 进行一个 aio 的调用，即，在收到返回信号之前，程序可以继续去处理其他的任务。这里面真正核心的就是 ```EventLoop```，它负责监视发送这些信号，并且返回数据，它可以通过 ```asyncio.get_event_loop``` 获取到。然后他会真正返回的数据是一个读取 ```StreamReader``` 和写入 ```StreamWriter``` 的对象。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接下来，就可以通过这个 ```reader``` 和 ```writer``` 进行数据的读取和写入。```writer``` 是可以直接写入的，如果是 ```reader``` 的话，就需要 aio 的方式等待受到数据后返回。这样看起来更接近于普通的 socket 编程。不过关闭连接时，仅仅需要关闭 ```writer``` 就足够了。</span><br><span class="line"></span><br><span class="line">从 socket 通讯到 redis 通讯</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">本质上来说，所有的网络请求都可以看成是 SocketIO 的请求，因此，我们可以把 Redis 的请求当做是一个 socket 的通讯来进行，这样就很方便了。</span><br><span class="line"></span><br><span class="line">不过先等一等，那么通讯的数据格式怎么办？没关系，这里我们使用 ```hiredis-py``` 来解决协议解析的问题。不过，从库设计的角度来说，我们需要封装一个 RedisConnection 的类出来解决 Redis 的通讯协议。它可能传入的参数包含，一个 ```StreamReader```、一个 ```StreamWriter```，一个 ```EventLoop```，哦，别忘记还有编码 ```encoding```。其他的我们就用一个 ```*``` 来表示好了。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">class RedisConnection(object):</span><br><span class="line">    &apos;&apos;&apos;Redis Connection&apos;&apos;&apos;</span><br><span class="line">    def __init__(self, reader, writer, *, encoding=None, loop=None):</span><br><span class="line">        if loop is None:</span><br><span class="line">            loop = asyncio.get_event_loop()</span><br><span class="line">        self._reader = reader</span><br><span class="line">        self._writer = writer</span><br><span class="line">        self._encoding = encoding</span><br><span class="line">        self._loop = loop</span><br><span class="line">        self._db = 0</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;RedisConnection [db:&#123;&#125;]&gt;&apos;.format(self._db)</span><br></pre></td></tr></table></figure></p>
<p>记得加上 <figure class="highlight plain"><figcaption><span>用来描述这个对象，这个可是一个好习惯。接下来就需要完善这个类了，比如，我们需要添加一个关闭连接的方法，这需要至少一个参数用于标记连接是否关闭，一个用于执行关闭操作，比如我们需要这样子的：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">    def close(self):</span><br><span class="line">        &quot;&quot;&quot;Close connection.&quot;&quot;&quot;</span><br><span class="line">        self._do_close(None)</span><br><span class="line"></span><br><span class="line">    def _do_close(self, exc):</span><br><span class="line">        if self._closed:</span><br><span class="line">            return</span><br><span class="line">        self._closed = True</span><br><span class="line">        self._closing = False</span><br><span class="line">        # 关闭写入</span><br><span class="line">        self._writer.transport.close()</span><br><span class="line">        # 取消读取任务</span><br><span class="line">        self._reader_task.cancel()</span><br><span class="line">        self._reader_task = None</span><br><span class="line">        self._writer = None</span><br><span class="line">        self._reader = None</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def closed(self):</span><br><span class="line">        &quot;&quot;&quot;True if connection is closed.&quot;&quot;&quot;</span><br><span class="line">        closed = self._closing or self._closed</span><br><span class="line">        if not closed and self._reader and self._reader.at_eof():</span><br><span class="line">            self._closing = closed = True</span><br><span class="line">            self._loop.call_soon(self._do_close, None)</span><br><span class="line">        return closed</span><br></pre></td></tr></table></figure></p>
<p>连接这类的方法已经处理完了，接下来就应该是执行 Redis 命令了，我们可以叫它 <figure class="highlight plain"><figcaption><span>```command```，一个是指令参数 ```*args```，还有一些其他的，比如编码 ```encoding```。这里为了节省时间，只是考虑一些 Set 和 Get 的基本操作。哦，不过等等，那么 Redis 的数据结构是什么样子的呢？我们还需要先把它编译成 Redis-server 可以识别的形式，那么需要一个 ```encode_command``` 方法。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">_converters = &#123;</span><br><span class="line">    bytes: lambda val: val,</span><br><span class="line">    bytearray: lambda val: val,</span><br><span class="line">    str: lambda val: val.encode(&apos;utf-8&apos;),</span><br><span class="line">    int: lambda val: str(val).encode(&apos;utf-8&apos;),</span><br><span class="line">    float: lambda val: str(val).encode(&apos;utf-8&apos;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encode_command(*args):</span><br><span class="line">    &quot;&quot;&quot;Encodes arguments into redis bulk-strings array.</span><br><span class="line">    Raises TypeError if any of args not of bytes, str, int or float type.</span><br><span class="line">    &quot;&quot;&quot;buf = bytearray()</span><br><span class="line"></span><br><span class="line">    def add(data):</span><br><span class="line">        return buf.extend(data + b&apos;\r\n&apos;)</span><br><span class="line"></span><br><span class="line">    add(b&apos;*&apos;+ _bytes_len(args))</span><br><span class="line">    for arg in args:</span><br><span class="line">        if type(arg) in _converters:</span><br><span class="line">            barg = _converters[type(arg)](arg)</span><br><span class="line">            add(b&apos;$&apos;+ _bytes_len(barg))</span><br><span class="line">            add(barg)</span><br><span class="line">        else:</span><br><span class="line">            raise TypeError(&quot;Argument &#123;!r&#125; expected to be of bytes,&quot;&quot;str, int or float type&quot;.format(arg))</span><br><span class="line">    return buf</span><br></pre></td></tr></table></figure></p>
<p>这样可以转化为可以识别的形式了，接下来还有一个问题，那么怎么让程序可以等待信号的生效呢？这里介绍一下 <figure class="highlight plain"><figcaption><span>```asyncio.Future``` 类是用于封装回调函数的类，包含了一些更加方便使用的方法。通过这个类，可以实现 aio 的通知机制，也就是回调。这个类实例可以通过 ```await``` 返回我们需要的结果。不过这样就还需要在项目中添加一些更多的变量，比如所有等待返回的 ```self._waiters```。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">    def execute(self, command, *args, encoding=None):</span><br><span class="line">        &quot;&quot;&quot;Executes redis command and returns Future waiting for the answer.</span><br><span class="line">        Raises:</span><br><span class="line">        * TypeError if any of args can not be encoded as bytes.</span><br><span class="line">        * ReplyError on redis &apos;-ERR&apos; resonses.</span><br><span class="line">        * ProtocolError when response can not be decoded meaning connection</span><br><span class="line">          is broken.</span><br><span class="line">        &quot;&quot;&quot;assert self._reader and not self._reader.at_eof(), (&quot;Connection closed or corrupted&quot;)</span><br><span class="line">        if command is None:</span><br><span class="line">            raise TypeError(&quot;command must not be None&quot;)</span><br><span class="line">        if None in set(args):</span><br><span class="line">            raise TypeError(&quot;args must not contain None&quot;)</span><br><span class="line">        # 这样小写也没有问题了</span><br><span class="line">        command = command.upper().strip()</span><br><span class="line">        if encoding is None:</span><br><span class="line">            encoding = self._encoding</span><br><span class="line">        fut = asyncio.Future(loop=self._loop)</span><br><span class="line">        self._writer.write(encode_command(command, *args))</span><br><span class="line">        self._waiters.append((fut, encoding, cb))</span><br><span class="line">        return fut</span><br></pre></td></tr></table></figure></p>
<p>现在所有的命令都已经发送到了 redis-server，接下来就需要读取对应的结果了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_read_data</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Response reader task."""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> self._reader.at_eof():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = <span class="keyword">await</span> self._reader.read(<span class="number">65536</span>)</span><br><span class="line">        <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="comment"># <span class="doctag">XXX:</span> for QUIT command connection error can be received</span></span><br><span class="line">            <span class="comment">#       before response</span></span><br><span class="line">            logger.error(<span class="string">"Exception on data read %r"</span>, exc, exc_info=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        self._parser.feed(data)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                obj = self._parser.gets()</span><br><span class="line">            <span class="keyword">except</span> ProtocolError <span class="keyword">as</span> exc:</span><br><span class="line">                <span class="comment"># ProtocolError is fatal</span></span><br><span class="line">                <span class="comment"># so connection must be closed</span></span><br><span class="line">                self._closing = <span class="literal">True</span></span><br><span class="line">                self._loop.call_soon(self._do_close, exc)</span><br><span class="line">                <span class="keyword">if</span> self._in_transaction:</span><br><span class="line">                    self._transaction_error = exc</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self._process_data(obj)</span><br><span class="line">    self._closing = <span class="literal">True</span></span><br><span class="line">    self._loop.call_soon(self._do_close, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_process_data</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">    <span class="string">"""Processes command results."""</span></span><br><span class="line">    waiter, encoding, cb = self._waiters.popleft()</span><br><span class="line">    <span class="keyword">if</span> waiter.done():</span><br><span class="line">        logger.debug(<span class="string">"Waiter future is already done %r"</span>, waiter)</span><br><span class="line">        <span class="keyword">assert</span> waiter.cancelled(), (<span class="string">"waiting future is in wrong state"</span>, waiter, obj)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(obj, RedisError):</span><br><span class="line">        waiter.set_exception(obj)</span><br><span class="line">        <span class="keyword">if</span> self._in_transaction:</span><br><span class="line">            self._transaction_error = obj</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> encoding <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                obj = decode(obj, encoding)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">                waiter.set_exception(exc)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        waiter.set_result(obj)</span><br><span class="line">        <span class="keyword">if</span> cb <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cb(obj)</span><br></pre></td></tr></table></figure>

<p>有了这些之后，我们就可以简单创建一个连接了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_connection</span><span class="params">(address, *, db=None, password=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                      encoding=None, loop=None)</span>:</span></span><br><span class="line">    <span class="string">"""Creates redis connection.</span></span><br><span class="line"><span class="string">    Opens connection to Redis server specified by address argument.</span></span><br><span class="line"><span class="string">    Address argument is similar to socket address argument, ie:</span></span><br><span class="line"><span class="string">    * when address is a tuple it represents (host, port) pair;</span></span><br><span class="line"><span class="string">    * when address is a str it represents unix domain socket path.</span></span><br><span class="line"><span class="string">    (no other address formats supported)</span></span><br><span class="line"><span class="string">    Encoding argument can be used to decode byte-replies to strings.</span></span><br><span class="line"><span class="string">    By default no decoding is done.</span></span><br><span class="line"><span class="string">    Return value is RedisConnection instance.</span></span><br><span class="line"><span class="string">    This function is a coroutine.</span></span><br><span class="line"><span class="string">    """</span><span class="keyword">assert</span> isinstance(address, (tuple, list, str)), <span class="string">"tuple or str expected"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isinstance(address, (list, tuple)):</span><br><span class="line">        host, port = address</span><br><span class="line">        reader, writer = <span class="keyword">await</span> asyncio.open_connection(host, port, loop=loop)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        reader, writer = <span class="keyword">await</span> asyncio.open_unix_connection(address, loop=loop)</span><br><span class="line">    conn = RedisConnection(reader, writer, encoding=encoding, loop=loop)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> password <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> conn.auth(password)</span><br><span class="line">        <span class="keyword">if</span> db <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> conn.select(db)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        conn.close()</span><br><span class="line">    <span class="keyword">return</span> conn</span><br></pre></td></tr></table></figure>

<p>这样，连接部分的代码基本上已经处理完成了，接下来要做的就是实现基于这个连接的命令执行了，下面的内容会下一个文章中继续介绍，敬请期待。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ipfans"
      src="https://avatars0.githubusercontent.com/u/363344?v=3&s=460">
  <p class="site-author-name" itemprop="name">ipfans</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ipfans" title="GitHub → https://github.com/ipfans" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/janxin" title="Twitter → https://twitter.com/janxin" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2013 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ipfans</span>
</div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://s1mbily.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

  <script>
  var link = "" ;
  // 遍历所有的img标签
  $("img").each( (i,o) => {
    var o = $(o);
      // 判断图片的链接是否包含sinaimg关键字
    if( o.attr("src").indexOf("sinaimg") > 0 ){
          // 给这个标签加上referrerPlicy属性
      o.attr("referrerpolicy","no-referrer");
          // 备份图片的src
      link = o.attr("src");
          // 重新设置src，让页面重新加载一次图片
      o.attr("src",link);
    }
  });
  </script>
</body>
</html>
