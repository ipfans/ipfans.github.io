<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ipfans's Blog</title><link>https://www.4async.com/</link><description>Recent content on ipfans's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 25 Jan 2023 09:39:00 +0000</lastBuildDate><atom:link href="https://www.4async.com/atom.xml" rel="self" type="application/rss+xml"/><item><title>Twirp初相识</title><link>https://www.4async.com/2023/01/twirp-first-step/</link><pubDate>Wed, 25 Jan 2023 09:39:00 +0000</pubDate><guid>https://www.4async.com/2023/01/twirp-first-step/</guid><description>&lt;img src="https://www.4async.com/2023/01/twirp-first-step/cover.png" alt="Featured image of post Twirp初相识" />什么是Twirp？ Twirp是Twitch在2018年开源的RPC框架。正如同他们在发布文章中说的那样，RPC相对于普通的RESTful API更方便设计、组织和维护，让开发者更加专注于业务。但是同样的，在Go社区中重要的gRPC方案严重与HTTP/2绑定，这也成为一个制约其推广的问题：HTTP/2的复杂性其实并不必要；与Go Runtime的割裂也是另外一个问题，导致部分优化难以直接通过升级Go版本在gRPC上显现。
Twirp则选择保留了部分好的地方：使用Protobuf这个IDL约束请求/返回类型，这样可以最大化借助Protobuf带来的优势，生成客户端和服务端代码。但是Twirp选择与Go标准库集成，这样可以更好的利用Go本身升级带来的优化。这同时也保证了Twirp本身的简洁性。同时，你也可以很方便的使用cURL等传统工具，借助json请求测试，而不需要手工处理二进制数据。同样的，借助Go标准库，未来Twirp可以更好的升级成HTTP/3而不是像gRPC一样等待上游更新。当然如果你更倾向于使用gRPC相关的实践，那么connect-go可能是你的另外一个不错选择。
当然，如果说缺点，Twirp并不完美：小众的社区，缺少生态，缺少相关信息内容等等。不过这些仍旧是瑕不掩瑜。毕竟实现一个相关的功能其实并不那么复杂。
如何使用Twirp Twirp虽然官网比较简单，甚至社区也不是很大的样子，但是基本上需求的数据基本都可以在官网上找到入口。但是这也有个问题，导致整个流程对新手并不友好，有比较高的上手门槛。接下来的内容主要是完善这部分的内容，方便新手用户使用。
安装Protobuf相关工具 由于Twirp同样使用Protobuf，我们需要使用相关工具。首先是Protobuf，接下来是一些protoc-gen工具：
brew install protobuf # Mac Only go install google.golang.org/protobuf/cmd/protoc-gen-go@latest go install github.com/twitchtv/twirp/protoc-gen-twirp@latest 可选项：Buf Buf是一个Protobuf管理工具，帮助你实现Schema Driven Development实践。它提供了一个CLI管理工具（支持lint，生成和破坏性检查等功能）和类似注册中心机制的BSR(Buf Schema Registry)，你可以在这里管理你的Schema版本和引用其他公开服务的Schema。不使用Buf并不会带来功能缺失，并且Buf提供了付费SaaS服务(测试期间免费)，可以根据你的情况选择是否使用。
brew install bufbuild/buf/buf # Mac Only 可选项：Taskfile Taskfile是我常用来替代Makefile的工具。这并不是必须的工具，你同样可以使用手工执行命令行和Makefile命令进行。事实上，使用Makefile其实可以更好的在Jenkins之类的pipeline里执行，但是对Github Action等现代pipeline而言，区别并不大。
brew install go-task/tap/go-task # Mac Only 生成项目文件 这里我们使用一个简单的Greeter程序演示使用。假设我们已经存在了一个Go的空项目，那么我们接下来需要创建对应的目录和文件。按照官方的建议，我们可以使用如下结构创建我们的项目，你可以在Github上查看完整的代码：
$ tree . . ├── README.md ├── Taskfile.yaml ├── buf.gen-ts.yaml ├── buf.gen.yaml ├── buf.yaml ├── build ├── client │ ├── package.json │ ├── pnpm-lock.yaml │ └── src │ └── protoc-gen-twirp-es.</description></item><item><title>去年的一点小工作(1)：从BFF谈起</title><link>https://www.4async.com/2023/01/something-happend-in-2022-1/</link><pubDate>Sat, 21 Jan 2023 17:55:39 +0000</pubDate><guid>https://www.4async.com/2023/01/something-happend-in-2022-1/</guid><description>&lt;img src="https://www.4async.com/2023/01/something-happend-in-2022-1/cover.jpg" alt="Featured image of post 去年的一点小工作(1)：从BFF谈起" />&lt;p>前年底，之前创业的公司关掉正式回归了打工生活。现在在一家SaaS公司做一些新业务开发和架构的工作。这个系列的文章也是想整理一下2022年的一些小成果，有一些内容和相关背景可能因为各种原因无法描述更细节的内容，也请各位见谅。&lt;/p>
&lt;h1 id="后端和前端的配合我们遇到了什么问题">后端和前端的配合，我们遇到了什么问题？&lt;/h1></description></item><item><title>Byebye 2022, Hello 2023</title><link>https://www.4async.com/2023/01/byebye-2022-hello-2023/</link><pubDate>Sun, 01 Jan 2023 17:53:39 +0000</pubDate><guid>https://www.4async.com/2023/01/byebye-2022-hello-2023/</guid><description>&lt;img src="https://www.4async.com/2023/01/byebye-2022-hello-2023/2022-2023.jpg" alt="Featured image of post Byebye 2022, Hello 2023" /></description></item><item><title>给hugo添加mermaid支持</title><link>https://www.4async.com/2022/12/add-mermaid-support-for-hugo/</link><pubDate>Mon, 26 Dec 2022 17:48:00 +0000</pubDate><guid>https://www.4async.com/2022/12/add-mermaid-support-for-hugo/</guid><description>&lt;img src="https://www.4async.com/2022/12/add-mermaid-support-for-hugo/gohugo.png" alt="Featured image of post 给hugo添加mermaid支持" />&lt;p>发现2022年居然一篇博客都没写，一方面是疫情原因实在太糟心，另外一方面是环境使然，2022年一年都在适应新环境和拼命的推动项目前行。立个Flag，保证明年至少一个季度有一篇文章吧。&lt;/p>
&lt;p>这篇文章是为了提示如何在hugo中添加mermaid支持，mermaid是一个流程图的工具，可以在markdown中直接使用，非常方便。其实在hugo官方文档中已经有了说明，但是我在使用的时候发现对新人不是特别友好，所以这里记录一下，顺便水一个。&lt;/p></description></item><item><title>一些实用工具列表</title><link>https://www.4async.com/2021/11/awesome-toolkit/</link><pubDate>Mon, 29 Nov 2021 17:48:00 +0000</pubDate><guid>https://www.4async.com/2021/11/awesome-toolkit/</guid><description>&lt;img src="https://www.4async.com/2021/11/awesome-toolkit/toolkit.png" alt="Featured image of post 一些实用工具列表" />一些在工作中经常使用的一些工具。如果有什么推荐的，也欢迎在评论中提供。这个列表后续会持续更新
HTTP工具 curlie - httpie-like 工具，底层是curl lego - Let&amp;rsquo;s Encrypt证书工具 mkcert - 方便导入本地证书 paw.cloud - 原生的macOS HTTP调试工具，现在每年都会免费送，有兴趣关注一下 编译工具 go-task - 我用来替代Makefile，并无什么特殊必要，主要是不想写Makefile 代码质量 golangci-lint - 感觉无需介绍了，集成了很多实用工具，重复的就不列举了 pre-commit - 提交前检查代码质量，比如代码风格，缩进，空格等等 dcd - 查找代码中的重复代码 代码统计 scc - 高性能统计代码行数 图表工具 go-diagrams - 使用Go语言描述系统架构图 ndiag - 如果不想用Go描述，也可以选择用YAML描述系统架构 draft - 另外一个用YAML描述的工具，风格不一样 k8sviz - 你也可以从现成的K8s环境中生成系统架构图 archview - 通过代码中注释生成应用内部分层结构 go-plantuml - 根据Go代码生成结构体的PlantUML图 goplantuml - 另外一种生成PlantUML的工具 go-erd - 不想用PlantUML也可以换这种风格 asciiflow - 可以画ASCII图，ASCII图好处是可以放在代码里，如果你愿意的话 sequence - 嫌弃asciiflow比较原始，做时序图的时候可以用这个 mermaid-js - 方便集成在网页中，也可以导出成图片 kroki - 上面没提到的图类型的生成？看看这个 IaC pulumi - Terraform业界比较常用，不过要学习HCL比较蛋疼，我个人比较喜欢pulumi，可以选择自己的习惯的语言，tf-cdk目前还比较初级。</description></item><item><title>Go 1.17 泛型尝鲜</title><link>https://www.4async.com/2021/08/golang-117-generics/</link><pubDate>Tue, 17 Aug 2021 17:48:00 +0000</pubDate><guid>https://www.4async.com/2021/08/golang-117-generics/</guid><description>&lt;img src="https://www.4async.com/2021/08/golang-117-generics/go.png" alt="Featured image of post Go 1.17 泛型尝鲜" />今天，Go的1.17版本终于正式发布，除了带来各种优化和新功能外，1.17正式在程序中提供了尝鲜的泛型支持，这一功能也是为1.18版本泛型正式实装做铺垫。意味着在6个月后，我们就可以正式使用泛型开发了。那在Go 1.18正式实装之前，我们在1.17版本中先尝鲜一下泛型的支持吧。
泛型有什么作用？ 在使用Go没有泛型之前我们怎么实现针对多类型的逻辑实现的呢？有很多方法，比如说使用interface{}作为变量类型参数，在内部通过类型判断进入对应的处理逻辑；将类型转化为特定表现的鸭子类型，通过接口定义的方法实现逻辑整合；还有人专门编写了Go的函数代码生成工具，通过批量生成不同类型的相同实现函数代替手工实现等等。这些方法多多少少存在一些问题：使用了interface{}作为参数意味着放弃了编译时检查，作为强类型语言的一个优势就被抹掉了。同样，无论使用代码生成还是手工书写，一旦出现问题，意味着这些方法都需要重复生成或者进行批量修改，工作量反而变得更多了。
在Go中引入泛型会给程序开发带来很多好处：通过泛型，可以针对多种类型编写一次代码，大大节省了编码时间。你可以充分应用编译器的编译检查，保证程序变量类型的可靠性。借助泛型，你可以减少代码的重复度，也不会出现一处出现问题需要修改多处地方的尴尬问题。这也让很多测试工作变得更简单，借助类型安全，你甚至可以少考虑很多的边缘情况。
Go语言官方有详细的泛型提案文档可以在这里和这里查看详情。
如何使用泛型 前面理论我们仅仅只做介绍，这次尝鲜还是以实践为主。让我们先从一个小例子开始。
从简单的例子开始 让我们先从一个最简单的例子开始：
package main import ( &amp;#34;fmt&amp;#34; ) type Addable interface { type int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, uintptr, float32, float64, complex64, complex128, string } func add[T Addable](a, b T) T { return a + b } func main() { fmt.Println(add(1,2)) fmt.Println(add(&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;)) } 这个函数可以实现任何需要使用+符号进行运算的类型，我们通过定义Addable类型，枚举了所有可能可以使用add方法的所有的类型。比如我们在main函数中就使用了int和string两种不同类型。
但是如果这时我们使用简单的go run命令运行，会发现提示语法错误：
$ go version go version go1.17 darwin/arm64 $ go run ~/main.</description></item><item><title>Go Web应用中常见的反模式</title><link>https://www.4async.com/2021/08/common-anti-patterns-in-go-web-applications/</link><pubDate>Fri, 13 Aug 2021 14:09:00 +0000</pubDate><guid>https://www.4async.com/2021/08/common-anti-patterns-in-go-web-applications/</guid><description>&lt;img src="https://www.4async.com/2020/02/2020-02-16-moving-towards-domain-driven-design-in-go/cover_huea63e6370dcf0c375755d886a5d0b9c6_97708_1600x0_resize_q75_box.jpg" alt="Featured image of post Go Web应用中常见的反模式" />作者：Miłosz Smółka 译者：Kevin 原文地址：https://threedots.tech/post/common-anti-patterns-in-go-web-applications/
在我职业生涯的某个阶段，我对我所构建的软件不再感到兴奋。
我最喜欢的工作内容是底层的细节和复杂的算法。在转到面向用户的应用开发之后，这些内容基本消失了。编程似乎是利用现有的库和工具把数据从一处移至另一处。到目前为止，我所学到的关于软件的知识不再那么有用了。
让我们面对现实吧：大多数Web应用无法解决棘手的技术挑战。他们需要做到的是正确的对产品进行建模，并且比竞争对手更快的改进产品。
这起初看起来似乎是那么的无聊，但是你很快会意识到实现这个目标比听起来要难。这是一项完全不同的挑战。即使它们技术上实现并没有那么复杂，但时解决它们会对产品产生巨大影响并且让人获得满足。
Web应用面临的最大挑战不是变成了一个无法维护的屎山，而是会减慢你的速度，让你的业务最终失败。
这是他们如何在Go中发生和我是如何避免他们的。
松耦合是关键 应用难以维护的一个重要原因是强耦合。
在强耦合应用中，任何你尝试触动的东西都有可能产生意想不到的副作用。每次重构的尝试都会发现新的问题。最终，你决定字号从头重写整个项目。在一个快速增长的产品中，你是不可能冻结所有的开发任务去完成重写已经构建的应用的。而且你不能保证这次你把所有事都完成好。
相比之下，松耦合应用保持了清晰的边界。他们允许更换一些损坏的部分不影响项目的其他部分。它们更容易构建和维护。但是，为什么他们如此罕见呢？
微服务许诺了松耦合时实践，但是我们现在已经过了他们的炒作年代，而难以维护的应用仍旧存在。有些时候这反而变得更糟糕了：我们落入了分布式单体的陷阱，处理和之前相同的问题，而且还增加了网络开销。
❌ 反模式：分布式单体 在你了解边界之前，不要将你的应用切分成为微服务。
微服务并不会降低耦合，因为拆分服务的次数并不重要。重要的是如何连接各个服务。
✅ 策略：松耦合 以实现松耦合的模块为目标。如何部署它们（作为模块化单体应用或微服务）是一个实现细节。
DRY引入了耦合 强耦合十分常见，因为我们很早就学到了不要重复自己(Don&amp;rsquo;t Repeat Yourself, DRY)原则。
简短的规则很容易被大家记住，但是简短的三个单词很难概括所有的细节。《程序员修炼之道: 从小工到专家》这本书提供了一个更长的版本：
每条知识在系统中都必须有一个单一的、明确的、权威的表述。
&amp;ldquo;每一条知识&amp;quot;这个说法相当极端。大多数编程困境的答案是看情况而定，DRY也不例外。
当你让两个事物使用相同抽象的时候，你就引入了耦合。如果你严格遵循DRY原则，你就需要在这个抽象之前增加抽象。
在Go中保持DRY 相比于其他现代语言，Go是清晰的，缺少很多特性，没有太多的语法糖来隐藏复杂性。
我们习惯了捷径，所以一开始很难接受Go的冗长。就像我们已经开发出一种去寻找一种更加聪明的编写代码的方式的本能。
最典型的例子就是错误处理。如果你有编写Go的经验，你会觉得下面的代码片段很自然
if err != nil { return err } 但是对新手而言，一遍又一遍的重复这三行就是似乎在破坏DRY原则。他们经常想办法来规避这种样板方法，但是却没有什么好的结果。
最终，大家都接受了Go的工作方式。它让你重复你自己，不过这并不是DRY告诉你的你要避免重复。
单一数据模型带来的应用耦合 Go中有一个特性引入了强耦合，但会让你认为你自己在遵循DRY原则。这就是在一个结构体中使用多个标签。 这似乎是一个好主意，因为我们经常对不同的事物使用相似的模型。
这里有一个流行的方式保存单个User模型的方法：
type User struct { ID int `json:&amp;#34;id&amp;#34; gorm:&amp;#34;autoIncrement primaryKey&amp;#34;` FirstName string `json:&amp;#34;first_name&amp;#34; validate:&amp;#34;required_without=LastName&amp;#34;` LastName string `json:&amp;#34;last_name&amp;#34; validate:&amp;#34;required_without=FirstName&amp;#34;` DisplayName string `json:&amp;#34;display_name&amp;#34;` Email string `json:&amp;#34;email,omitempty&amp;#34; gorm:&amp;#34;-&amp;#34;` Emails []Email `json:&amp;#34;emails&amp;#34; validate:&amp;#34;required,dive&amp;#34; gorm:&amp;#34;constraint:OnDelete:CASCADE&amp;#34;` PasswordHash string `json:&amp;#34;-&amp;#34;` LastIP string `json:&amp;#34;-&amp;#34;` CreatedAt *time.</description></item><item><title>什么是事件建模Event Modeling?</title><link>https://www.4async.com/2021/07/introducing-event-modeling/</link><pubDate>Tue, 06 Jul 2021 11:41:00 +0000</pubDate><guid>https://www.4async.com/2021/07/introducing-event-modeling/</guid><description>&lt;img src="https://www.4async.com/2021/07/introducing-event-modeling/event-modeling-tutorial.jpg" alt="Featured image of post 什么是事件建模Event Modeling?" />基本概念 事件建模（Event Modeling）是一种描述系统的方法，展示信息如何随时间变化的例子。具体来说，这种方式省略了瞬息万变的细节，而着眼于在任何特定的时间点上的持久化存储和用户所见数据的变化。这些时间轴上的事件，构成了对系统的描述。
近年来，很多系统使用事件通过事件存储数据库或者使用特定方式使用常规数据库构建了状态和信息传播的模块。然而，大多数方法仍然依赖于通过SQL数据库、文档数据库或者其他技术实现严格意义上的当前时间点信息的视图。
对很多系统而言，特别是对于非小型系统而言，随着系统复杂性的增加，变更成本将会随着时间的推移难度指数级上升。与现有的设计和建模方式对比，事件建模可以在短时间内创建一个基础蓝图，将返工工作量降到最低。
从过去谈起 讲故事自古以来就是人类能够将知识传递给后代的方法，它在很大程度上依赖于我们如何存储记忆-无论是逻辑的、视觉的、听觉的还是其他的。这一点很重要，因为这与信息系统的构建方式有相似之处。 用具体的例子说明某物应该如何工作是一种常见的方式。这种方式可以在软件开发的成功实践中看到，如行为驱动开发。这种方式很有效，因为我们通过故事来沟通更有效。将它和讲故事联系在一起，是一种保持社会信息的方式。我们的大脑是为它而建的，而不是为流程图和其他格式而建的。 而事件建模模型就是遵循这种讲故事模式而建立的产品建模方式。
事件建模模式 时间线是最好描述故事主线的方式，对我们的系统而言，时间线也是描述我们系统核心部分概念的重要组成部分。我们可以通过在一条时间线上，系统从开始到结束，在没有分支情况下应该做什么方式展示我们系统的一部分功能。这就是一个典型的事件模型的组成。我们可以用这种方式跟踪所有UI界面中字段值如何存储和如何展示的。比如在上面的示例图中，我们使用了3种不同模块的内容和传统的线框模型就展示了整个系统的模型。但是简单性是我们重要的一个目标，因此我们只依赖于4种模式构建这种模型图。
保持简单性 当我们想采用某些做法或流程来帮助彼此理解和沟通时，它与个人为熟练掌握这些方法而进行的学习量成反比。换句话说，如果我们可以更快的掌握一个名叫X的方法时，我们就可以更好的通过这种方式进行知识分享和互动；反之，无论这种方法多么好，昂贵的学习成本总会搞砸一切。
当一本书是团队中的必读书目时，每个人都会说他们读过；但事实上只有一半的人会真正读过；这些真正读过的人中一半的人会声称他们理解了这本书；而这些声称理解的人中只有一半的人真正的理解了这本书；而这些真正理解了这本书的人只有一半的人能够使用它。
这就是为什么使用3个模块和基于2个想法的4种模式进行事件建模。因为这只需要几分钟就可以将所有的东西向所有人解释清楚。其他的学习则可以在实践中进行。即便理解出现了不足和错误，也可以很快在实践中得到纠正。
事件 假设我们想为连锁酒店设计一个酒店网站，让我们的客户可以在线预订房间，并让我们安排清洁和任何其他酒店问题。 我们可以显示在该业务的年度时间线上存储了哪些事件。 我们可以假装我们已经有了这个系统，然后问自己随着时间的推移存储了哪些事件。
线框图 让我们看一下在图片的最上面的部分的第一个模块。为了让讲故事这个事情更加可视化，我们可以在顶部显示功能的线框图或者网页模拟图。这也可以被具象化为具体的泳道图，以方便不同的人（也可以是系统）与我们的系统进行互动。这里一些自动化的内容可以用齿轮表示，同时说明系统正在做什么。通过这种方式，我们可以非常容易的展示出系统需要实现的功能列表，执行流程和项目完成标记。这里的图是示例了一个酒店的预订、支付和通知系统的过程，我们可以重点关注一下所有相关高亮显示的内容。
借助这个模块，我们可以很方便的和设计师一起沟通设计系统，当然，这里需要注意在设计中，两个重要的内容需要添加到整个设计中：用户所拥有的权限和用户可以获取的信息。
命令 大多数信息系统必须给用户一种影响系统的状态的能力，而这种能力就是命令。在我们的例子中，我们必须允许房间预订改变系统状态，这样我们就不会发生超额预订情况。当那个人在未来的预订日期到达时，他们就有一个为他们准备的房间。
改变系统状态的意图会被封装在一个命令中。相对于简单地将表单数据保存到数据库中的一个表中，这可以让我们以非技术性的方式来显示意图，同时允许任何实现 - 尽管我们可以看到某些方法更具优势。
从UI和UX的角度来看，这就是一个&amp;quot;命令响应式用户界面&amp;quot;，对帮助制作可组合的UI大有帮助。使用这种模式，从技术和商业的角度来看，交易的界限就更清楚了。以酒店入住为例，酒店的客人要么登记成功，要么没有。
当命令成功的前提条件有细微的差别时，它们会在&amp;quot;Given-When-Then&amp;quot;风格的描述方式中进行阐述。这种方式也是行为测试模式惯用的描述方式，也是一种成功的讲述故事的方式。实际执行过程中，可能会有几个这样的故事来说明一个命令如何能成功执行和不能成功执行。
这里我们可以用一个例子来描述一下：
Given：我们已经注册并添加了一个支付方式
When：我们试图预订一个房间
Then：一个房间被预订了
这种描述方式也通常被叫做“安排、行动、断言”，在UI/UX的世界中，也被称为“情景、统计、价值”。 在图中我们也可以发现，所有的命令都是用蓝色进行标记的。
视图（或者叫读模型） 任何信息系统的一个重要能力是将系统中保存的状态告知用户。我们的酒店客人需要知道他们感兴趣的某些类型的房间在哪一天可以入住。这通常有很多种情况，需要支持信息系统的多个模型。
随着这些新事件的存储，系统中的视图也会一直变化。在我们的酒店系统中，这个日历视图随着影响库存的新事件的发生而被更新。其他视图中清洁团队可以在客户离店事件存储后在其他视图中看到房间已经可以被清理了。
指定视图的行为方式与我们指定接受命令的方式非常相似，但有一处不同。视图是被动的，并且不能在事件被存储到系统中之后撤销事件。
举个例子：
Given：酒店设置了12间海景房，海景房从4月4日到12日被预订
Then：日历上应该显示除4月4日到12日以外的所有海景房的日期
从上面图中我们也可以注意到，所有的读都是用绿色进行标记的。
集成 我们刚刚介绍了描述大多数系统所需的 4 种模式中的前 2 种模式。 系统可以从其他系统获取信息并且将信息发送到其他系统。 强迫这 2 个模式成为前 2 个模式的扩展并共享相同的空间是很诱人的选择。 然而这会让交流变得更加困难，因为它们没有人类可见的方面，并且需要一些更高级别的模式。
翻译 当我们有一个为我们提供信息的外部系统时，将这些信息转换成我们自己系统中的更熟悉的形式会很有帮助。 在我们的酒店系统中，如果选择让我们的清洁人员反应更加灵敏，我们可以从客人的 GPS 坐标中获取事件。 我们不想使用经度和纬度对作为事件来指定我们系统中的先决条件。 我们宁愿选择对我们有意义的活动，例如“客人离开酒店”、“客人回到酒店房间”。
通常，翻译很简单，可以表示为从外部事件中获取信息的视图。如果我们不将它们用作测试的任何“Given”部分，则它们存储在该视图模型中的值仅在我们的状态更改测试中的命令参数中表示。
自动化 我们的系统一般都需要与外部服务进行通信。当我们酒店的客人在退房时支付住宿费用时，我们的系统会调用付款处理程序。我们可以通过系统中某个处理程序的“待办事项列表”的概念来了解这是如何发生的。这个待办事项列表显示了我们需要完成的任务。例如，我们的处理程序会不时查看该列表（可能是几毫秒或几天）并向外部系统发送命令以处理付款。然后将来自外部系统的回复转换为我们存储回系统中的事件。通过这种方式，我们将系统中使用的构建块保留为对我们有意义的东西。
我们通过在具有线框的蓝图顶部放置一个处理程序来展示这一点。这表明这些东西在屏幕上无法看到但在后台发生。由于需要完成后台任务，用户可能期望旋转图标提示延迟。此规范的形式为“Given：要执行的任务的视图，When：每个项目启动此命令时，Then：这些事件会返回。”
实际上，这些可以通过许多不同的方式实现，例如队列、响应式或实时构造。它们甚至可能是我们使用的待办事项列表。这里的目标是传达我们的系统在需要影响外部时是如何与之沟通的。
落地实现 事件建模分7个步骤进行。我们已经解释了最终的目标。因此，让我们倒退到开头，展示如何建立起蓝图。</description></item><item><title>构建属于你自己的dapr绑定组件</title><link>https://www.4async.com/2021/05/building-your-own-dapr-binding/</link><pubDate>Sat, 15 May 2021 18:38:00 +0000</pubDate><guid>https://www.4async.com/2021/05/building-your-own-dapr-binding/</guid><description>&lt;img src="https://vip1.loli.io/2022/03/26/uJdVWNeXC6Z3Hq8.png" alt="Featured image of post 构建属于你自己的dapr绑定组件" />在上一篇文章中，吐槽了拖延症的危害，因此这次我来分享一下我最新推送到dapr的最新的一个新的绑定组件，通过这个来看一下如何实现自己的绑定组件。
文中提到的PR可以在 dapr/components-contrib#872 查看对应的具体代码。
什么是 dapr 的绑定组件？ 在dapr中，绑定是用于使用外部系统功能（比如事件或者接口）的扩展组件。它的优势在于：
免除连接到消息传递系统(如队列和消息总线)并进行轮询的复杂性； 聚焦于业务逻辑，而不是如何与系统交互的实现细节； 使代码不受 SDK 或库的跟踪； 处理重试和故障恢复； 在运行时在绑定之间切换； 构建具有特定于环境的绑定的可移植应用程序，不需要进行代码更改； 在官方文档中，也提到了一个具体的例子：以twilio发送短信为例，一般开发过程中应用程序需要依赖Twilio SDK才可以实现功能，但是借助绑定组件，你可以将SDK的绑定转移至dapr程序领域内，在本身应用程序中不再绑定对应的SDK，不用担心未来SDK过期或者变更带来的重复工作（仅需要更新dapr即可）。
根据订阅的进出方向，绑定组件也分为输入绑定和输出绑定。这些绑定均是通过yaml文件描述类型和元数据，通过HTTP/gRPC进行调用。
如何实现自己的绑定组件？ 官方例子中提供了一个基础的介绍，上一节中我们也提到了在程序中，根据进出方向可以把绑定组件分为输出绑定和输入绑定。你可以通过官方教程中的例子提供查看：
在这个例子用，你可以看到，根据方向吧dapr发布消息到Kafka作为输出组件，把Kafka读取消息到dapr作为输入组件。
绑定的声明yaml文件的规范则如下：
apiVersion: dapr.io/v1alpha1 kind: Component metadata: name: &amp;lt;NAME&amp;gt; namespace: &amp;lt;NAMESPACE&amp;gt; spec: type: bindings.&amp;lt;TYPE&amp;gt; version: v1 metadata: - name: &amp;lt;NAME&amp;gt; value: &amp;lt;VALUE&amp;gt; 其中metadata.name则是绑定置名称，spec.metadata.name和spec.metadata.value则是配置的属性和对应值。这个值我们可以通过实现接口InputBinding或者OutputBinding实现输入绑定和输出绑定.
type InputBinding interface { Init(metadata Metadata) error Read(handler func(*ReadResponse) ([]byte, error)) error } type OutputBinding interface { Init(metadata Metadata) error Invoke(req *InvokeRequest) (*InvokeResponse, error) Operations() []OperationKind } 接下来需要实现一个生成对象的方法，比如说我们需要实现一个飞书推送Webhook的绑定组件，则可以：</description></item><item><title>构建属于你自己的dapr服务发现</title><link>https://www.4async.com/2021/05/building-your-own-dapr-service-discovery/</link><pubDate>Sat, 08 May 2021 18:38:00 +0000</pubDate><guid>https://www.4async.com/2021/05/building-your-own-dapr-service-discovery/</guid><description>&lt;img src="https://vip1.loli.io/2022/03/26/uJdVWNeXC6Z3Hq8.png" alt="Featured image of post 构建属于你自己的dapr服务发现" />写在最前: 这篇文章其实算是马后炮了，因为一直拖延症的问题，顺带过了一个五一假期，结果发现已经有社区贡献者提供了Consul的服务发现实现，于是本来写了一半的文章只能进行调整了。拖延症害人啊！几个草稿的文章看来要尽快赶出来了🤦‍♂️
在上一篇文章中，我其实遗留了一个问题：如何定义dapr的服务发现呢？其实在后面阅读dapr的源码之后也前一篇文章的评论中提到了答案：目前dapr提供了内置两种服务发现模式：K8s模式和用于独立部署的mDNS模式。mDNS模式在某些网络环境下可能存在问题（比如跨机房），不过没有关系，dapr同时提供了可扩展能力，可以通过定义自主的服务发现能力扩展dapr的边界。
从 NameResolution 到 Resolver 接口 在 pkg/components/nameresolution/registry.go 文件中，dapr定义了一个 NameResolution 结构体用于服务注册和发现：
type ( // NameResolution is a name resolution component definition. NameResolution struct { Name string FactoryMethod func() nr.Resolver } // Registry handles registering and creating name resolution components. Registry interface { Register(components ...NameResolution) Create(name, version string) (nr.Resolver, error) } nameResolutionRegistry struct { resolvers map[string]func() nr.Resolver } ) 其中真正的服务解析则是依靠 components-contrib 中实现了 Resolver 接口的具体实现执行。
// Resolver is the interface of name resolver.</description></item><item><title>在非容器(集群)环境下运行dapr</title><link>https://www.4async.com/2021/03/2021-03-11-running-dapr-without-container/</link><pubDate>Thu, 11 Mar 2021 18:38:00 +0000</pubDate><guid>https://www.4async.com/2021/03/2021-03-11-running-dapr-without-container/</guid><description>&lt;img src="https://vip1.loli.io/2022/03/26/uJdVWNeXC6Z3Hq8.png" alt="Featured image of post 在非容器(集群)环境下运行dapr" />前一段时间一直关注的dapr正式发布了v1.0版本(实际上本文发布时还更新了v1.0.1)，代表dapr在某些程度上进入稳定状态，可以尝试在实际中进行运用。作为我一直关注的项目，在第一时间中进行了尝试，并试图引入实际项目中，本文则是针对这些的一些先期测试内容.
什么是dapr？ dapr最早是由微软开源的(不愧是你)，一个可移植的、事件驱动的程序运行时，它使任何开发者都能轻松地构建运行在云和边缘的弹性、无状态/有状态的应用程序，并且可以灵活支持多种开发语言。换而言之，在我看来，dapr可以作为一个serverless落地方案看待和处理，对程序而言，只关注提供的store和消息队列接口，无需关心架构层面更多内容。
不过在官方的示例教程中，使用的环境为容器环境部署和管理dapr。实际上，除了在容器环境或者容器集群环境下，dapr可以配置为在本地机器上以自托管模式运行。
本地安装 dapr安装可以通过官方的dapr-cli实现，dapr-cli可以通过一键安装命令快速安装：
# wget -q https://raw.githubusercontent.com/dapr/cli/master/install/install.sh -O - | /bin/bash Your system is linux_amd64 Dapr CLI is detected: main: line 86: 43656 Segmentation fault $DAPR_CLI_FILE --version Reinstalling Dapr CLI - /usr/local/bin/dapr... Getting the latest Dapr CLI... Installing v1.0.0 Dapr CLI... Downloading https://github.com/dapr/cli/releases/download/v1.0.0/dapr_linux_amd64.tar.gz ... dapr installed into /usr/local/bin successfully. CLI version: 1.0.0 Runtime version: n/a To get started with Dapr, please visit https://docs.dapr.io/getting-started/ 可以通过输入dapr命令确认dapr-cli程序是否被正常安装成功。
接下来使用dapr-cli安装所有的runtime等应用。
# dapr init --slim ⌛ Making the jump to hyperspace.</description></item><item><title>NATS-Server(JetStream)和NATS Streaming Server对比</title><link>https://www.4async.com/2021/03/2021-03-02-nats-server-usage/</link><pubDate>Tue, 02 Mar 2021 18:38:00 +0000</pubDate><guid>https://www.4async.com/2021/03/2021-03-02-nats-server-usage/</guid><description>&lt;img src="https://vip1.loli.io/2022/03/26/Cv92HUNpYyjDTVK.png" alt="Featured image of post NATS-Server(JetStream)和NATS Streaming Server对比" />在我吐槽了无数次之后，NATS JetStream终于结束了beta阶段正式进入RC阶段。终于官方也在最近刚刚正式回复了我正式版本在处理几个问题之后就会正式发布。那么在这个比较重要的NATS-Server特性发布之际聊一下NATS产品本身区别和新特性的使用，还有更多的潜在的区别。
概念区分：NATS-Server / NATS Streaming Server / NATS JetStream NATS-Server NATS-Server（或者叫nats）是一个开源的、云原生的、高性能的消息传递系统，是NATS的最基础的产品。它的核心是一个发布/订阅（Pub/Sub）系统，客户端可以在不同集群中的服务间nats进行通讯，而不需要关注具体的消息在哪个服务上。换而言之，客户端可以在任意一个集群的服务端上发布消息，同时在任意集群客户端上尝试读取消息。在官方与其他同类消息队列产品功能对比中，我们也可以管窥一下产品的功能列表。nats支持多流多服务进行pub/sub，负载均衡，保障消息最多/最少一次送达，多租户和用户认证等功能。虽然看上去优点很多，但是nats不是一个应用很广的消息队列的重要原因是，它缺少了一些对消息队列而言很最重要的产品特性，比如持久化支持，比如消息确保一次送达。这意味着当你的消息发送出去之后，你的消息是在处理过程中可能丢失的，甚至是可能送达不到的。
NATS Streaming Server NATS Streaming Server（或者叫stan）是用于尝试解决上面提到的nats的已存在问题的。stan添加了持久化功能和消息送达策略支持。stan中自带了nats服务端，但是在使用过程中，nats和stan不能进行混用。在官方文档中，是这么描述stan和nats之间的关系的：
NATS客户端和NATS Streaming Server客户端之间不能相互交换数据。也就是说，如果一个NATS Streaming Server客户端在foo上发布消息，在同一主题上订阅的NATS客户端将不会收到消息。NATS Streaming Server消息是由protobuf组成的NATS消息。NATS Streaming Server要向生产者发送ACK，并接收消费者的ACK。如果与NATS客户端自由交换消息，就会引起问题。
stan的具体架构如下图：
但是stan虽然提供了持久化和消息传递策略支持，但是在架构设计上却出现了问题，导致在最开始设计时遗留了很多问题，比如当你确定stan集群是固定的不能无限制水平扩容(#999)，比如不支持多租户功能(#1122)，比如客户端无法主动拉取消息只能被推送等等
NATS JetStream NATS JetStream（或者叫JetStream）是NATS基于Raft算法实现的最新的架构设计尝试解决上述问题的新方案。在区别于原有的stan功能上，提供了新的持久化功能和消息送达策略，同时支持水平扩容。同时，新的JetStream也为大消息做了一些优化，不再将这特性功能作为nats的客户端存在而是嵌入NATS Server中作为其中的一个功能存在。也就是说，如果在对这几项技术进行选择时，JetStream应该是最应该被选择的方案。更多详细情况具体可以查看官方的指导文档。
NATS JetStream使用 理论介绍过了，接下来说说实际使用的事情。现在JetStream还是RC阶段，
编译和启动客户端 下载nats-server源码，解压之后执行：
cd nats-server-master go build -o nats-server -ldflags=&amp;#34;-s -w -buildid=&amp;#34; . ./nats-server -js 这样就可以启动一个支持JetStream功能的服务端了。
[54738] 2021/03/02 18:27:02.605197 [INF] Starting nats-server [54738] 2021/03/02 18:27:02.605236 [INF] Version: 2.2.0-RC.2 [54738] 2021/03/02 18:27:02.605238 [INF] Git: [not set] [54738] 2021/03/02 18:27:02.</description></item><item><title>上下文Context与结构体Struct</title><link>https://www.4async.com/2021/02/2021-02-25-context-and-structs/</link><pubDate>Thu, 25 Feb 2021 10:30:00 +0000</pubDate><guid>https://www.4async.com/2021/02/2021-02-25-context-and-structs/</guid><description>&lt;img src="https://www.4async.com/2021/02/2021-02-25-context-and-structs/cover.png" alt="Featured image of post 上下文Context与结构体Struct" />原文地址：https://blog.golang.org/context-and-structs 原文作者：Jean de Klerk, Matt T. Proud 译者：Kevin 介紹 在许多Go API中，尤其是现代的API中，函数和方法的第一个参数通常是context.Context。上下文（Context）提供了一种方法，用于跨API边界和进程之间传输截止时间、调用者取消和其他请求范围的值。当一个库与远程服务器（如数据库、API等）直接或间接交互时，经常会用到它。
在context的文档中写道。
上下文不应该存储在结构类型里面，而是传递给每个需要它的函数。 本文对这一建议进行了扩展，用具体例子解析为什么传递上下文而不是将其存储在其他类型中很重要。它还强调了一种罕见的情况，即在结构类型中存储上下文可能是有意义的，以及如何安全地这样做。
倾向于将上下文作为参数传递 为了深入理解不在结构中存储上下文的建议，我们来考虑一下首选的上下文作为参数的方法。
type Worker struct { /* … */ } type Work struct { /* … */ } func New() *Worker { return &amp;amp;Worker{} } func (w *Worker) Fetch(ctx context.Context) (*Work, error) { _ = ctx // 每次调用中ctx用于取消操作，截止时间和元数据。 } func (w *Worker) Process(ctx context.Context, w *Work) error { _ = ctx // A每次调用中ctx用于取消操作，截止时间和元数据。 } 在这个例子中，(*Worker).Fetch和(*Worker).Process方法都直接接受上下文。通过这种通过参数传递的设计，用户可以设置每次调用的截止时间、取消和元数据。而且，很清楚传递给每个方法的context.Context将如何被使用：没有期望传递给一个方法的context.Context将被任何其他方法使用。这是因为上下文的范围被限定在了小范围的必须操作内，这大大增加了这个包中上下文的实用性和清晰度。
将上下文存储在结构中会导致混乱 让我们再次使用上下文存储在结构体中这种方式审视一下上面的Worker例子。它的问题是，当你把上下文存储在一个结构中时，你会向调用者隐藏它的生命周期，甚至可能的是把两个不同的作用域以不可预料的方式互相干扰：</description></item><item><title>切换至Hugo引擎驱动</title><link>https://www.4async.com/2021/02/2021-02-19-move-to-hugo/</link><pubDate>Fri, 19 Feb 2021 16:27:00 +0000</pubDate><guid>https://www.4async.com/2021/02/2021-02-19-move-to-hugo/</guid><description>&lt;img src="https://www.4async.com/2021/02/2021-02-19-move-to-hugo/cover.png" alt="Featured image of post 切换至Hugo引擎驱动" />其实很早之前就希望切换至Hugo引擎驱动博客了，但是体验下来一圈，最大的感觉是Hugo的主题都很一言难尽&amp;hellip;所以拖着一直没有切换。结果今天想发布新文章时突然发现我无法正常编译Hexo的项目了，于是干脆趁此良机切换至Hugo引擎了。
本站目前使用的主题是stack主题，相当简洁，推荐想切换至Hugo的小伙伴了解一下。
另外提供一下快速进行Github Action部署的方案（私有化仓库代码/公有化仓库网站展示），PERSONAL_TOKEN是个人token，需要从个人设置页面里获取填写至仓库Secrets中：
name: github pages on: push: branches: - master jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: &amp;#39;latest&amp;#39; - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} external_repository: 你的用户名/你的仓库 publish_dir: ./public cname: 你的域名</description></item><item><title>Go 1.16 中Module功能新变化</title><link>https://www.4async.com/2021/02/2021-02-19-go116-module-changes/</link><pubDate>Fri, 19 Feb 2021 10:16:00 +0000</pubDate><guid>https://www.4async.com/2021/02/2021-02-19-go116-module-changes/</guid><description>&lt;img src="https://www.4async.com/2021/02/2021-02-19-go116-module-changes/cover.jpg" alt="Featured image of post Go 1.16 中Module功能新变化" />原文地址：https://blog.golang.org/go116-module-changes 原文作者：Jay Conrod 译者：Kevin 希望您喜欢Go 1.16! 这个版本有很多新功能，特别是对Module而言。发行说明中简要介绍了这些变化，但让我们深入发掘一下其中的一些变化。
Module功能默认开启 go命令现在默认以module-aware模式构建包，即使没有go.mod文件存在。这是向在所有项目中使用Module功能迈出的一大步。
通过设置GO111MODULE环境变量为off，仍然可以在GOPATH模式下构建包。你也可以将GO111MODULE设置为auto，只有当当前目录或任何父目录中存在go.mod文件时才启用module-aware模式。这在以前是默认的。请注意，您可以使用go env -w来永久地设置GO111MODULE和其他变量。
go env -w GO111MODULE=auto 我们计划在 Go 1.17 中放弃对GOPATH模式的支持。换句话说，Go 1.17将忽略GO111MODULE。如果您的项目没有以module-aware模式构建，现在是时候迁移了。如果有问题妨碍您迁移，请考虑提交问题或体验报告。
不会自动更改 go.mod 和 go.sum 在之前的版本中，当go命令发现go.mod或go.sum有问题时，比如缺少require指令或缺少sum，它会尝试自动修复问题。我们收到了很多反馈，认为这种行为是出乎大家意料的，尤其是对于像go list这样通常不会产生副作用的命令。自动修复并不总是可取的：如果一个导入的包没有被任何需要的Module提供，go命令会添加一个新的依赖关系，可能会触发普通依赖关系的升级。即使是拼写错误的导入路径也会导致（失败的）网络查找。
在 Go 1.16 中，module-aware命令在发现go.mod或go.sum中的问题后会报告一个错误，而不是尝试自动修复问题。在大多数情况下，错误信息建议使用命令来修复问题。
$ go build example.go:3:8: no required module provides package golang.org/x/net/html; to add it: go get golang.org/x/net/html $ go get golang.org/x/net/html $ go build 和之前一样，如果存在vendor目录，go命令可能会使用该目录（详见Vendoring）。像go get和go mod tidy这样的命令仍然会修改go.mod和go.sum，因为它们的主要目的是管理依赖关系。
在特定版本上安装可执行文件 go install命令现在可以通过指定@version后缀来安装特定版本的可执行文件。
go install golang.org/x/tools/gopls@v0.6.5 当使用这种语法时，go install命令会从该Module的制定版本安装，而忽略当前目录和父目录中的任何 go.mod 文件。(如果没有@version后缀，go install会像往常一样继续运行，使用当前Module的go.mod中列出的版本要求和替换来构建程序。)
我们曾经推荐使用go get -u程序来安装可执行文件，但这种使用方式对go.</description></item><item><title>OpenTelemetry入门</title><link>https://www.4async.com/2020/03/2020-03-31-intro-opentelemetry/</link><pubDate>Tue, 31 Mar 2020 11:10:00 +0000</pubDate><guid>https://www.4async.com/2020/03/2020-03-31-intro-opentelemetry/</guid><description>&lt;img src="https://www.4async.com/2020/03/2020-03-31-intro-opentelemetry/cover.png" alt="Featured image of post OpenTelemetry入门" />&lt;p>今天早些时候，&lt;a class="link" href="https://opentelemetry.io/" target="_blank" rel="noopener"
>OpenTelemetry&lt;/a>正式&lt;a class="link" href="https://medium.com/opentelemetry/opentelemetry-is-officially-in-beta-352fa859db10" target="_blank" rel="noopener"
>进入Beta版本阶段&lt;/a>，这标志着OpenTelemetry的基本模型已经正式确定，可以开始将OpenTelemetry集成到应用程序和客户端库中，以捕获应用程序级指标和分布式跟踪。&lt;/p></description></item><item><title>译：在Go中转向领域驱动设计</title><link>https://www.4async.com/2020/02/2020-02-16-moving-towards-domain-driven-design-in-go/</link><pubDate>Sun, 16 Feb 2020 21:52:00 +0000</pubDate><guid>https://www.4async.com/2020/02/2020-02-16-moving-towards-domain-driven-design-in-go/</guid><description>&lt;img src="https://www.4async.com/2020/02/2020-02-16-moving-towards-domain-driven-design-in-go/cover.jpg" alt="Featured image of post 译：在Go中转向领域驱动设计" />&lt;p>原文：&lt;a class="link" href="https://www.calhoun.io/moving-towards-domain-driven-design-in-go/" target="_blank" rel="noopener"
>Moving Towards Domain Driven Design in Go&lt;/a>&lt;/p>
&lt;p>本文的目的是帮助演示当应用程序随着时间不断推移不断演化时，我们如何利用领域驱动设计帮我们解决可能遇到的问题。为了实现这个目标，我们会通过一个琐碎的项目研究项目是如何随着时间一步步演化的。这不是一个完整的项目，示例代码并不能够直接编译，甚至有些导入以来没有全部列出。这只是一个简单的示例，也就是说，如果出现什么问题，你可以随时与我联系，我们将对问题进行调整或者你的问题及时解答（如果可以的话）。&lt;/p></description></item><item><title>从 Go 语言的依赖库讲起（2）监控、分布式追踪和日志</title><link>https://www.4async.com/2020/02/2020-02-05-golang-debug-instrumental/</link><pubDate>Wed, 05 Feb 2020 18:30:00 +0000</pubDate><guid>https://www.4async.com/2020/02/2020-02-05-golang-debug-instrumental/</guid><description>&lt;p>我们通常会遇到线上甚至测试中代码出现问题，这些问题可能来自于我们开发过程中的引入的BUG，有些来自于我们的功能未得到理想结果的，甚至有一些问题来自于运行环境的。很多事情可能未必能够足够可控，尤其是上线之后才发现出现了问题。除了我们&lt;a class="link" href="" >前面一篇文章&lt;/a>中介绍了一些测试相关的内容，虽然可以解决一部分问题，但是这些并不能完全杜绝所有问题在线上一定不会出现任何问题。因此我们需要建立对发布/预发环境一套相对完善的监控、诊断机制，保证我们可以尽快进行故障的分析和溯源。&lt;/p></description></item><item><title>从 Go 语言的依赖库讲起（1）Ginkgo、testify和GoMock</title><link>https://www.4async.com/2020/01/2020-01-10-golang-test-driven-toolkit/</link><pubDate>Fri, 10 Jan 2020 17:30:00 +0000</pubDate><guid>https://www.4async.com/2020/01/2020-01-10-golang-test-driven-toolkit/</guid><description>&lt;p>对开发而言，测试的重要性相信对每个开发者而言是老生常谈的事情。虽然我们很有可能在开发过程中由于各种原因会希望后续补全，然而事实上我更建议采用“Tests that fail then pass”原则去处理在实际开发过程中遇到的问题。&lt;/p>
&lt;p>在我们开发过程的初期阶段，开发质量的保持更多依赖开发人员自身素质保持。但是对一个团队而言，未必能够一直保持人员的高素质开发。在这个过程中，人员的变动，新老编码习惯的冲突，人员能力的残次不齐都有可能导致代码的腐化。在测试过程中，我们选择引入测试保障代码的质量&lt;/p>
&lt;p>Go本身提供了基础的测试功能，但是这个功能在实际使用过程中仍有使用起来功能较弱的问题。比如我们在使用过程中，需要使用额外的库让测试代码更佳高效。在实际实践过程中，我推荐使用&lt;code>Ginkgo&lt;/code>、&lt;code>testify&lt;/code>和&lt;code>GoMock&lt;/code>工具。&lt;/p></description></item><item><title>从Go语言的依赖库讲起（0）：让我们聊聊如何开发更方便维护的Go语言程序</title><link>https://www.4async.com/2019/11/2019-11-23-learning-go-from-3rd-library/</link><pubDate>Sat, 23 Nov 2019 22:43:00 +0000</pubDate><guid>https://www.4async.com/2019/11/2019-11-23-learning-go-from-3rd-library/</guid><description>缘起 今年是Go语言的10年生日，准确的说应该是Go开放于2009年，当时虽然公开了，但是其实真正的可用性并不是很好。甚至Windows的支持都没有。当时我的主要环境还是在Windows平台，因此没有太关注Go语言。在2012年Go语言正式发布1.0版本之后，我当时工作环境转移到了Linux/macOS/iOS相关的产品上，因此重新学习了一下Go语言。
后来在Go的1.3版本发布后，我在支付宝的内部系统中第一次上线了一个基于Go语言的边缘服务，也是第一次将Go语言应用到了实际的生产环境中。后来在云柚科技创业过程中，正式将Go语言作为我们物联网环境的第一优选语言（也基本上是唯一语言），大规模的批量部署Go语言项目和代码。
聊聊如何开发更方便维护的Go语言程序 对Go语言而言，开发似乎是简单的事情：Go本身的语法比较简单，关键词不多，可以快速上手。如果基本功能而言，能采用的花式解法不多，导致Go语言的上手比较简单，对我们创业期间的公司而言，享受到了很多这种方面带来的很多红利：我们工程师基本上都是其他语言/岗位转型过来的全(quan)栈(gan)工程师，他们也为我们业务的快速发展提供了原生的动力。
然而，当我们把时间稍微放长一点，我们会发现当时我们仍旧遗留下了很多历史性的技术债，这些内容包含了我们当时对于代码质量的妥协，由其他语言习惯带过来的洋玩意但有点水土不服，一些过度的设计，一些库选择上和我们后续的最佳实践相违背等等问题。
这里面，一些软性的东西其实我们可以通过一些非编码环节去解决：对开发过的代码要求提供单元测试和开发后的Code Review；在技术开发之前进行沟通，规避可能出现的过度设计问题等等。不过，我想了想，这些更多属于规范性的问题，各个公司自有自身的特色在，那么还有什么内容可以更适合初中级开发一块聊一聊的呢？
那么毫无疑问就是对依赖库的选择。这部分的内容直接与我们在开发过程中会采用的实际最佳实践相关，无论是多人合作项目，还是单枪匹马的开源项目开发，各种依赖库无法避免：它们可以帮我们有效提升开发效率，帮我们落地最佳实践，让我们更快的更高效的完成工作。因此，我打算从这个系列中，一方面去聊聊我们未来会介绍的依赖库的使用；另外一方面，也想通过这个系列，聊聊如何是使用依赖库的过程中，将各种最佳实践一一落地。我们可能会介绍为什么选择这个依赖库，这个依赖库会带给我们的实践会是怎么样的。
不过在这里仍旧提醒一句，这里提到的所有的功能和实践均为在实际项目中总结的内容，部分实践则可根据个人情况进行实际选择。所有的实践并非全部都是最优解，仍需根据实际项目情况进行对应的调整和抉择。
最后，希望你们能够喜欢这个系列。：）</description></item></channel></rss>