<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="原文地址: PEP-0492
   PEP 492     标题 协程与 async/await 语法   作者 Yury Selivanov &amp;lt;yury at magic.io&amp;gt;   翻译 ipfans &amp;lt;ipfanscn at gmail.com&amp;gt;   状态 最终稿   Python 版本 3.5   翻译最后更新 2015-11-03    目录
摘要 API 设计和实现的备注 基本原理和目标
语法规范
 新协程声明语法 types.coroutine() Await 表达式  新的操作符优先级列表 await 表达式示例   异步上下文管理与 async with  新语法 例子   异步迭代器与 async for  新语法 例子 1 例子 2 为什么使用 StopAsyncIteration   协程对象  与生成器的不同之处 协程对象方法   调试特性 新的标准库函数 新的抽象基类  专用术语表"><title>PEP 0492 Coroutines with async and await syntax 中文翻译</title><link rel=canonical href=https://www.4async.com/2015/10/2015-10-31-coroutines-with-async-and-await-syntax-chinese/><link rel=stylesheet href=../../../scss/style.min.css><meta property="og:title" content="PEP 0492 Coroutines with async and await syntax 中文翻译"><meta property="og:description" content="原文地址: PEP-0492
   PEP 492     标题 协程与 async/await 语法   作者 Yury Selivanov &amp;lt;yury at magic.io&amp;gt;   翻译 ipfans &amp;lt;ipfanscn at gmail.com&amp;gt;   状态 最终稿   Python 版本 3.5   翻译最后更新 2015-11-03    目录
摘要 API 设计和实现的备注 基本原理和目标
语法规范
 新协程声明语法 types.coroutine() Await 表达式  新的操作符优先级列表 await 表达式示例   异步上下文管理与 async with  新语法 例子   异步迭代器与 async for  新语法 例子 1 例子 2 为什么使用 StopAsyncIteration   协程对象  与生成器的不同之处 协程对象方法   调试特性 新的标准库函数 新的抽象基类  专用术语表"><meta property="og:url" content="https://www.4async.com/2015/10/2015-10-31-coroutines-with-async-and-await-syntax-chinese/"><meta property="og:site_name" content="ipfans's Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="Python"><meta property="article:tag" content="async"><meta property="article:tag" content="asyncio"><meta property="article:published_time" content="2015-10-31T12:48:15+00:00"><meta property="article:modified_time" content="2015-10-31T12:48:15+00:00"><meta property="og:image" content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460"><meta name=twitter:site content="janxin"><meta name=twitter:title content="PEP 0492 Coroutines with async and await syntax 中文翻译"><meta name=twitter:description content="原文地址: PEP-0492
   PEP 492     标题 协程与 async/await 语法   作者 Yury Selivanov &amp;lt;yury at magic.io&amp;gt;   翻译 ipfans &amp;lt;ipfanscn at gmail.com&amp;gt;   状态 最终稿   Python 版本 3.5   翻译最后更新 2015-11-03    目录
摘要 API 设计和实现的备注 基本原理和目标
语法规范
 新协程声明语法 types.coroutine() Await 表达式  新的操作符优先级列表 await 表达式示例   异步上下文管理与 async with  新语法 例子   异步迭代器与 async for  新语法 例子 1 例子 2 为什么使用 StopAsyncIteration   协程对象  与生成器的不同之处 协程对象方法   调试特性 新的标准库函数 新的抽象基类  专用术语表"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://avatars0.githubusercontent.com/u/363344?v=3&s=460"></head><body><script>(function(){const colorSchemeKey='StackColorScheme';if(!localStorage.getItem(colorSchemeKey)){localStorage.setItem(colorSchemeKey,"auto");}})();</script><script>(function(){const colorSchemeKey='StackColorScheme';const colorSchemeItem=localStorage.getItem(colorSchemeKey);const supportDarkMode=window.matchMedia('(prefers-color-scheme: dark)').matches===true;if(colorSchemeItem=='dark'||colorSchemeItem==='auto'&&supportDarkMode){document.body.dataset.scheme='dark';}else{document.body.dataset.scheme='light';}})();</script><div class="container main-container flex on-phone--column extended article-page with-toolbar"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><img src=../../../img/avatar_huae056372e08c63f80862e9295e80f934_12087_300x0_resize_q75_box.jpeg width=300 height=300 class=site-logo loading=lazy alt=Avatar></figure><h1 class=site-name><a href=https://www.4async.com>ipfans's Blog</a></h1><h2 class=site-description></h2></header><ol class=menu id=main-menu><li><a href=../../../><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=../../../about><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=../../../archives><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=../../../atom.xml><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg><span>Feed</span></a></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></ol></aside><main class="main full-width"><div id=article-toolbar><a href=https://www.4async.com class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><article class=main-article><header class=article-header><div class=article-details><h2 class=article-title><a href=../../../2015/10/2015-10-31-coroutines-with-async-and-await-syntax-chinese/>PEP 0492 Coroutines with async and await syntax 中文翻译</a></h2><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>Oct 31, 2015</time></footer></div></header><section class=article-content><p>原文地址: <a class=link href=https://www.python.org/dev/peps/pep-0492/ target=_blank rel=noopener>PEP-0492</a></p><table><thead><tr><th style=text-align:left>PEP</th><th style=text-align:left>492</th></tr></thead><tbody><tr><td style=text-align:left>标题</td><td style=text-align:left>协程与 async/await 语法</td></tr><tr><td style=text-align:left>作者</td><td style=text-align:left>Yury Selivanov <code>&lt;yury at magic.io></code></td></tr><tr><td style=text-align:left>翻译</td><td style=text-align:left>ipfans <code>&lt;ipfanscn at gmail.com></code></td></tr><tr><td style=text-align:left>状态</td><td style=text-align:left>最终稿</td></tr><tr><td style=text-align:left>Python 版本</td><td style=text-align:left>3.5</td></tr><tr><td style=text-align:left>翻译最后更新</td><td style=text-align:left>2015-11-03</td></tr></tbody></table><p>目录</p><p><a class=link href=#Abstract>摘要</a><br><a class=link href=#API-Design-and-Implementation-Note>API 设计和实现的备注</a><br><a class=link href=#Rationale-and-Goals>基本原理和目标</a><br><a class=link href=#Specification>语法规范</a></p><ul><li><a class=link href=#New-Coroutine-Declaration-Syntax>新协程声明语法</a></li><li><a class=link href=#Type-Coroutine>types.coroutine()</a></li><li><a class=link href=#Await-Expression>Await 表达式</a><ul><li><a class=link href=#Updated-operator-precedence-table>新的操作符优先级列表</a></li><li><a class=link href=#Examples-of-await-expressions>await 表达式示例</a></li></ul></li><li><a class=link href=#Asynchronous-Context-Managers>异步上下文管理与 <code>async with</code></a><ul><li><a class=link href=#Async-With-New-Syntax>新语法</a></li><li><a class=link href=#Async-With-Example>例子</a></li></ul></li><li><a class=link href=#Asynchronous-Iterators>异步迭代器与 <code>async for</code></a><ul><li><a class=link href=#Async-For-New-Syntax>新语法</a></li><li><a class=link href=#Async-For-Example-1>例子 1</a></li><li><a class=link href=#Async-For-Example-2>例子 2</a></li><li><a class=link href=#Why-StopAsyncIteration>为什么使用 <code>StopAsyncIteration</code></a></li></ul></li><li><a class=link href=#Coroutine-objects>协程对象</a><ul><li><a class=link href=#Differences-from-generators>与生成器的不同之处</a></li><li><a class=link href=#Coroutine-object-methods>协程对象方法</a></li></ul></li><li><a class=link href=#Debugging-Features>调试特性</a></li><li><a class=link href=#New-Standard-Library-Functions>新的标准库函数</a></li><li><a class=link href=#New-Abstract-Base-Classes>新的抽象基类</a></li></ul><p><a class=link href=#Glossary>专用术语表</a><br><a class=link href=#List-of-functions-and-methods>函数与方法列表</a><br><a class=link href=#Transition-Plan>移植计划</a></p><ul><li><a class=link href=#Backwards-Compatibility>向后兼容性</a><ul><li><a class=link href=#asyncio>asyncio</a></li><li><a class=link href=#asyncio-migration-strategy>asyncio 移植策略</a></li><li><a class=link href=#async-await-in-CPython-code-base>CPython 代码中的 <code>async/await</code></a></li></ul></li><li><a class=link href=#Grammar-Updates>语法更新</a></li><li><a class=link href=#Deprecation-Plans>失效计划</a></li></ul><p>设计思路 (暂时不考虑翻译)<br><a class=link href=#Performance>性能</a></p><ul><li><a class=link href=#Overall-Impact>总体影响</a></li><li><a class=link href=#Tokenizer-modifications>编译器修改</a></li><li><a class=link href=#async-await><code>async/await</code></a></li></ul><p><a class=link href=#Reference-Implementation>实现参考</a></p><ul><li><a class=link href=#List-of-high-level-changes-and-new-protocols>上层修改和新协议列表</a></li><li><a class=link href=#working-example>可以工作的实例</a></li></ul><p>参考</p><p>致谢</p><p>版权信息</p><h2 id=a-nameabstracta-摘要>摘要</h2><p>不断增长的网络连通性需求带动了对响应性、伸缩性代码的需求。这个 PEP 的目标在于回答如何更简单的、Pythinic 的实现显式的异步 / 并发的 Python 代码。</p><p>我们把协程概念独立出来，并为其使用新的语法。最终目标是建立一个通用、易学的 Python 异步编程模型，并尽量与同步编程的风格保持一致。</p><p>这个 PEP 假设异步任务被一个事件循环器（类似于标准库里的 asyncio.events.AbstractEventLoop）管理和调度。不过，我们并不会依赖某个事件循环器的具体实现方法，从本质上说只与此相关：使用 yield 作为给调度器的信号，表示协程将会挂起直到一个异步事件（如 IO）完成。</p><p>我们相信这些改变将会使 Python 在这个异步编程快速增长的领域能够保持一定的竞争性，就像许多其它编程语言已经、将要进行的改变那样。</p><h2 id=a-nameapi-design-and-implementation-noteaapi-设计和实现的备注>API 设计和实现的备注</h2><p>根据 Python 3.5 Beta 期间的反馈，我们进行了重新设计：明确的把协程从生成器里独立出来 &mdash; 原生协程现在拥有了自己完整的独立类型，而不再是一种新的生成器类型。</p><p>这个改变主要是为了解决在 Tornado Web 服务中里集成协程时出现的一些问题。</p><h2 id=a-namerationale-and-goalsa-基本原理和目标>基本原理和目标</h2><p>现在版本的 Python 支持使用生成器实现协程功能 (<a class=link href=https://www.python.org/dev/peps/pep-0342 target=_blank rel=noopener>PEP-342</a>)，后面通过 <a class=link href=https://www.python.org/dev/peps/pep-0380 target=_blank rel=noopener>PEP-380</a> 引入了 <code>yield from</code> 语法进行了增强。但是这样仍有一些缺点：</p><ul><li>协程与常规的生成器在相同语法时用以混淆，尤其是对心开发者而言。</li><li>一个函数是否是协程需要通过是否主体代码中使用了 <code>yield</code> 或者 <code>yield from</code> 语句进行检测，这样在重构代码中添加、去除过程中容易出现不明显的错误</li><li>异步调用的支持被 <code>yield</code> 支持的语法先定了，导致我们无法使用更多的语法特性，比如 <code>with</code> 和 <code>for</code> 语句。</li></ul><p>这个提议的目的是将协程作为原生 Python 语言特性，并且将他们与生成器明确的区分开。它避免了生成器 / 协程中间的混淆请困高，方便编写出不依赖于特定库的协程代码。这个也方便 linter 和 IDE 能够实现更好的进行静态代码分析和重构。</p><p>原生协程和相关的新语法特性使得可以在异步框架下可以定义一个上下文管理器和迭代协议。在这个提议后续中，新的 <code>async with</code> 语法让 Python 程序在进入和离开运行上下文时实现异步调用，新的 <code>async for</code> 语法可以在迭代器中实现异步调用。</p><h2 id=a-namespecificationa-语法规范>语法规范</h2><p>这个提议介绍了新的语法用于增强 Python 中的协程支持。</p><p>这个语法规范假设你已经了解 Python 现有协程实现方法 (<a class=link href=https://www.python.org/dev/peps/pep-0342 target=_blank rel=noopener>PEP-342</a> 和 <a class=link href=https://www.python.org/dev/peps/pep-0380 target=_blank rel=noopener>PEP-380</a>)。这次语法改变的动机来自于 asyncio 框架 (<a class=link href=https://www.python.org/dev/peps/pep-3156 target=_blank rel=noopener>PEP-3156</a>) 和 <code>Cofunctions</code> 提议 (<a class=link href=https://www.python.org/dev/peps/pep-3152 target=_blank rel=noopener>PEP-3152</a>，现在此提议已被废弃)。</p><p>从本文档中，我们使用 <code>原生协程</code> 代指新语法生命的函数，<code>基于生成器的协程</code> 用于表示那些基于生成器语法实现的协程。<code>协程</code> 则表示两个地方都可以使用的内容。</p><h3 id=a-namenew-coroutine-declaration-syntaxa-新协程声明语法>新协程声明语法</h3><p>下面的新语法用于声明原生协程：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read_data</span>(db):
    <span style=color:#66d9ef>pass</span>
</code></pre></div><p>协程的主要属性包括：</p><ul><li><code>async def</code> 函数始终为协程，即使它不包含 <code>await</code> 表达式。</li><li>如果在 <code>async</code> 函数中使用 <code>yield</code> 或者 <code>yield from</code> 表达式会产生 <code>SyntaxError</code> 错误。</li><li>在内部，引入了两个新的代码对象标记：<ul><li><code>CO_COROUTINE</code> 用于标记原生协程（和新语法一起定义）</li><li><code>CO_ITERABLE_COROUTINE</code> 用于标记基于生成器的协程，兼容原生协程。(通过 <code>types.coroutine()</code> 函数设置)</li></ul></li><li>常规生成器在调用时会返回一个 <code>genertor</code> 对象，同理，协程在调用时会返回一个 <code>coroutine</code> 对象。</li><li>协程不再抛出 <code>StopIteration</code> 异常，而是替代为 <code>RuntimeError</code>。常规生成器实现类似的行为需要进行引入 <code>__future__</code>(<a class=link href=https://www.python.org/dev/peps/pep-3156 target=_blank rel=noopener>PEP-3156</a>)</li><li>当协程进行垃圾回收时，一个从未被 <code>await</code> 的协程会抛出 <code>RuntimeWarning</code> 异常。(参考 <a class=link href=#Debugging-Features>调试特性</a>)</li><li>更多内容请参考 <a class=link href=#Coroutine-objects>协程对象</a> 一节。</li></ul><h3 id=a-nametype-coroutineatypescoroutine>types.coroutine()</h3><p>在 <code>types</code> 模块中新添加了一个函数 <code>coroutine(fn)</code> 用于 <code>asyncio</code> 中基于生成器的协程与本 PEP 中引入的原生携协程互通。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#a6e22e>@types.coroutine</span>
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>process_data</span>(db):
    data <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield</span> <span style=color:#f92672>from</span> read_data(db)
    <span style=color:#f92672>...</span>
</code></pre></div><p>这个函数将生成器函数对象设置 <code>CO_ITERABLE_COROUTINE</code> 标记，将返回对象变为 <code>coroutine</code> 对象。</p><p>如果 <code>fn</code> 不是一个生成器函数，那么它会对其进行封装。如果它返回一个生成器，那么它会封装一个 <code>awaitable</code> 代理对象 (参考下面 <code>awaitable</code> 对象的定义)。</p><p>注意：<code>CO_COROUTINE</code> 标记不能通过 <code>types.coroutine()</code> 进行设置，这就可以将新语法定义的原生协程与基于生成器的协程进行区分。</p><p>types 模块添加了一个新函数 coroutine(fn)，使用它，“生成器实现的协程” 和 “原生协程” 之间可以进行互操作。</p><h3 id=a-nameawait-expressionaawait-表达式>Await 表达式</h3><p>下面新的 <code>await</code> 表达式用于获取协程执行结果：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read_data</span>(db):
    data <span style=color:#f92672>=</span> await db<span style=color:#f92672>.</span>fetch(<span style=color:#e6db74>&#39;SELECT ...&#39;</span>)
    <span style=color:#f92672>...</span>
</code></pre></div><p><code>await</code> 与 <code>yield from</code> 相似，挂起 <code>read_data</code> 协程的执行直到 <code>db.fetch</code> 这个 <code>awaitable</code> 对象完成并返回结果数据。</p><p>它复用了 <code>yield from</code> 的实现，并且添加了额外的验证参数。<code>await</code> 只接受以下之一的 <code>awaitable</code> 对象：</p><ul><li>一个原生协程函数返回的原生协程对象。</li><li>一个使用 <code>types.coroutine()</code> 修饰器的函数返回的基于生成器的协程对象。</li><li>一个包含返回迭代器的 <code>__await__</code> 方法的对象。<br>任意一个 <code>yield from</code> 链都会以一个 <code>yield</code> 结束，这是 <code>Future</code> 实现的基本机制。因此，协程在内部中是一种特殊的生成器。每个 <code>await</code> 最终会被 <code>await</code> 调用链条上的某个 <code>yield</code> 语句挂起（参考 <a class=link href=https://www.python.org/dev/peps/pep-3156 target=_blank rel=noopener>PEP-3156</a> 中的进一步解释）。<br>为了启用协程的这一特点，一个新的魔术方法 <code>__await__</code> 被添加进来。在 <code>asyncio</code> 中，对于对象在 await 语句启用 <code>Future</code> 对象只需要添加 <code>__await__ = __iter__</code> 这行到 <code>asyncio.Future</code> 类中。<br>在本 PEP 中，带有 <code>__await__</code> 方法的对象也叫做 <code>Future-like</code> 对象。
同样的，请注意到 <code>__aiter__</code> 方法（下面会定义）不能用于这种目的。它是不同的协议，有点类似于用 <code>__iter__</code> 替代普通调用方法的 <code>__call___</code>。<br>如果 <code>__await__</code> 返回非迭代器类型数据，会产生一个 <code>TypeError</code>.</li><li>CPython C API 中使用 <code>tp_as_async.am_await</code> 定义的函数，并且返回一个迭代器（类似 <code>__await__</code> 方法）。</li></ul><h4 id=a-nameupdated-operator-precedence-tablea-新的操作符优先级列表>新的操作符优先级列表</h4><p>关键词 <code>await</code> 与 <code>yield</code> 和 <code>yield form</code> 操作符的区别是 <code>await</code> 表达式大部分情况下不需要括号包裹。</p><p>同样的，<code>yield from</code> 允许允许任意表达式做其参数，包含表达式如 <code>yield a()+b()</code>，这样通常处理作为 <code>yield from (a()+b())</code>，这个通常会造成 Bug。通常情况下任意算数操作的结果都不会是 <code>awaitable</code> 对象。为了避免这种情况，我们将 await 的优先级调整为低于 <code>[], () 和.</code>，但是高于 <code>**</code> 操作符。</p><table><thead><tr><th style=text-align:left>操作符</th><th style=text-align:left>描述</th></tr></thead><tbody><tr><td style=text-align:left>yield x , yield from x</td><td style=text-align:left>Yield 表达式</td></tr><tr><td style=text-align:left>lambda</td><td style=text-align:left>Lambda 表达式</td></tr><tr><td style=text-align:left>if &ndash; else</td><td style=text-align:left>条件表达式</td></tr><tr><td style=text-align:left>or</td><td style=text-align:left>布尔或</td></tr><tr><td style=text-align:left>and</td><td style=text-align:left>布尔与</td></tr><tr><td style=text-align:left>not x</td><td style=text-align:left>布尔非</td></tr><tr><td style=text-align:left>in , not in , is , is not , &lt;, &lt;= ,> , >= , != , ==</td><td style=text-align:left>比较，包含成员测试和类型测试</td></tr><tr><td style=text-align:left>|</td><td style=text-align:left>字节或</td></tr><tr><td style=text-align:left>^</td><td style=text-align:left>字节异或</td></tr><tr><td style=text-align:left>&</td><td style=text-align:left>字节与</td></tr><tr><td style=text-align:left>&#171;,&#187;</td><td style=text-align:left>移位</td></tr><tr><td style=text-align:left>+ , -</td><td style=text-align:left>加和减</td></tr><tr><td style=text-align:left>* , @ , / , // , %</td><td style=text-align:left>乘，矩阵乘法，除，取余</td></tr><tr><td style=text-align:left>+x , -x , ~x</td><td style=text-align:left>正数, 复数, 取反</td></tr><tr><td style=text-align:left>**</td><td style=text-align:left>平方</td></tr><tr><td style=text-align:left>await x</td><td style=text-align:left>Await 表达式</td></tr><tr><td style=text-align:left>x[index] , x[index:index] , x(arguments&mldr;) , x.attribute</td><td style=text-align:left>子集，切片，调用，属性</td></tr><tr><td style=text-align:left>(expressions&mldr;) , [expressions&mldr;] , {key: value&mldr;} , {expressions&mldr;}</td><td style=text-align:left>类型显示</td></tr></tbody></table><h4 id=a-nameexamples-of-await-expressionsaawait-表达式示例>await 表达式示例</h4><p>有效的语法例子:</p><table><thead><tr><th style=text-align:left>表达式</th><th style=text-align:left>会被处理为</th></tr></thead><tbody><tr><td style=text-align:left>if await fut: pass</td><td style=text-align:left>if (await fut): pass</td></tr><tr><td style=text-align:left>if await fut + 1: pass</td><td style=text-align:left>if (await fut) + 1: pass</td></tr><tr><td style=text-align:left>pair = await fut, &lsquo;spam&rsquo;</td><td style=text-align:left>pair = (await fut), &lsquo;spam&rsquo;</td></tr><tr><td style=text-align:left>with await fut, open(): pass</td><td style=text-align:left>with (await fut), open(): pass</td></tr><tr><td style=text-align:left>await foo()[&lsquo;spam&rsquo;].baz()()</td><td style=text-align:left>await (foo()[&lsquo;spam&rsquo;].baz()() )</td></tr><tr><td style=text-align:left>return await coro()</td><td style=text-align:left>return ( await coro() )</td></tr><tr><td style=text-align:left>res = await coro() ** 2</td><td style=text-align:left>res = (await coro()) ** 2</td></tr><tr><td style=text-align:left>func(a1=await coro(), a2=0)</td><td style=text-align:left>func(a1=(await coro()), a2=0)</td></tr><tr><td style=text-align:left>await foo() + await bar()</td><td style=text-align:left>(await foo()) + (await bar())</td></tr><tr><td style=text-align:left>-await foo()</td><td style=text-align:left>-(await foo())</td></tr></tbody></table><p>错误的语法例子:</p><table><thead><tr><th style=text-align:left>表达式</th><th style=text-align:left>应写作</th></tr></thead><tbody><tr><td style=text-align:left>await await coro()</td><td style=text-align:left>await (await coro())</td></tr><tr><td style=text-align:left>await -coro()</td><td style=text-align:left>await (-coro())</td></tr></tbody></table><h3 id=a-nameasynchronous-context-managersa-异步上下文管理与-async-with>异步上下文管理与 <code>async with</code></h3><p>一个异步上下文管理器是用于在 <code>enter</code> 和 <code>exit</code> 方法中管理暂停执行的上下文管理器。</p><p>为此，我们设置了新的异步上下文管理器。添加了两个魔术方法： <code>__aenter__</code> 和 <code>__aexit__</code>。这两个方法都返回 <code>awaitable</code> 对象。</p><p>异步上下文管理器例子如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AsyncContextManager</span>:
    async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__aenter__</span>(self):
        await log(<span style=color:#e6db74>&#39;entering context&#39;</span>)

    async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__aexit__</span>(self, exc_type, exc, tb):
        await log(<span style=color:#e6db74>&#39;exiting context&#39;</span>)
</code></pre></div><h4 id=a-nameasync-with-new-syntaxa-新语法>新语法</h4><p>一个新的异步上下文管理语法被接受：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>async <span style=color:#66d9ef>with</span> EXPR <span style=color:#66d9ef>as</span> VAR:
    BLOCK
</code></pre></div><p>语义上等同于：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>mgr <span style=color:#f92672>=</span> (EXPR)
aexit <span style=color:#f92672>=</span> type(mgr)<span style=color:#f92672>.</span>__aexit__
aenter <span style=color:#f92672>=</span> type(mgr)<span style=color:#f92672>.</span>__aenter__(mgr)
exc <span style=color:#f92672>=</span> True

VAR <span style=color:#f92672>=</span> await aenter
<span style=color:#66d9ef>try</span>:
    BLOCK
<span style=color:#66d9ef>except</span>:
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> await aexit(mgr, <span style=color:#f92672>*</span>sys<span style=color:#f92672>.</span>exc_info()):
        <span style=color:#66d9ef>raise</span>
<span style=color:#66d9ef>else</span>:
    await aexit(mgr, None, None, None)
</code></pre></div><p>和普通的 <code>with</code> 语句一样，可以在单个 <code>async with</code> 语句里指定多个上下文管理器。</p><p>在使用 <code>async with</code> 时，如果上下文管理器没有 <code>__aenter__</code> 和 <code>__aexit__</code> 方法，则会引发错误。在 <code>async def</code> 函数之外使用 <code>async with</code> 则会引发 <code>SyntaxError</code> 异常。</p><h4 id=a-nameasync-with-examplea-例子>例子</h4><p>通过异步上下文管理器更容易实现协程对数据库事务的正确管理：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>commit</span>(session, data):
    <span style=color:#f92672>...</span>

    async <span style=color:#66d9ef>with</span> session<span style=color:#f92672>.</span>transaction():
        <span style=color:#f92672>...</span>
        await session<span style=color:#f92672>.</span>update(data)
        <span style=color:#f92672>...</span>
</code></pre></div><p>代码看起来也更加简单：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>async <span style=color:#66d9ef>with</span> lock:
    <span style=color:#f92672>...</span>
</code></pre></div><p>而不是</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>with</span> (<span style=color:#66d9ef>yield</span> <span style=color:#f92672>from</span> lock):
    <span style=color:#f92672>...</span>
</code></pre></div><h3 id=a-nameasynchronous-iteratorsa-异步迭代器与-async-for>异步迭代器与 <code>async for</code></h3><p>一个异步迭代器能够在它的迭代实现里调用异步代码，也可以在它的 <code>__next__</code> 方法里调用异步代码。为了支持异步迭代，需要：</p><ol><li>一个对象必须实现 <code>__aiter__</code> 方法（或者，使用 CPython C API 的 tp_as_async.am_aiter 定义），返回一个异步迭代器对象中的 ```awaitable```` 结果。</li><li>一个异步迭代器必须实现 <code>__anext__</code> 方法（或者，使用 CPython C API 的 tp_as_async.am_anext 定义）返回一个 <code>awaitable</code>。</li><li>停止迭代器的 <code>__anext__</code> 必须抛出一个 <code>StopAsyncIteration</code> 异常。</li></ol><p>一个异步迭代的例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AsyncIterable</span>:
    async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__aiter__</span>(self):
        <span style=color:#66d9ef>return</span> self

    async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__anext__</span>(self):
        data <span style=color:#f92672>=</span> await self<span style=color:#f92672>.</span>fetch_data()
        <span style=color:#66d9ef>if</span> data:
            <span style=color:#66d9ef>return</span> data
        <span style=color:#66d9ef>else</span>:
            <span style=color:#66d9ef>raise</span> StopAsyncIteration

    async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fetch_data</span>(self):
        <span style=color:#f92672>...</span>
</code></pre></div><h4 id=a-nameasync-for-new-syntaxa-新语法>新语法</h4><p>一种新的异步迭代方案被采纳：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>async <span style=color:#66d9ef>for</span> TARGET <span style=color:#f92672>in</span> ITER:
    BLOCK
<span style=color:#66d9ef>else</span>:
    BLOCK2
</code></pre></div><p>语义上等同于：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>iter <span style=color:#f92672>=</span> (ITER)
iter <span style=color:#f92672>=</span> await type(iter)<span style=color:#f92672>.</span>__aiter__(iter)
running <span style=color:#f92672>=</span> True
<span style=color:#66d9ef>while</span> running:
    <span style=color:#66d9ef>try</span>:
        TARGET <span style=color:#f92672>=</span> await type(iter)<span style=color:#f92672>.</span>__anext__(iter)
    <span style=color:#66d9ef>except</span> StopAsyncIteration:
        running <span style=color:#f92672>=</span> False
    <span style=color:#66d9ef>else</span>:
        BLOCK
<span style=color:#66d9ef>else</span>:
    BLOCK2
</code></pre></div><p>如果对一个普通的不含有 <code>__aiter__</code> 方法的迭代器使用 <code>async for</code>，会引发 <code>TypeError</code> 异常。如果在 <code>async def</code> 函数外使用 <code>async for</code> 会已发 <code>SyntaxError</code> 异常。</p><p>和普通的 <code>for</code> 语法一样，<code>async for</code> 有可选的 <code>else</code> 分支。</p><h4 id=a-nameasync-for-example-1a-例子-1>例子 1</h4><p>通过异步迭代器，就可以实现通过迭代实现异步缓冲数据：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>async <span style=color:#66d9ef>for</span> data <span style=color:#f92672>in</span> cursor:
    <span style=color:#f92672>...</span>
</code></pre></div><p>当 <code>cursor</code> 是一个异步迭代器时，就可以在 N 次迭代后从数据库中预取 N 行数据。</p><p>下面的代码演示了新的异步迭代协议：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Cursor</span>:
    <span style=color:#66d9ef>def</span> __init__(self):
        self<span style=color:#f92672>.</span>buffer <span style=color:#f92672>=</span> collections<span style=color:#f92672>.</span>deque()

    async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_prefetch</span>(self):
        <span style=color:#f92672>...</span>

    async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__aiter__</span>(self):
        <span style=color:#66d9ef>return</span> self

    async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__anext__</span>(self):
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> self<span style=color:#f92672>.</span>buffer:
            self<span style=color:#f92672>.</span>buffer <span style=color:#f92672>=</span> await self<span style=color:#f92672>.</span>_prefetch()
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> self<span style=color:#f92672>.</span>buffer:
                <span style=color:#66d9ef>raise</span> StopAsyncIteration
        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>buffer<span style=color:#f92672>.</span>popleft()
</code></pre></div><p>那么这个 <code>Cursor</code> 类可以按照下面的方式使用：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>async <span style=color:#66d9ef>for</span> row <span style=color:#f92672>in</span> Cursor():
    <span style=color:#66d9ef>print</span>(row)
</code></pre></div><p>这个等同于下面的代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>i <span style=color:#f92672>=</span> await Cursor()<span style=color:#f92672>.</span>__aiter__()
<span style=color:#66d9ef>while</span> True:
    <span style=color:#66d9ef>try</span>:
        row <span style=color:#f92672>=</span> await i<span style=color:#f92672>.</span>__anext__()
    <span style=color:#66d9ef>except</span> StopAsyncIteration:
        <span style=color:#66d9ef>break</span>
    <span style=color:#66d9ef>else</span>:
        <span style=color:#66d9ef>print</span>(row)
</code></pre></div><h4 id=a-nameasync-for-example-2a-例子-2>例子 2</h4><p>下面的工具类用于将普通的迭代转换为异步。这个并没有什么实际的作用，这个代码只是用于演示普通迭代与异步迭代之间的关系。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AsyncIteratorWrapper</span>:
    <span style=color:#66d9ef>def</span> __init__(self, obj):
        self<span style=color:#f92672>.</span>_it <span style=color:#f92672>=</span> iter(obj)

    async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__aiter__</span>(self):
        <span style=color:#66d9ef>return</span> self

    async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__anext__</span>(self):
        <span style=color:#66d9ef>try</span>:
            value <span style=color:#f92672>=</span> next(self<span style=color:#f92672>.</span>_it)
        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>StopIteration</span>:
            <span style=color:#66d9ef>raise</span> StopAsyncIteration
        <span style=color:#66d9ef>return</span> value

async <span style=color:#66d9ef>for</span> letter <span style=color:#f92672>in</span> AsyncIteratorWrapper(<span style=color:#e6db74>&#34;abc&#34;</span>):
    <span style=color:#66d9ef>print</span>(letter)
</code></pre></div><h4 id=a-namewhy-stopasynciterationa-为什么使用-stopasynciteration>为什么使用 <code>StopAsyncIteration</code></h4><p>协程在内部实现中依旧是依赖于迭代器的。因此，在 <a class=link href=https://www.python.org/dev/peps/pep-0479 target=_blank rel=noopener>PEP-479</a> 生效之前，下面两者并没有区别：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>g1</span>():
    <span style=color:#66d9ef>yield</span> <span style=color:#f92672>from</span> fut
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;spam&#39;</span>
<span style=color:#f92672>and</span>

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>g2</span>():
    <span style=color:#66d9ef>yield</span> <span style=color:#f92672>from</span> fut
    <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>StopIteration</span>(<span style=color:#e6db74>&#39;spam&#39;</span>)
</code></pre></div><p>但是在 PEP 479 接受并且默认对协程开启时，下面的例子中的 <code>StopIteration</code> 会被封装成 <code>RuntimeError</code>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>a1</span>():
    await fut
    <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>StopIteration</span>(<span style=color:#e6db74>&#39;spam&#39;</span>)
</code></pre></div><p>所以，想通知外部代码迭代已经结束，抛出一个 <code>StopIteration</code> 异常的是不行的。因此，一个新的内置异常类 <code>StopAsyncIteration</code> 被引入进来了。</p><p>另外，根据 PEP 479，所有协程中抛出的 <code>StopIteration</code> 异常都会被封装成 <code>RuntimeError</code>。</p><h3 id=a-namecoroutine-objectsa-协程对象>协程对象</h3><h4 id=a-namedifferences-from-generatorsa-与生成器的不同之处>与生成器的不同之处</h4><p>这节进适用于 <code>CO_COROUTINE</code> 标记的原生协程，即，使用 <code>async def</code> 语法定义的对象。</p><p><strong>现有的 asyncio 库中的 * 基于生成器的协程 * 的行为未做变更。</strong></p><p>为了将协程与生成器区别开来，定义了下面的概念：</p><ol><li>原生协程对象不实现 <code>__iter__</code> 和 <code>__next__</code> 方法。因此，他们不能够通过 <code>iter()，list()，tuple()</code> 和其他一些内置函数进行迭代。他们也不能用于 <code>for...in</code> 循环。<br>在原生协程中尝试使用 <code>__iter__</code> 或者 <code>__next</code> 会触发 <code>TypeError</code> 异常。</li><li>未被装饰的生成器不能够 <code>yield from</code> 一个原生协程：这样会引发 <code>TypeError</code>。</li><li>基于生成器的协程 (asyncio 代码必须使用 <code>@asyncio.coroutine</code>) 可以 <code>yield from</code> 一个原生协程。</li><li>对原生协程对象和原生协程函数调用 <code>inspect.isgenerator()</code> 和 <code>inspect.isgeneratorfunction()</code> 会返回 False。</li></ol><h4 id=a-namecoroutine-object-methodsa-协程对象方法>协程对象方法</h4><p>协程内部基于生成器，因此他们同享实现过程。类似于生成器对象，协程包含 <code>throw()</code>，<code>send()</code> 和 <code>close()</code> 方法。<code>StopIteration</code> 和 <code>GeneratorExit</code> 在协程中扮演者同样的角色（尽管 PEP 479 默认对协程开启了）。参考 <a class=link href=https://www.python.org/dev/peps/pep-0342 target=_blank rel=noopener>PEP-342</a>, <a class=link href=https://www.python.org/dev/peps/pep-0380 target=_blank rel=noopener>PEP-380</a> 和 Python 文档了解更多细节。</p><p>协程的 <code>throw()</code> 和 <code>send()</code> 方法可以用于将返回值和抛出异常推送到类似于 <code>Future</code> 的对象中。</p><h3 id=a-namedebugging-featuresa-调试特性>调试特性</h3><p>一个初学者普遍会犯的错误是忘记在协程中使用 <code>yield from</code>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#a6e22e>@asyncio.coroutine</span>
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>useful</span>():
    asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>1</span>) <span style=color:#75715e># this will do noting without &#39;yield from&#39;</span>
</code></pre></div><p>为了调试这类错误，asycio 提供了一种特殊的调试模式：装饰器 <code>@coroutine</code> 封装所有的函数成一个特殊对象，这个对象的析构函数中记录警告。当封装的生成器垃圾回收时，会产生详细的记录信息，包括具体定义修饰函数、回收时的栈信息等等。封装对象同样提供一个 <code>__repr__</code> 函数用于输出关于生成器的详细信息。</p><p>唯一的问题是如何启用这些调试功能。这些调试工具在生产模式中什么都不做，<code>@coroutine</code> 修饰符在系统变量 <code>PYTHONASYNCIODEBUG</code> 设置后才会提供调试功能。这种方式可以让 asyncio 程序使用 asyncio 自己的函数分析。<code>EventLoop.set_debug</code> 是另外一个调试工具，他不会影响 <code>@coroutine</code> 修饰符行为。</p><p>根据本提议，协程是原生的与生成器不同的概念。当抛出 <code>RuntimeWarning</code> 异常的协程是从来没有被 <code>awaited</code> 过的。因此添加了两条新的函数到 sys 模块：<code>set_coroutine_wrapper</code> 和 <code>get_coroutine_wrapper</code>。这个用于开启 asyncio 或者其他框架中的高级调试 (比如显示协程创建的位置和垃圾回收时的栈信息)。</p><h3 id=a-namenew-standard-library-functionsa-新的标准库函数>新的标准库函数</h3><ul><li><code>types.coroutine(gen)</code>。参考 <a class=link href=#Type-Coroutine>types.coroutine()</a> 节中的内容。</li><li><code>inspect.iscoroutine(obj)</code> 当 obj 是原生协程时返回 True。</li><li><code>inspect.iscoroutinefunction(obj)</code> 当 obj 是原生协程函数时返回为 True。</li><li><code>inspect.isawaitable(obj)</code> 当 obj 是 <code>awaitable</code> 时返回为 True。</li><li><code>inspect.getcoroutinestate(coro)</code> 返回原生协程对象的当前状态（是 <code>inspect.getfgeneratorstate(gen)</code> 的镜像）。</li><li><code>inspect.getcoroutinelocals(coro)</code> 返回原生协程对象的局部变量的映射（是 <code>inspect.getgeneratorlocals(gen)</code> 的镜像）。</li><li><code>sys.set_coroutine_wrapper(wrapper)</code> 允许拦截原生协程对象的创建。<code>wrapper</code> 必须是一个接受一个参数 <code>callable</code>（一个协程对象），或者是 <code>None</code>。<code>None</code> 会重置 <code>wrapper</code>。当调用第二次时，新的 <code>wrapper</code> 会替代之前的封装。这个函数是线程专有的。参考 <a class=link href=#Debugging-Features>调度调试</a> 了解更多细节。</li><li><code>sys.get_coroutine_wrapper()</code> 返回当前的封装对象。如果封装未设置会返回 None。这个函数是线程专有的。参考 <a class=link href=#Debugging-Features>调度调试</a> 了解更多细节。</li></ul><h3 id=a-namenew-abstract-base-classesa-新的抽象基类>新的抽象基类</h3><p>为了允许更好的与现有的框架（比如 Tornado）和编译器（比如 Cython）整合，我们添加了两个新的抽象基类 (ABC)：<br><code>collections.abc.Awaitable</code> 是 <code>Future-like</code> 类的抽象基类，它实现了 <code>__await__</code> 方法。<br><code>collections.abc.Coroutine</code> 是协程对象的抽象基类，它实现了 <code>send(value)</code>，<code>throw(type, exc, tb)</code>，<code>close()</code> 和 <code>__await__()</code> 方法。</p><p>值得注意的是，带有 <code>CO_ITERABLE_COROUTINE</code> 标记的基于生成器的协程并没有实现 <code>__await__</code> 方法，因此他不是 <code>collections.abc.Coroutine</code> 和 <code>collections.abc.Awaitable</code> 抽象类的实例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#a6e22e>@types.coroutine</span>
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>gencoro</span>():
    <span style=color:#66d9ef>yield</span>

<span style=color:#66d9ef>assert</span> <span style=color:#f92672>not</span> isinstance(gencoro(), collections<span style=color:#f92672>.</span>abc<span style=color:#f92672>.</span>Coroutine)

<span style=color:#75715e># 然而:</span>
<span style=color:#66d9ef>assert</span> inspect<span style=color:#f92672>.</span>isawaitable(gencoro())
</code></pre></div><p>为了方便对异步迭代的调试，添加了另外两个抽象基类：</p><ul><li><code>collections.abc.AsyncIterable</code> &ndash; 用于测试 <code>__aiter__</code> 方法</li><li><code>collections.abc.AsyncIterator</code> &ndash; 用于测试 <code>__aiter__</code> 和 <code>__anext__</code> 方法。</li></ul><h2 id=a-nameglossarya-专用术语表>专用术语表</h2><h2 id=a-namelist-of-functions-and-methodsa-函数与方法列表>函数与方法列表</h2><h2 id=a-nametransition-plana-移植计划>移植计划</h2><h3 id=a-namebackwards-compatibilitya-向后兼容性>向后兼容性</h3><h4 id=a-nameasyncioaasyncio>asyncio</h4><h4 id=a-nameasyncio-migration-strategyaasyncio-移植策略>asyncio 移植策略</h4><h4 id=a-nameasync-await-in-cpython-code-baseacpython-代码中的-asyncawait>CPython 代码中的 <code>async/await</code></h4><h3 id=a-namegrammar-updatesa-语法更新>语法更新</h3><h3 id=a-namedeprecation-plansa-失效计划>失效计划</h3><h2 id=a-nameperformancea-性能>性能</h2><h3 id=a-nameoverall-impacta-总体影响>总体影响</h3><p>这个提议并不会造成性能影响。这是 Python 官方性能测试结果：</p><pre><code>python perf.py -r -b default ../cpython/python.exe ../cpython-aw/python.exe

[skipped]

Report on Darwin ysmac 14.3.0 Darwin Kernel Version 14.3.0:
Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64
x86_64 i386

Total CPU cores: 8

### etree_iterparse ###
Min: 0.365359 -&gt; 0.349168: 1.05x faster
Avg: 0.396924 -&gt; 0.379735: 1.05x faster
Significant (t=9.71)
Stddev: 0.01225 -&gt; 0.01277: 1.0423x larger

The following not significant results are hidden, use -v to show them:
django_v2, 2to3, etree_generate, etree_parse, etree_process, fastpickle,
fastunpickle, json_dump_v2, json_load, nbody, regex_v8, tornado_http.
</code></pre><h3 id=a-nametokenizer-modificationsa-编译器修改>编译器修改</h3><p>修改后的编译器处理 Python 文件没有明显的性能下降：处理 12MB 大小的文件（<code>Lib/test/test_binop.py</code> 重复 1000 次）消耗时间相同。</p><h3 id=a-nameasync-awaitaasyncawait><code>async/await</code></h3><p>下面的小测试用于检测『async』函数和生成器的性能差异：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> sys
<span style=color:#f92672>import</span> time

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>binary</span>(n):
    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
    l <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield</span> <span style=color:#f92672>from</span> binary(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
    r <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield</span> <span style=color:#f92672>from</span> binary(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
    <span style=color:#66d9ef>return</span> l <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> r

async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>abinary</span>(n):
    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
    l <span style=color:#f92672>=</span> await abinary(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
    r <span style=color:#f92672>=</span> await abinary(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
    <span style=color:#66d9ef>return</span> l <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> r

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>timeit</span>(func, depth, repeat):
    t0 <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(repeat):
        o <span style=color:#f92672>=</span> func(depth)
        <span style=color:#66d9ef>try</span>:
            <span style=color:#66d9ef>while</span> True:
                o<span style=color:#f92672>.</span>send(None)
        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>StopIteration</span>:
            <span style=color:#66d9ef>pass</span>
    t1 <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;{}({}) * {}: total {:.3f}s&#39;</span><span style=color:#f92672>.</span>format(func<span style=color:#f92672>.</span>__name__, depth, repeat, t1<span style=color:#f92672>-</span>t0))
</code></pre></div><p>结果显示并没有明显的性能差异：</p><pre><code>binary(19) * 30: total 53.321s
abinary(19) * 30: total 55.073s

binary(19) * 30: total 53.361s
abinary(19) * 30: total 51.360s

binary(19) * 30: total 49.438s
abinary(19) * 30: total 51.047s
</code></pre><p>注意：19 层意味着 1,048,575 调用。</p><h2 id=a-namereference-implementationa-实现参考>实现参考</h2><p>实现参考可以在 <a class=link href=https://github.com/1st1/cpython/tree/await target=_blank rel=noopener>这里</a> 找到。</p><h3 id=a-namelist-of-high-level-changes-and-new-protocolsa-上层修改和新协议列表>上层修改和新协议列表</h3><ol><li>新的协程定义语法：<code>async def</code> 和新的 <code>await</code> 关键字。</li><li><code>Future-like</code> 对象提供新的 <code>__await__</code> 方法和新的 <code>PyTypeObject</code> 的 <code>tp_as_async.am_await</code>。</li><li>新的异步上下文管理器语法： <code>async with</code>，协议提供了 <code>__aenter__</code> 和 <code>__aexit__</code> 方法。</li><li>新的异步迭代语法：<code>async for</code>，协议提供了 <code>__aiter</code>、<code>__aexit</code> 和新的内置异常 <code>StopAsyncIteration</code>。<code>PyTypeObject</code> 提供了新的 <code>tp_as_async.am_aiter</code> 和 <code>tp_as_async.am_anext</code>。</li><li>新的 AST 节点：<code>AsyncFunctionDef</code>，<code>AsyncFor</code>，<code>AsyncWith</code> 和 <code>Await</code>。</li><li>新函数 <code>sys.set_coroutine_wrapper(callback)</code>，<code>sys.get_coroutine_wrapper()</code>，<code>types.coroutine(gen)</code>，<code>inspect.iscoroutinefunction(func)</code>，<code>inspect.iscoroutine(obj)</code>，<code>inspect.isawaitable(obj)</code>，<code>inspect.getcoroutinestate(coro)</code> 和 <code>inspect.getcoroutinelocals(coro)</code>。</li><li>新的代码对象标记 <code>CO_COROUTINE</code> 和 <code>CO_ITERABLE_COROUTINE</code>。</li><li>新的抽象基类 <code>collections.abc.Awaitable</code>，<code>collections.abc.Coroutine</code>，<code>collections.abc.AsyncIterable</code> 和 <code>collections.abc.AsyncIterator</code>。</li><li>C API 变更：新的 <code>PyCoro_Type</code>（将 Python 作为 <code>types.CoroutineType</code> 输出）和 <code>PyCoroObject</code>。<code>PyCoro_CheckExact(*o)</code> 用于检测 o 是否为原生协程。</li></ol><p>虽然变化和新内容列表并不短，但是重要的是理解：大部分用户不会直接使用这些特性。他的目的是在于框架和库能够使用这些为用户提供便捷的使用和明确的 API 用于 <code>async def</code>，<code>await</code>，<code>async for</code> 和 <code>async with</code> 语法。</p><h3 id=a-nameworking-examplea-可以工作的实例>可以工作的实例</h3><p>本 PEP 提出的所有概念都 <a class=link href=https://github.com/1st1/cpython/tree/await target=_blank rel=noopener>已经实现</a>，并且可以被测试。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> asyncio

async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>echo_server</span>():
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;Serving on localhost:8000&#39;</span>)
    await asyncio<span style=color:#f92672>.</span>start_server(handle_connection,<span style=color:#e6db74>&#39;localhost&#39;</span>, <span style=color:#ae81ff>8000</span>)

async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>handle_connection</span>(reader, writer):
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;New connection...&#39;</span>)

    <span style=color:#66d9ef>while</span> True:
        data <span style=color:#f92672>=</span> await reader<span style=color:#f92672>.</span>read(<span style=color:#ae81ff>8192</span>)

        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> data:
            <span style=color:#66d9ef>break</span>

        <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;Sending {:.10}... back&#39;</span><span style=color:#f92672>.</span>format(repr(data)))
        writer<span style=color:#f92672>.</span>write(data)

loop <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>get_event_loop()
loop<span style=color:#f92672>.</span>run_until_complete(echo_server())
<span style=color:#66d9ef>try</span>:
    loop<span style=color:#f92672>.</span>run_forever()
<span style=color:#66d9ef>finally</span>:
    loop<span style=color:#f92672>.</span>close()
</code></pre></div></section><footer class=article-footer><section class=article-tags><a href=../../../tags/python/>Python</a>
<a href=../../../tags/async/>async</a>
<a href=../../../tags/asyncio/>asyncio</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>相关文章</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=../../../2016/02/2016-02-03-simple-implement-asyncio-to-understand-how-async-works/><div class=article-details><h2 class=article-title>从 asyncio 简单实现看异步是如何工作的</h2></div></a></article><article><a href=../../../2015/11/2015-11-11-async-python/><div class=article-details><h2 class=article-title>Python 异步与性能迷思</h2></div></a></article><article><a href=../../../2015/10/2015-10-30-write-aio-python-redis-client-as-dummy-2/><div class=article-details><h2 class=article-title>从零实现一个 Redis 客户端（二）</h2></div></a></article><article><a href=../../../2015/10/2015-10-10-write-aio-python-redis-client-as-dummy-1/><div class=article-details><h2 class=article-title>零基础编写 Python Redis Client（一）</h2></div></a></article><article><a href=../../../2015/08/2015-08-14-introduction-to-async-and-await/><div class=article-details><h2 class=article-title>Python async/await 入门</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"s1mbily"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener('onColorSchemeChange',(e)=>{if(DISQUS){DISQUS.reset({reload:true});}})</script><footer class=site-footer><section class=copyright>&copy;
2013 -
2021 ipfans's Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=2.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=../../../ts/main.js defer></script><script>(function(){const customFont=document.createElement('link');customFont.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";customFont.type="text/css";customFont.rel="stylesheet";document.head.appendChild(customFont);}());</script></body></html>